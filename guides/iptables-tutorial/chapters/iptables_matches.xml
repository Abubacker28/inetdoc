<chapter xml:id="matches">
  <title xml:id="matches.title">Correspondances Iptables</title>
  <indexterm zone="matches">
    <primary>Match</primary>
  </indexterm>
  <indexterm zone="matches">
    <primary>Iptables matches</primary>
    <seealso>Match</seealso>
  </indexterm>
  
   <para>
Cette section permet d'approfondir les correspondances. Elles sont
intentionnellement classées en cinq catégories distinctes.
En premier, on trouve les <emphasis>correspondances génériques</emphasis> qui
s'emploient avec toutes les règles. Ensuite, il y a les
<emphasis>correspondances TCP</emphasis> qui ne s'appliquent qu'aux paquets
<systemitem>TCP</systemitem>. De même, pour les
<emphasis>correspondances UDP</emphasis> qui ne s'appliquent qu'aux paquets
<systemitem>UDP</systemitem>, et les <emphasis>correspondances ICMP</emphasis>
qui ne s'appliquent qu'aux paquets <systemitem>ICMP</systemitem>.
Et à la fin, on décrit les <emphasis>correspondances spéciales</emphasis>,
comme les correspondances d'état, de propriétaire, de limite, etc...
Ces dernières correspondances sont réparties en autant de sous-catégories,
même si elles ne se révèlent pas singulièrement si différentes.
J'espère que cette répartition est suffisamment cohérente pour être
compréhensible.
   </para>

   <para>
Comme vous l'avez peut être déjà compris si vous avez lu les chapitres
précédents, une correspondance est quelque chose qui spécifie une
condition spéciale dans le paquet et qui doit être vraie (ou fausse).
Une seule règle peut contenir plusieurs correspondances de cette sorte.
Par exemple, nous voulons sélectionner des paquets issus d'un hôte spécifique
sur notre réseau local, et seulement des ports particuliers sur cet hôte.
Nous utilisons alors les correspondances qui indiquent la règle à appliquer
à la cible - ou saut - sur les paquets qui ont une adresse source spécifique,
arrivant sur l'interface connectée au réseau local et ces paquets doivent
être sur un des ports spécifiés. Si une de ces correspondances est erronée
(ex. l'adresse source est incorrecte, mais le reste est correct), la règle
complète échoue et la règle suivante est testée sur le paquet.
Si toutes les correspondances sont vraies, la cible spécifiée par la règle
est appliquée.
   </para>
   
   <section xml:id="genericmatches">
    <title xml:id="genericmatches.title">Correspondances génériques</title>
    <indexterm zone="genericmatches">
      <primary>Match</primary>
      <secondary>Generic</secondary>
    </indexterm>
    <indexterm zone="genericmatches">
      <primary>Generic matches</primary>
    </indexterm>

    <para>
Les <emphasis>correspondances génériques</emphasis> désignent un
type de correspondance toujours disponible, et ce quel que soit le protocole
concerné ou les extensions de correspondances chargées. Autrement dit,
ces correspondances ne requièrent aucun paramètre particulier.
La correspondance <command>--protocol</command> a été délibérément incluse
ici, bien qu'elle s'adresse spécifiquement aux protocoles. Par exemple, si
vous désirez utiliser une <emphasis>correspondance TCP</emphasis>, vous devez
appeler la correspondance <command>--protocol</command> et lui fournir
<systemitem>TCP</systemitem> pour option. Pourtant,
<command>--protocol</command> est également en elle-même une correspondance
générique, puisqu'elle permet d'établir une correspondance avec des
protocoles différents. Les correspondances suivantes sont donc toujours
disponibles.
   </para>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--protocol</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--protocol</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>Protocol match</primary>
   </indexterm>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--source</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--source</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>Source match</primary>
   </indexterm>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--destination</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--destination</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>Destination match</primary>
   </indexterm>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--in-interface</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--in-interface</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>In-interface match</primary>
   </indexterm>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--out-interface</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--out-interface</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>Out-interface match</primary>
   </indexterm>

   <indexterm zone="table.genericmatches">
     <primary>Match</primary>
     <secondary>--fragment</secondary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>--fragment</primary>
   </indexterm>
   <indexterm zone="table.genericmatches">
     <primary>Fragment match</primary>
   </indexterm>
 
   
   <table frame='all' xml:id="table.genericmatches">
    <title xml:id="table.genericmatches.title">Correspondances génériques</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>

     <colspec colwidth='1.5*'/>
     <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>-p</command>, <command>--protocol</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance permet de vérifier le type de protocole,
par exemple <systemitem>TCP</systemitem>, <systemitem>UDP</systemitem> ou
<systemitem>ICMP</systemitem>. De plus, le protocole doit nécessairement soit
faire partie des protocoles définis en interne comme TCP, UDP ou ICMP, soit
prendre une valeur spécifiée dans le fichier <link linkend="protocolstxt" 
endterm="protocolstxt.title"></link>, ce qui, si elle ne s'y trouve pas,
retourne une erreur. Le protocole peut aussi être entré sous forme d'un nombre
entier. A titre d'exemple, le protocole ICMP est identifié par la valeur
entière 1, TCP par la valeur 6 et UDP par 17. Enfin, le protocole
peut aussi prendre la valeur ALL. <emphasis>ALL</emphasis> signifie tous,
donc il établit une correspondance avec tous les protocoles TCP, UDP et ICMP.
La commande accepte aussi une liste de protocoles séparés par des virgules,
telle que <command>udp,tcp</command> qui permet d'établir une correspondance
avec tous les paquets <systemitem>UDP</systemitem> et
<systemitem>TCP</systemitem>. Si on désigne le protocole par la valeur zéro
(0), ceci est équivalent à ALL, soit tous les protocoles, qui est aussi la
valeur par défaut si la correspondance <command>--protocol</command> est
omise. Cette correspondance peut également être inversée à l'aide du symbole
<command>!</command>. Dans ce cas, <command>--protocol ! tcp</command>
identifie les protocoles différents de <systemitem>TCP</systemitem>,
et établit donc une correspondance avec <systemitem>UDP</systemitem> et 
<systemitem>ICMP</systemitem>.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>-s</command>, <command>--src</command>,
<command>--source</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -s 192.168.1.1</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
C'est la correspondance de source. Elle sert à sélectionner
les paquets à partir de leur adresse IP source. La forme principale permet
d'établir une correspondance avec des adresses IP uniques, telles que 
<emphasis>192.168.1.1</emphasis>. Mais il est possible d'employer un masque
réseau sous une forme binaire de type CIDR, en spécifiant le nombre de "1"
dans la partie gauche du masque réseau. Par exemple, ajouter
<emphasis>/24</emphasis> signifie utiliser le masque réseau 
<emphasis>255.255.255.0</emphasis>. Ainsi, un intervalle complet d'adresses
IP peut être détecté, comme celui d'un réseau local ou d'un sous-réseau
derrière un pare-feu. La commande ressemble alors à
<emphasis>192.168.0.0/24</emphasis>, qui établit une correspondance avec les
paquets de l'intervalle <emphasis>192.168.0.x</emphasis>. Une autre méthode
consiste à utiliser un masque réseau ordinaire de la forme 
<emphasis>255.255.255.255</emphasis>, ce qui donne au final
<emphasis>192.168.0.0/255.255.255.0</emphasis>. On peut également inverser la
sélection avec un <command>!</command> comme précédemment. Ainsi, avec
une correspondance du type <command>--source ! 192.168.0.0/24</command>, on
établit une correspondance avec tous les paquets dont l'adresse source
n'appartient pas à l'intervalle <emphasis>192.168.0.x</emphasis>. Le
comportement par défaut sélectionne toutes les adresses IP.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>-d</command>, <command>--dst</command>,
<command>--destination</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -d 192.168.1.1</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
La correspondance <command>--destination</command> est
utilisée pour sélectionner les paquets à partir de leur(s) adresse(s)
destination. Ceci fonctionne sensiblement comme la correspondance
<command>--source</command> et avec la même syntaxe, excepté qu'on
s'intéresse ici à la destination des paquets. Pour correspondre avec un
intervalle d'adresses IP, on peut ajouter un masque réseau soit sous sa forme
exacte, soit avec le nombre de 1 compris dans la partie gauche du masque
réseau sous forme binaire. voici des exemples :
<emphasis>192.168.0.0/255.255.255.0</emphasis> et
<emphasis>192.168.0.0/24</emphasis>. Les deux sont parfaitement équivalents.
Il est toujours possible d'inverser la sélection à l'aide du signe
<command>!</command> comme précédemment.
<command>--destination ! 192.168.0.1</command> établit une correspondance
avec tous les paquets sauf ceux qui sont destinés à l'adresse IP
<emphasis>192.168.0.1</emphasis>.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>-i</command>, 
<command>--in-interface</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -i eth0</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance est destinée à sélectionner les paquets
issus d'une certaine interface. Remarquez que cette option n'est autorisée
que dans les chaînes <systemitem>INPUT</systemitem>,
<systemitem>FORWARD</systemitem> et <systemitem>PREROUTING</systemitem>,
et qu'elle retourne une erreur si elle est utilisée ailleurs. Si aucune
interface n'est spécifiée, le comportement par défaut présuppose que le
caractère <command>+</command> a été omis. Ce caractère permet d'établir une
correspondance avec une chaîne de caractères (composée de lettres et
chiffres). Un simple <command>+</command> stipule au noyau de reconnaître
tous les paquets sans identifier leur interface d'origine. Le caractère
<command>+</command> peut également être juxtaposé au type d'interface, donc
<command>eth+</command> désigne tous les périphériques Ethernet.
Le sens de cette option peut être inversée à l'aide du symbole  
<command>!</command>. Une ligne dont la syntaxe est
<command>-i ! eth0</command> cherche à correspondre à toutes les interfaces
d'entrée, sauf <systemitem>eth0</systemitem>.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>-o</command>, 
<command>--out-interface</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A FORWARD -o eth0</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
La correspondance <command>--out-interface</command> permet de
sélectionner les paquets en fonction de l'interface par laquelle ils sortent.
Remarquez que cette correspondance n'est disponible que pour les chaînes
<systemitem>OUTPUT</systemitem>, <systemitem>FORWARD</systemitem> et
<systemitem>POSTROUTING</systemitem>, à l'opposé de la correspondance
<command>--in-interface</command>. A part ça, elle fonctionne presque de la
même façon. L'extension <command>+</command> traduit une correspondance avec
des périphériques similaires, ainsi <command>eth+</command> établit une
correspondance avec tous les périphériques de type
<systemitem>eth</systemitem>, et ainsi de suite. Pour inverser le sens de la
sélection, utilisez le signe <command>!</command> exactement comme pour la
correspondance <command>--in-interface</command>. Si aucune interface de
sortie n'est spécifiée avec <command>--out-interface</command>, le
comportement par défaut accepte tous les périphériques, indépendemment de la
direction prise par les paquets.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>-f</command>, <command>--fragment</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -f</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance est destinée à sélectionner le deuxième
et le troisième fragment d'un paquet fragmenté. En fait, dans le cas d'un
paquet fragmenté, il est impossible de connaître ni les ports source ou
destination des fragments, ni les types <systemitem>ICMP</systemitem>, ni
d'autres choses encore. Ainsi, les paquets fragmentés peuvent être utilisés
dans des cas très particuliers pour organiser des attaques contre des
ordinateurs. De tels fragments ne correspondent à aucune autre règle, ce qui
a conduit à créer celle-ci. Cette option peut aussi être employée avec le
symbole <command>!</command> ; mais exceptionnellement ici, le signe
<command>!</command> doit précéder la correspondance, c'est-à-dire
<command>! -f</command>. Quand cette correspondance est inversée, elle
sélectionne tous les fragments d'en-tête et/ou tous les paquets non
fragmentés. Ceci signifie qu'on établit une correspondance avec tous les
premiers fragments des paquets fragmentés, et pas avec les deuxièmes,
troisièmes, et ainsi de suite. On établit aussi une correspondance avec les
paquets qui n'ont pas été fragmentés pendant le transfert. Notez qu'il y a
d'excellentes options de défragmentation dans le noyau, et qui peuvent se
substituer à cette correspondance. Notez également que si vous utilisez le 
traçage de connexion, vous ne verrez aucun paquet fragmenté, puisqu'ils sont
pris en compte avant d'atteindre les chaînes ou les tables dans
<command>iptables</command>.
</entry>
       </row>

     </tbody>
     </tgroup>
    </table>

   </section>

   <section xml:id="implicitmatches">
    <title xml:id="implicitmatches.title">Correspondances implicites</title>
    <indexterm zone="implicitmatches">
      <primary>Match</primary>
      <secondary>Implicit</secondary>
    </indexterm>
    <indexterm zone="implicitmatches">
      <primary>Implicit matches</primary>
    </indexterm>

    <indexterm zone="implicitmatches">
      <primary>Match</primary>
      <secondary>--match</secondary>
    </indexterm>
    <indexterm zone="implicitmatches">
      <primary>--match</primary>
    </indexterm>
 
    <para>
Cette section se charge de décrire les correspondances
chargées implicitement. Ces <emphasis>correspondances implicites</emphasis>
sont sous-jacentes, acquises et automatiques. Par exemple, lorsqu'on établit
une correspondance avec <command>--protocol tcp</command> sans autre critère.
Il y a actuellement trois types de correspondances implicites pour trois
protocoles différents : les <emphasis>correspondances TCP</emphasis>,
les <emphasis>correspondances UDP</emphasis> et les <emphasis>correspondances
ICMP</emphasis>. Les correspondances basées sur <systemitem>TCP</systemitem>
contiennent un ensemble de critères uniquement valables pour les paquets
<systemitem>TCP</systemitem>. De même pour les correspondances 
<systemitem>UDP</systemitem> et <systemitem>ICMP</systemitem>. D'un autre
côté, il peut aussi y avoir des correspondances explicites, c'est-à-dire
chargées explicitement. Les <emphasis>correspondances explicites</emphasis>
ne sont ni sous-jacentes, ni automatiques, vous devez obligatoirement les
spécifier. Pour celles-ci, utilisez l'option <command>-m</command> ou
<command>--match</command>, qui est abordée dans la section suivante.
   </para>

   <section xml:id="tcpmatches">
    <title xml:id="tcpmatches.title">Correspondances TCP</title>
    <indexterm zone="tcpmatches">
      <primary>Match</primary>
      <secondary>TCP</secondary>
      <seealso>TCP match</seealso>
    </indexterm>
    <indexterm zone="tcpmatches">
      <primary>TCP match</primary>
    </indexterm>

    <para> 
Ces correspondances sont dédiées à un protocole, et en l'occurence
elles sont seulement disponibles pour des paquets ou des flux
<systemitem>TCP</systemitem>. Pour utiliser ces correspondances, vous devez
ajouter <command>--protocol tcp</command> à la ligne de commande avant de
vous en servir. Notez bien que <command>--protocol tcp</command>
doit précéder (donc être situé à gauche) les correspondances spécifiques au
protocole. Celles-ci peuvent être chargées implicitement de la même façon que
peuvent l'être les <emphasis>correspondances UDP</emphasis> et
<emphasis>ICMP</emphasis>. Les autres correspondances sont développées à la
suite de cette section.
    </para>
    <indexterm zone="table.tcpmatches">
      <primary>TCP match</primary>
      <secondary>--source-port</secondary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>--source-port</primary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>Source-port match</primary>
    </indexterm>
 
    <indexterm zone="table.tcpmatches">
      <primary>TCP match</primary>
      <secondary>--destination-port</secondary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>--destination-port</primary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>Destination-port match</primary>
    </indexterm>
  
    <indexterm zone="table.tcpmatches">
      <primary>TCP match</primary>
      <secondary>--tcp-flags</secondary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>--tcp-flags</primary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>Tcp-flags match</primary>
    </indexterm>
   
    <indexterm zone="table.tcpmatches">
      <primary>TCP match</primary>
      <secondary>--syn</secondary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>--syn</primary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>Syn match</primary>
    </indexterm>
   
    <indexterm zone="table.tcpmatches">
      <primary>TCP match</primary>
      <secondary>--tcp-option</secondary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>--tcp-option</primary>
    </indexterm>
    <indexterm zone="table.tcpmatches">
      <primary>Tcp-option match</primary>
    </indexterm>
 
    <table frame='all' xml:id="table.tcpmatches">
     <title xml:id="table.tcpmatches.title">Correspondances TCP</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--sport</command>,
<command>--source-port</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp --sport 22</command></entry>
       </row>

       <row>
        <entry>Explication</entry>
        <entry>
La correspondance <command>--source-port</command> permet de
sélectionner des paquets à partir de leur port source. Sans cela, on
sous-entend tous les ports source. La correspondance accepte indifféremment
un nom de service ou un numéro de port. Si vous spécifiez un nom de service,
celui-ci doit figurer dans le fichier <link linkend="servicestxt"
endterm="servicestxt.title"></link>, parce qu'<command>iptables</command>
s'appuie sur ce fichier pour identifier le service. Si vous spécifiez le port
par son numéro, la règle sera chargée légèrement plus vite, puisqu'
<command>iptables</command> n'a pas à valider le nom du service. Cependant,
la correspondance risque d'être un peu plus difficile à lire qu'avec un nom
de service. Si vous écrivez une table de règles constituée de plus de 200
règles, vous devriez utiliser les numéros de port, car la différence devient
sensible (sur une machine lente, ceci peut conduire à un écart de 10
secondes, si vous avez défini une table de règles contenant au moins
1000 règles).
La correspondance <command>--source-port</command> permet aussi de
sélectionner n'importe quel intervalle de ports. Par exemple,
<command>--source-port 22:80</command> établit une correspondance avec tous
les ports source compris entre 22 et 80. Si vous omettez la spécification du
premier port, le port 0 est implicitement considéré. Ainsi,
<command>--source-port :80</command> permet d'établir une correspondance avec
les ports de 0 à 80. Et si vous omettez la spécification du dernier port, le
port 65535 est considéré. Ainsi, <command>--source-port 22:</command> permet
d'établir une correspondance avec tous les ports de 22 à 65535. Si vous
intervertissez les ports de l'intervalle, <command>iptables</command> corrige
automatiquement en réordonnant les numéros. Donc, écrire
<command>--source-port 80:22</command> est naturellement interprété
<command>--source-port 22:80</command>.
Une correspondance peut être inversée en ajoutant le symbole
<command>!</command>. Par exemple, <command>--source-port ! 22</command>
signifie établir une correspondance avec tous les ports sauf le port 22.
L'inversion peut s'appliquer aussi à un intervalle de ports, comme par
exemple <command>--source-port ! 22:80</command> qui établit une
correspondance avec tous les ports sauf ceux de l'intervalle 22 à 80.
Notez que cette correspondance n'accepte pas plusieurs ports ou intervalles
de ports distincts. Pour plus d'information sur cette possibilité, consultez
l'extension de correspondance multiport.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--dport</command>,
<command>--destination-port</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp --dport 22</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance permet de sélectionner des paquets
<systemitem>TCP</systemitem> en fonction de leur port de destination. Elle
s'appuie sur la même syntaxe que la correspondance
<command>--source-port</command>. Elle comprend les spécifications de ports
et d'intervalle de ports, ainsi que l'option d'inversion. De même, elle
intervertit si nécessaire les premier et dernier ports dans la spécification
d'intervalle, comme ci-dessus. Cette correspondance considère également par
défaut les valeurs de ports de 0 et 65535 si les extrémités d'intervalle sont
omises. En définitive, elle fonctionne exactement selon la même syntaxe que
<command>--source-port</command>.
Notez que cette correspondance n'accepte pas plusieurs ports ou intervalles
de ports distincts. Pour plus d'information sur cette possibilité, consultez
l'extension de correspondance multiport.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--tcp-flags</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -p tcp --tcp-flags SYN,FIN,ACK
SYN</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance permet de sélectionner les paquets à
partir de leurs fanions <systemitem>TCP</systemitem>. En premier, la
correspondance nécessite une liste de fanions à tester (un masque) suivie de
la liste des fanions qui doivent être positionnés à 1 (donc activés). Dans
les deux listes, les fanions sont séparés par des virgules. La correspondance
reconnaît les fanions <systemitem>SYN</systemitem>,
<systemitem>ACK</systemitem>, <systemitem>FIN</systemitem>,
<systemitem>RST</systemitem>, <systemitem>URG</systemitem> et
<systemitem>PSH</systemitem>. Elle accepte aussi les mots
<systemitem>ALL</systemitem> et <systemitem>NONE</systemitem>
dont le sens est plutôt intuitif : ALL équivaut à tous les
fanions et NONE à aucun. Typiquement, <command>--tcp-flags ALL NONE</command>
vérifie tous les fanions <systemitem>TCP</systemitem> et établit une
correspondance si aucun n'est activé (donc positionné à 1). Cette option peut
également être inversée à l'aide du signe <command>!</command>. Par exemple,
spécifier <command>! SYN,FIN,ACK SYN</command> revient à faire correspondre
les paquets qui possèdent les bits <systemitem>ACK</systemitem> et
<systemitem>FIN</systemitem> activés, mais pas le bit
<systemitem>SYN</systemitem>. Notez que la séparation des fanions par des
virgules ne doit inclure aucune espace, comme vous pouvez le voir dans
l'exemple ci-dessus.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--syn</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -p tcp --syn</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
La correspondance <command>--syn</command> est plus ou moins
une relique du règne d'ipchains. Elle perdure pour garantir une certaine
rétro-compatibilité et simplifier la transition vers
<command>iptables</command>. Elle permet d'établir une correspondance avec
des paquets s'ils possèdent le bit <systemitem>SYN</systemitem> activé et les
bits <systemitem>ACK</systemitem> et <systemitem>RST</systemitem> désactivés.
Cette commande se comporte rigoureusement comme la correspondance
<command>--tcp-flags SYN,RST,ACK SYN</command>. Les paquets de ce type
servent principalement aux demandes de connexion en provenance de serveurs.
Si vous bloquez ces paquets, vous devriez effectivement empêcher toutes les
tentatives de connexions entrantes. Toutefois, vous ne bloquerez pas les
connexions sortantes, qui sont mises à profit aujourd'hui par de nombreux
exploits (par exemple, détourner un service légitime pour installer
localement un programme ou créer une liaison à partir d'une connexion
existante sur votre hôte au lieu d'ouvrir un nouveau port).
Cette correspondance peut également être inversée à l'aide du signe
<command>!</command>. Ainsi, <command>! --syn</command> correspond à tous les
paquets ayant les bits <systemitem>RST</systemitem> ou
<systemitem>ACK</systemitem> activés, autrement dit les paquets appartenant à
une connexion déjà établie.
</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--tcp-option</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -p tcp --tcp-option 16</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance permet d'établir une correspondance avec
des paquets suivant leurs options <systemitem>TCP</systemitem>. Une
<systemitem>option TCP</systemitem> identifie une partie spécifique de
l'en-tête des paquets. Cette partie contient 3 champs différents.
Le premier a une longueur de 8 bits et décrit les options utilisées dans
ce flux ; le deuxième s'étend aussi sur 8 bits et précise la
longueur du champ des options. L'information de longueur du champ doit son
existence au caractère optionnel des <systemitem>options TCP</systemitem>.
Pour être conforme aux standards, il n'est pas utile d'implémenter toutes les
options, il suffit de les identifier. Si elles ne sont pas prises en
charge, on lit seulement l'information de longueur afin de sauter par-dessus
ces données. Cette correspondance permet de sélectionner plusieurs options
<systemitem>TCP</systemitem> en fonction de leurs valeurs numériques. Elle
peut également être inversée avec le signe <command>!</command>, de telle
sorte que la correspondance s'établisse avec toutes les options
<systemitem>TCP</systemitem> sauf celle passée en paramètre. Pour obtenir la
liste complète des options, consultez le site
<link linkend="ietf" endterm="ietf.title"></link> qui contient une liste de
toutes les valeurs standard employées sur Internet.
</entry>
       </row>

     </tbody>
     </tgroup>
    </table>

   </section>


   <section xml:id="udpmatches">
    <title xml:id="udpmatches.title">Correspondances UDP</title>
    <indexterm zone="udpmatches">
      <primary>Match</primary>
      <secondary>UDP</secondary>
      <seealso>UDP match</seealso>
    </indexterm>
    <indexterm zone="udpmatches">
      <primary>UDP</primary>
    </indexterm>

    <para> 
 Cette section décrit les correspondances qui fonctionnent seulement
avec des paquets <systemitem>UDP</systemitem>. Elles sont chargées
implicitement lorsque la correspondance <command>--protocol UDP</command>
est spécifiée et elles ne sont effectivement disponible qu'après
cette spécification. Notez que les paquets <systemitem>UDP</systemitem> ne
sont pas orientés connexion, et par conséquent ils ne possèdent pas de fanions
particuliers pour informer du rôle joué par le datagramme tel que l'ouverture
ou la fermeture d'une connexion, ou encore le simple envoi de données.
Les paquets <systemitem>UDP</systemitem> ne nécessitent aucun accusé de
réception. S'ils s'égarent sur le réseau, ils n'engendrent aucune action
(aucun message d'erreur de type <systemitem>ICMP</systemitem> n'est expédié).
Autrement dit, il existe nettement moins de correspondances associées aux
paquets <systemitem>UDP</systemitem> qu'aux paquets
<systemitem>TCP</systemitem>. Notez que la machine d'état fonctionne sur
tous les types de paquets, même si les paquets <systemitem>UDP</systemitem>
et <systemitem>ICMP</systemitem> appartiennent à des protocoles sans
connexion. La machine d'état fonctionne quasiment de la même façon pour les
paquets <systemitem>UDP</systemitem> que pour les paquets
<systemitem>TCP</systemitem>.
    </para>
  
    <indexterm zone="table.udpmatches">
      <primary>UDP match</primary>
      <secondary>--source-port</secondary>
    </indexterm>
    <indexterm zone="table.udpmatches">
      <primary>--source-port</primary>
    </indexterm>
    <indexterm zone="table.udpmatches">
      <primary>Source-port match</primary>
    </indexterm>
   
    <indexterm zone="table.udpmatches">
      <primary>UDP match</primary>
      <secondary>--destination-port</secondary>
    </indexterm>
    <indexterm zone="table.udpmatches">
      <primary>--destination-port</primary>
    </indexterm>
    <indexterm zone="table.udpmatches">
      <primary>Destination-port match</primary>
    </indexterm>
 
    <table frame='all' xml:id="table.udpmatches">
     <title xml:id="table.udpmatches.title">Correspondances UDP</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--sport</command>,
<command>--source-port</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p udp --sport 53</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
<entry>
 Cette correspondance fonctionne exactement comme son équivalent
<systemitem>TCP</systemitem>. Elle permet d'établir des correspondances
avec des paquets à partir de leurs ports source <systemitem>UDP</systemitem>.
Elle prend en charge les intervalles de ports, les ports uniques et les
inversions de ports selon la même syntaxe. Pour spécifier un intervalle de
ports <systemitem>UDP</systemitem>, vous pouvez utiliser 22:80 qui établit une
correspondance avec les ports <systemitem>UDP</systemitem> de 22 à 80. Si le
premier numéro est omis, il est considéré par défaut comme étant le port 0. Si
le dernier numéro est omis, le port 65535 est pris par défaut. Si le port le
plus grand est mis avant le plus petit, les numéros sont intervertis
automatiquement. Dans le cas d'un port <systemitem>UDP</systemitem> unique, la
syntaxe se calque sur l'exemple ci-dessus. Pour inverser la correspondance de
port, il suffit d'insérer le signe <command>!</command>. Dans
<command>--source-port ! 53</command>, la correspondance s'établit avec tous les
ports sauf le numéro 53. Cette correspondance comprend les noms de service, du
moment qu'ils sont disponibles dans le fichier <link linkend="servicestxt" 
endterm="servicestxt.title"></link>. Notez que cette correspondance n'accepte
pas les ports et les intervalles de ports distincts. Pour davantage
d'information, consultez l'extension de correspondance multiport. 

</entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--dport</command>,
<command>--destination-port</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p udp --dport 53</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
Cette correspondance s'apparente fortement à
<command>--source-port</command> décrite ci-dessus. Elle est aussi très
proche de la correspondance <systemitem>TCP</systemitem> équivalente, sauf
qu'elle s'applique aux paquets <systemitem>UDP</systemitem>. Elle établit une
correspondance à partir du port destination <systemitem>UDP</systemitem>.
Elle accepte les intervalles de ports, les ports uniques et les inversions.
Pour sélectionner un port unique, vous pouvez utiliser par exemple
<command>--destination-port 53</command> ; pour l'inverser, ce sera
plutôt <command>--destination-port ! 53</command>. La première commande
sélectionnne tous les paquets <systemitem>UDP</systemitem> en direction du
port 53, alors que la seconde sélectionne tous les paquets sauf ceux destinés
au port 53. Pour spécifier un intervalle de ports, utilisez par exemple
<command>--destination-port 9:19</command> pour établir une correspondance
avec tous les paquets destinés aux ports <systemitem>UDP</systemitem> compris
entre 9 et 19. Si le premier port est omis, on considère le port 0 par
défaut. Si le second est omis, on considère le port 65535 par défaut. Si le
port le plus grand est placé avant le plus petit, ils sont interchangés
automatiquement pour que le plus petit port précède le plus grand. Notez que
cette correspondance n'accepte pas les ports et intervalles de ports
distincts. Pour plus d'information, consultez l'extension de correspondance
multiport.
</entry>
       </row>

     </tbody>
     </tgroup>
    </table>

   </section>


   <section xml:id="icmpmatches">
    <title xml:id="icmpmatches.title">Correspondances ICMP</title>
    <indexterm zone="icmpmatches">
      <primary>Match</primary>
      <secondary>ICMP</secondary>
      <seealso>ICMP match</seealso>
    </indexterm>
    <indexterm zone="icmpmatches">
      <primary>ICMP match</primary>
    </indexterm>

    <para> 
Abordons maintenant les <emphasis>correspondances ICMP</emphasis>.
Les paquets <systemitem>ICMP</systemitem> sont de nature éphémère,
c'est-à-dire qu'ils ont une vie courte, plus courte que les paquets
<systemitem>UDP</systemitem> dans le sens où ils sont sans connexion. Le
protocole <systemitem>ICMP</systemitem> sert principalement aux
messages d'erreur, aux contrôles de connexion, et d'autres choses du même
acabit. <systemitem>ICMP</systemitem> n'est pas un protocole subordonné au
protocole IP, mais plutôt qui enrichit le protocole IP et concourt à la
gestion des erreurs. L'en-tête des paquets <systemitem>ICMP</systemitem>
ressemble à celle des paquets IP, mais diffère sur certains aspects. La
caractéristique primordiale de ce protocole provient du type d'en-tête, qui
traduit la raison d'être du paquet. A titre d'exemple, si on tente d'accéder
à une adresse IP inaccessible, on récupère normalement en retour un
<computeroutput>ICMP host unreachable</computeroutput> (machine
injoignable). Pour voir la liste complète des types
<systemitem>ICMP</systemitem>, consultez l'annexe <link
linkend="icmptypes" endterm="icmptypes.title"></link>. Une seule
correspondance <systemitem>ICMP</systemitem> spécifique est disponible pour
les paquets <systemitem>ICMP</systemitem>, et heureusement, elle devrait
suffire. Cette correspondance est chargée implicitement quand on spécifie
<command>--protocol ICMP</command>, et on en dispose automatiquement. Notez
que toutes les correspondances génériques sont utilisables, et qu'elles
permettent par exemple de sélectionner les adresses source et destination.
    </para>
   
    <indexterm zone="table.icmpmatches">
      <primary>ICMP match</primary>
      <secondary>--icmp-type</secondary>
    </indexterm>
    <indexterm zone="table.icmpmatches">
      <primary>--icmp-type</primary>
    </indexterm>
    <indexterm zone="table.icmpmatches">
      <primary>Icmp-type match</primary>
    </indexterm>
 
    <table frame='all' xml:id="table.icmpmatches">
     <title xml:id="table.icmpmatches.title">Correspondances ICMP</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--icmp-type</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.3, 2.4, 2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p icmp --icmp-type
8</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance permet de spécifier le <systemitem>type
ICMP</systemitem> à sélectionner. Les <systemitem>types ICMP</systemitem>
peuvent être définis soit par leur valeur numérique, soit par leur nom. Les
valeurs numériques sont spécifiés dans le RFC 792. Pour afficher la liste
complète des noms <systemitem>ICMP</systemitem>, exécutez la commande
<command>iptables --protocol icmp --help</command> ou consultez l'annexe
<link linkend="icmptypes" endterm="icmptypes.title"></link>. Cette
correspondance peut être inversée en insérant le signe <command>!</command>
de cette façon : <command>--icmp-type ! 8</command> ou
<command>--icmp-type 8/0</command>. Pour une liste complète des noms, tapez 
<command>iptables -p icmp --help</command>.
        

<note><para>Notez que netfilter utilise le type ICMP 255 pour sélectionner
tous les types ICMP. Si vous essayez de sélectionner ce type ICMP, vous
sélectionnerez tous le types ICMP.
</para></note>
</para></entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   </section>

   <section xml:id="sctpmatches">
     <title xml:id="sctpmatches.title">Correspondances SCTP</title>
     <indexterm zone="sctpmatches">
       <primary>Match</primary>
       <secondary>SCTP</secondary>
       <seealso>SCTP match</seealso>
     </indexterm>
     <indexterm zone="sctpmatches">
       <primary>SCTP match</primary>
     </indexterm>


     <para>
<systemitem>SCTP</systemitem> ou <systemitem>Stream Control Transmission
Protocol</systemitem> est une occurence relativement nouvelle dans le
domaine du réseau en comparaison des protocoles <systemitem>TCP</systemitem> 
et <systemitem>UDP</systemitem>. Le chapitre <link
linkend="sctpcharacteristics" endterm="sctpcharacteristics.title"></link>
explique ce protocole en détail. Les correspondances implicites SCTP sont
chargées en ajoutant la correspondance <command>-p sctp</command> à la
ligne de commande de iptables.
     </para>

     <para>
Le protocole SCTP a été développé par certaines des plus grandes
entreprises de télécommunication, et ce protocole est spécialement bien
adapté pour les transactions simultanées importantes avec une haute
fiabilité.
     </para>
   
    <indexterm zone="table.sctpmatches">
      <primary>SCTP match</primary>
      <secondary>--source-port</secondary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>--source-port</primary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>Source-port match</primary>
    </indexterm>
   
    <indexterm zone="table.sctpmatches">
      <primary>SCTP match</primary>
      <secondary>--destination-port</secondary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>--destination-port</primary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>Destination-port match</primary>
    </indexterm>
    
    <indexterm zone="table.sctpmatches">
      <primary>SCTP match</primary>
      <secondary>--chunk-types</secondary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>--chunk-types</primary>
    </indexterm>
    <indexterm zone="table.sctpmatches">
      <primary>Chunk-types match</primary>
    </indexterm>
 
    <table frame='all' xml:id="table.sctpmatches">
     <title xml:id="table.sctpmatches.title">Correspondances SCTP</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--source-port</command>, 
	  <command>--sport</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p sctp --source-port 
	  80</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
La correspondance <command>--source-port</command> est utilisée pour
sélectionner un paquet SCTP basé sur le port source dans l'en-tête d'un
paquet SCTP. Le port peut soit être un simple port, comme dans l'exemple
ci-dessus, ou une série de ports spécifiés comme 
<command>--source-port 20:100</command>, ou il peut aussi être interverti par 
le signe <command>!</command>. Ça ressemble, par exemple, à 
<command>--source-port ! 25</command>. Le port source est un entier non signé
de 16 bits, ainsi sa valeur maximale est 65535 et minimale 0. 
</para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--destination-port</command>, 
	  <command>--dport</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p sctp --destination-port 
	  80</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance est utilisée pour le port destination des paquets SCTP.
Tous les paquets SCTP contiennent un port de destination, comme ils possèdent
un port source, dans les en-têtes. Le port peut être soit spécifié comme dans 
l'exemple ci-dessus, ou avec un série de ports comme 
<command>--destination-port 6660:6670</command>. La commande peut également
être intervertie avec le signe <command>!</command>, par exemple,
<command>--destination-port ! 80</command>. Cet exemple sélectionne tous les 
paquets sauf ceux du port 80. On retrouve le même comportement avec les ports
source et destination, le plus haut est 65535 et le plus bas 0.
</para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--chunk-types</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p sctp --chunk-types any 
	  INIT,INIT_ACK</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance est le type bloc du paquet SCTP. Il existe différents
types bloc disponibles. Pour une liste complète voir ci-dessous. La
correspondance débute avec le mot-clé <command>--chunk-types</command> 
et continue avec un fanion indiquant si nous devons tout sélectionner, certains
ou aucun. Après cela, nous spécifions les types bloc SCTP. Les types bloc
sont présentés dans une liste séparée ci-dessous.
</para><para>
De plus les fanions peuvent aussi prendre certains fanions bloc. Ceci se fait, 
par exemple, avec la forme <command>--chunk-types any DATA:Be</command>. Les
fanions sont spécifiques pour chaque type bloc SCTP et doivent être valides
selon la liste ci-dessous.
</para><para>
Si une majuscule est utilisée, le fanion doit être placé, et si une
minuscule est utilisée il ne doit pas être placé pour la correspondance.
La correspondance complète peut être inversée avec le signe 
<command>!</command> juste après le mot-clé <command>--chunk-types</command>. 
Exemple,  <command>--chunk-types ! any DATA:Be</command> ne sélectionnera rien
sauf cette forme.
</para></entry>
       </row>


     </tbody>
     </tgroup>
    </table>

    <para>
Ci-dessous une liste des types bloc que la correspondance 
<command>--chunk-types</command> reconnaîtra.

    </para>
   
    <indexterm zone="list.sctpmatch.chunktypes">
      <primary>Chunk types (SCTP)</primary>
    </indexterm>
    <indexterm zone="list.sctpmatch.chunktypes">
      <primary>SCTP</primary>
      <secondary>Chunk types</secondary>
    </indexterm>
 
	<itemizedlist xml:id="list.sctpmatch.chunktypes">
	  <title>Types bloc SCTP utilisés avec --chunk-types</title>
	  <listitem>
	    <para>
ABORT
	    </para>
	  </listitem>

	  <listitem>
	    <para>
ASCONF
	    </para>
	  </listitem>

	  <listitem>
	    <para>
ASCONF_ACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
COOKIE_ACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
COOKIE_ECHO
	    </para>
	  </listitem>

	  <listitem>
	    <para>
DATA
	    </para>
	  </listitem>

	  <listitem>
	    <para>
ECN_CWR
	    </para>
	  </listitem>

	  <listitem>
	    <para>
ECN_ECNE
	    </para>
	  </listitem>

	  <listitem>
	    <para>
ERROR
	    </para>
	  </listitem>

	  <listitem>
	    <para>
HEARTBEAT
	    </para>
	  </listitem>

	  <listitem>
	    <para>
HEARTBEAT_ACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
INIT
	    </para>
	  </listitem>

	  <listitem>
	    <para>
INIT_ACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
SACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
SHUTDOWN
	    </para>
	  </listitem>

	  <listitem>
	    <para>
SHUTDOWN_ACK
	    </para>
	  </listitem>

	  <listitem>
	    <para>
SHUTDOWN_COMPLETE
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
Les fanions suivants peuvent être utilisés avec la correspondance 
<command>--chunk-types</command> comme vu ci-dessus.
Selon la <link linkend="rfc2960" endterm="rfc2960.title"></link> tout le reste
des fanions est réservé et non utilisé, et doivent être placés à 0. Iptables
ne contient pas actuellement de mesures pour renforcer ceci, heureusement, 
car il pourrait survenir d'autres problèmes, comme nous l'avons précédemment 
vu, quand ECN était implémenté dans le protocole IP.
	</para>

    <indexterm zone="list.sctpmatch.chunkflags">
      <primary>Chunk flags (SCTP)</primary>
    </indexterm>
    <indexterm zone="list.sctpmatch.chunkflags">
      <primary>SCTP</primary>
      <secondary>Chunk flags</secondary>
    </indexterm>
 
	<itemizedlist xml:id="list.sctpmatch.chunkflags">
	  <title>Fanions bloc SCTP utilisés avec --chunk-types</title>
	  <listitem>
	    <para>
DATA - U ou u pour <link linkend="sctpheaderdata">Unordered bit</link>, B ou 
b pour <link linkend="sctpheaderdata">Beginning fragment bit</link> et E ou 
e pour <link linkend="sctpheaderdata">Ending fragment bit</link>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
ABORT - T ou t pour <link linkend="sctpheaderabort">TCB destroy flag</link>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
SHUTDOWN_COMPLETE - T ou t pour <link linkend="sctpheadershutdowncomplete">TCB 
destroyed flag</link>.
	    </para>
	  </listitem>
	</itemizedlist>

     </section>
   </section>

   <section xml:id="explicitmatches">
    <title xml:id="explicitmatches.title">Correspondances explicites</title>
    <indexterm zone="explicitmatches">
      <primary>Explicit matches</primary>
    </indexterm>
    <indexterm zone="explicitmatches">
      <primary>Match</primary>
      <secondary>Explicit</secondary>
      <seealso>Explicit matches</seealso>
    </indexterm>
    <indexterm zone="explicitmatches">
      <primary>Match</primary>
      <secondary>--match</secondary>
    </indexterm>
 
    <para>
Les correspondances explicites doivent être chargés spécifiquement 
par l'option <command>-m</command> ou <command>--match</command>. Par
exemple, les correspondances d'état nécessitent la directive
<command>-m state</command> avant d'entrer la véritable correspondance à
prendre en compte. Certaines de ces correspondances sont spécifiques à un
protocole. Certaines peuvent aussi être détachées de tout protocole
spécifique - par exemple les états de connexion. Ils sont identifiés par
<command>NEW</command> (pour le premier paquet d'une connexion non encore
établie), <command>ESTABLISHED</command> (pour une connexion déjà enregistrée
dans le noyau), <command>RELATED</command> (pour une nouvelle connexion créée
par une connexion plus ancienne et déjà établie), etc.
Parmi ces correspondances explicites, quelques-une peuvent avoir évolué pour
des questions de test ou d'expérimentation, ou simplement pour mettre en
évidence les capacités d'<command>iptables</command>. Par conséquent, ceci
signifie que l'intégralité de ces correspondances n'est pas à première vue
indispensable. Néanmoins, il y a de grandes chances que vous trouviez
certaines des ces correspondances explicites particulièrement utiles. Et de
nouvelles apparaissent en permanence, lors de chaque nouvelle version
d'<command>iptables</command>. Que vous leur découvriez ou non une
utilisation dépend de votre imagination et de vos besoins. Pour comprendre la
différence entre une correspondance chargée implicitement et une chargée
explicitement, il faut savoir que la première est chargée automatiquement
quand par exemple vous établissez une correspondance avec une propriété des
paquets <systemitem>TCP</systemitem>, alors que la seconde n'est jamais
chargée automatiquement - c'est à vous d'activer une
correspondance explicite.
    </para>

    <section xml:id="addrtypematch">
      <title xml:id="addrtypematch.title">Correspondance addrtype</title>
      <indexterm zone="addrtypematch">
        <primary>Addrtype match</primary>
      </indexterm>
      <indexterm zone="addrtypematch">
        <primary>Match</primary>
	<secondary>Addrtype</secondary>
	<seealso>Addrtype match</seealso>
      </indexterm>
 
      <para>
Le module addrtype sélectionne les paquets basés sur le type adresse.
Le type adresse est utilisé dans le noyau pour placer différents
paquets dans différentes catégories. Avec cette correspondance vous pourrez 
sélectionner tous les paquets basés sur leur adresse selon le noyau. Il faut
noter que le comportement exact des différents types adresse varie entre
les protocoles de la couche 3. je donnerai une brève description générale
ici, mais pour plus d'information lire le 
 <link linkend="lartc" endterm="lartc.title"></link> et le <link 
linkend="policyrouting" endterm="policyrouting.title"></link>. Les types
disponibles sont les suivants :
      </para>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>ANYCAST</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>ANYCAST</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>ANYCAST</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>BLACKHOLE</secondary>
        <tertiary></tertiary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>BLACKHOLE</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>BLACKHOLE</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>BROADCAST</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>BROADCAST</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>BROADCAST</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>LOCAL</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>LOCAL</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>LOCAL</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>MULTICAST</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>MULTICAST</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>MULTICAST</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>NAT</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>NAT</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>NAT</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>PROHIBIT</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>PROHIBIT</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>PROHIBIT</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>THROW</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>THROW</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>THROW</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>UNICAST</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>UNICAST</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>UNICAST</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>UNREACHABLE</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>UNREACHABLE</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>UNREACHABLE</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>UNSPEC</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>UNSPEC</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>UNSPEC</secondary>
      </indexterm>

      <indexterm zone="table.addrtypes">
        <primary>Addrtype match</primary>
	<secondary>XRESOLVE</secondary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>XRESOLVE</primary>
      </indexterm>
      <indexterm zone="table.addrtypes">
        <primary>Routing</primary>
	<secondary>XRESOLVE</secondary>
      </indexterm>

      <table frame='all' xml:id="table.addrtypes">
       <title xml:id="table.addrtypes.title">Types adresse</title>
       <tgroup cols='2' align='left' colsep='1' rowsep='1'>

        <colspec colwidth='2*'/>
        <colspec colwidth='8*'/>

	<thead>
         <row>
          <entry>Type</entry>
          <entry>Description</entry>
         </row>
	</thead>

        <tbody>
	 <row>
	  <entry><command>ANYCAST</command></entry>
	  <entry><para>
Type de connexion associative unique-à-multiple, où seulement un des multiples
destinataires reçoit les données. Par exemple, implémenté dans DNS. Vous
avez une adresse unique pour un serveur racine , mais qui possède plusieurs
localisations, votre paquet sera redirigé vers le plus proche serveur.
Non implémenté dans IPv4.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>BLACKHOLE</command></entry>
	  <entry><para>
Une adresse blackhole supprimera simplement le paquet et n'enverra pas de 
réponse. Elle fonctionne, de façon basique, comme un trou noir dans l'espace.
Elle est configurée dans les tables de routage de Linux. 
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>BROADCAST</command></entry>
	  <entry><para>
Un paquet broadcast (diffusion) est un simple paquet envoyé à tout le monde 
sur un réseau spécifique dans une relation unique-à-multiple. C'est, 
par exemple, utilisé dans la résolution ARP, où un paquet est envoyé pour
s'informer de la façon de joindre une adresse IP spécifique, ensuite l'hôte
autorisé répond avec sa propre adresse MAC.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>LOCAL</command></entry>
	  <entry><para>
Adresse locale de la machine sur laquelle nous travaillons. 127.0.0.1 par
exemple.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>MULTICAST</command></entry>
	  <entry><para>
Un paquet multicast (multidiffusion) est envoyé à divers hôtes utilisant
la distance la plus courte et seulement un paquet est expédié à chaque
point de cheminement où il sera copié plusieurs fois pour chaque hôte/routeur
souscrivant à l'adresse multicast spécifique. Utilisé couramment dans
le streaming media comme la vidéo ou le son.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>NAT</command></entry>
	  <entry><para>
Adresse qui a été NATée (traduite) par le noyau.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>PROHIBIT</command></entry>
	  <entry><para>
Comme le blackhole sauf qu'une réponse "interdit" sera générée. Dans le cas
de IPv4, ceci indique qu'une réponse <link linkend="icmpdestunreach">ICMP 
communication prohibited</link> (type 3, code 13) sera générée.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>THROW</command></entry>
	  <entry><para>
Route spéciale dans le noyau Linux. Si un paquet traverse un table de
routage il se comportera comme si aucune route n'était trouvée dans la table.
Dans le routage normal, ceci indique que le paquet se comporte comme s'il
n'avait pas de route. En stratégie de routage, une autre route peut être
trouvée dans une autre table.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>UNICAST</command></entry>
	  <entry><para>
Une adresse réellement routable pour une adresse unique. Le type de route
le plus commun.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>UNREACHABLE</command></entry>
	  <entry><para>
Signale une adresse injoignable (nous ne savons pas comment la joindre).
Les paquets seront supprimés et un <link linkend="icmpdestunreach">ICMP Host 
unreachable</link> (type 3, code 1) sera généré.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>UNSPEC</command></entry>
	  <entry><para>
Adresse non spécifiée qui n'a pas de signification réelle.
	  </para></entry>
	 </row>

	 <row>
	  <entry><command>XRESOLVE</command></entry>
	  <entry><para>
Type d'adresse utilisée pour envoyer une recherche de route vers les 
applications utilisateur. Non implémenté dans Linux.
	  </para></entry>
	 </row>

	</tbody>
	</tgroup>
       </table>
 
 	<para>
La correspondance addrtype est chargée en utilisant le mot-clé 
<command>-m addrtype</command>. Quand il est placé, des options de 
correspondance supplémentaires seront disponibles. Voir la table ci-dessous.

	</para>

        <indexterm zone="table.addrtypematch">
          <primary>Addrtype match</primary>
	  <secondary>--src-type</secondary>
        </indexterm>
        <indexterm zone="table.addrtypematch">
          <primary>--src-type</primary>
        </indexterm>
        <indexterm zone="table.addrtypematch">
          <primary>Src-type match</primary>
        </indexterm>
 
        <indexterm zone="table.addrtypematch">
          <primary>Addrtype match</primary>
	  <secondary>--dst-type</secondary>
        </indexterm>
        <indexterm zone="table.addrtypematch">
          <primary>--dst-type</primary>
        </indexterm>
        <indexterm zone="table.addrtypematch">
          <primary>Dst-type match</primary>
        </indexterm>
 
    <table frame='all' xml:id="table.addrtypematch">
     <title xml:id="table.addrtypematch.title">Options de la correspondance Addrtype</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--src-type</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -m addrtype --src-type 
	 UNICAST</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
L'option de correspondance <command>--src-type</command> est utilisée pour
sélectionner le type d'adresse source du paquet. Elle peut soit prendre
une adresse unique soit plusieurs adresses séparées par une virgule, par 
exemple  <command>--src-type BROADCAST,MULTICAST</command>. L'option de 
correspondance peut aussi être intervertie en ajoutant un point 
d'exclamation devant, par exemple 
<command>! --src-type BROADCAST,MULTICAST</command>.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--dst-type</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -m addrtype --dst-type 
	 UNICAST</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Le <command>--dst-type</command> fonctionne exactement comme le 
--src-type et possède la même syntaxe. La seule différence est qu'il
sélectionnera les paquets basés sur leur destination. 
        </para></entry>
       </row>

     </tbody>
     </tgroup>
    </table>

    </section>

    <section xml:id="ahespmatch">
      <title xml:id="ahespmatch.title">Correspondance AH/ESP</title>
      <indexterm zone="ahespmatch">
        <primary>AH/ESP match</primary>
      </indexterm>
      <indexterm zone="ahespmatch">
        <primary>Match</primary>
	<secondary>AH/ESP</secondary>
	<seealso>AH/ESP match</seealso>
      </indexterm>
      <indexterm zone="ahespmatch">
        <primary>IPSEC</primary>
      </indexterm>
      
      <para>
Ces correspondances sont utilisées pour les protocoles IPSEC AH et ESP.
IPSEC sert à créer des tunnels sécurisés par dessus une connexion Internet
non sécurisée. Les protocoles AH et ESP sont utilisés par IPSEC pour
créer ces connexions sécurisées. Les correspondances AH et ESP sont
deux correspondances séparées, mais elles sont toutes les deux décrites
ici car elles se ressemblent beaucoup, et toutes les deux ont le
même usage.
      </para>
      
      <para>
Je ne rentrerai pas dans les détails d'IPSEC ici, regardez les pages
suivantes pour plus d'information :
      </para>
      
      <itemizedlist mark="opencircle" xml:id="list.ahespmatch">
        <listitem>
          <para><link linkend="rfc2401" endterm="rfc2401.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="freeswan" endterm="freeswan.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="ipsec-howto" 
endterm="ipsec-howto.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="lartc" endterm="lartc.title"></link></para>
        </listitem>
      </itemizedlist>
      <indexterm zone="list.ahespmatch">
        <primary>RFC</primary>
	<secondary>2401</secondary>
      </indexterm>
      <indexterm zone="list.ahespmatch">
        <primary>FreeSWAN</primary>
      </indexterm>
    
      <para>
Il existe également des tonnes de documentation sur l'Internet à ce sujet.
      </para>
      
      <para>
Pour utiliser les correspondances AH/ESP, vous devrez vous servir de
 <command>-m ah</command> pour charger les correspondances AH, et
 <command>-m esp</command> pour charger les correspondances ESP.
      </para>
    
      <note>
        <para>
Dans les noyaux 2.2 et 2.4, Linux utilise une chose appelée FreeS/WAN
pour l'implémentation de IPSEC, mais à partir des noyaux 2.5.47 et
supérieurs, ceux-ci ont une implémentation directe de IPSEC et donc
ne nécessitent pas de patcher le noyau. C'est une réécriture complète
de l'implémentation de IPSEC dans Linux.
        </para>
      </note>
 
      <indexterm zone="table.ahmatch">
        <primary>AH/ESP match</primary>
        <secondary>--ahspi</secondary>
      </indexterm>
      <indexterm zone="table.ahmatch">
        <primary>--ahspi</primary>
      </indexterm>
      <indexterm zone="table.ahmatch">
        <primary>Ahspi match</primary>
      </indexterm>
      
      <table frame='all' xml:id="table.ahmatch">
       <title xml:id="table.ahmatch.title">Options de la correspondance AH</title>
       <tgroup cols='2' align='left' colsep='1' rowsep='1'>

        <colspec colwidth='1.5*'/>
        <colspec colwidth='8*'/>

        <tbody>
         <row>
          <entry>Correspondance</entry>
          <entry><command>--ahspi</command></entry>
         </row>
         <row>
          <entry>Noyau</entry>
          <entry>2.5 et 2.6</entry>
         </row>
         <row>
          <entry>Exemple</entry>
          <entry><command>iptables -A INPUT -p 51 -m ah --ahspi 
500</command></entry>
         </row>
         <row>
          <entry>Explication</entry>
          <entry>
Ceci vérifie le numéro de l'Index du Paramètre de Sécurité (SPI) des paquets
AH. Notez que vous devez spécifier le protocole, car AH s'exécute sur
un protocole différent des standards TCP, UDP et ICMP. Le numéro SPI est
utilisé en conjonction avec les adresses source et destination et les
clés secrètes pour créer une association de sécurité (SA). SA identifie
chacun des tunnels IPSEC pour tous les hôtes. SPI est utilisé uniquement
pour distinguer chaque tunnel IPSEC connecté entre deux tunnels identiques.
Utiliser la correspondance <command>--ahspi</command>, nous permet
de sélectionner un paquet basé sur le SPI des paquets. Cette correspondance
peut sélectionner une chaîne complète de valeur SPI en utilisant un signe :,
comme 500:520, qui vérifiera toute la chaîne des SPI.
          </entry>
         </row>

       </tbody>
       </tgroup>
      </table>
  
    <indexterm zone="table.espmatch">
      <primary>ESP match</primary>
      <secondary>--espspi</secondary>
      </indexterm>
    <indexterm zone="table.espmatch">
      <primary>--espspi</primary>
    </indexterm>
    <indexterm zone="table.espmatch">
      <primary>Espspi match</primary>
    </indexterm>
    
    <table frame='all' xml:id="table.espmatch">
     <title xml:id="table.espmatch.title">Options de la correspondance ESP</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--espspi</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p 50 -m esp --espspi 
500</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry>
La contrepartie de l'Index des Paramètres de Sécurité (SPI) est utilisée
de la même façon que la variante AH. La correspondance semble exactement
la même, avec seulement la différence esp/ah. Bien sûr, cette correspondance
peut sélectionner un ensemble complet de numéros SPI de la même façon
que la variante AH de la correspondance SPI, comme <command>--espi 200:250</command> qui sélectionne la totalité de la chaîne des SPI.
        </entry>
       </row>

     </tbody>
     </tgroup>
    </table>
    </section>

    <section xml:id="commentmatch">
      <title xml:id="commentmatch.title">Correspondance Comment</title>
      <indexterm zone="commentmatch">
        <primary>Comment match</primary>
      </indexterm>
      <indexterm zone="commentmatch">
        <primary>Match</primary>
	<secondary>Comment</secondary>
	<seealso>Comment match</seealso>
      </indexterm>

      <para>
La correspondance comment est utilisée pour ajouter des commentaires dans
la table de règles de iptables et le noyau. Ceci peut grandement simplifier
la compréhension de votre table de règles et le débogage. Par exemple, 
vous pouvez ajouter des commentaires qui documentent une fonction bash
qui ajoute des règles spécifiques à netfilter. Il faut noter que ce n'est
pas actuellement une correspondance. La "correspondance comment" est 
chargée en utilisant le mot-clé <command>-m</command>. Les options 
disponibles sont les suivantes :
      </para>
       
        <indexterm zone="table.commentmatch">
          <primary>Comment match</primary>
          <secondary>--comment</secondary>
        </indexterm>
        <indexterm zone="table.commentmatch">
          <primary>--comment</primary>
        </indexterm>
 
      <table frame='all' xml:id="table.commentmatch">
       <title xml:id="table.commentmatch.title">Options de la correspondance Comment</title>
       <tgroup cols='2' align='left' colsep='1' rowsep='1'>

        <colspec colwidth='1.5*'/>
        <colspec colwidth='8*'/>

        <tbody>
         <row>
          <entry>Correspondance</entry>
          <entry><command>--comment</command></entry>
         </row>
         <row>
          <entry>Noyau</entry>
          <entry>2.6</entry>
         </row>
         <row>
          <entry>Exemple</entry>
          <entry><command>iptables -A INPUT -m comment --comment "A comment"</command></entry>
         </row>
         <row>
          <entry>Explication</entry>
          <entry><para>
L'option <command>--comment</command> spécifie le commentaire à ajouter
à la règle dans le noyau. Le commentaire peut être au maximum de 256
caractères.
          </para></entry>
         </row>
	</tbody>
       </tgroup>
      </table>
      
    </section>

    <section xml:id="connmarkmatch">
      <title xml:id="connmarkmatch.title">Correspondance Connmark</title>
      <indexterm zone="connmarkmatch">
        <primary>Connmark match</primary>
      </indexterm>
      <indexterm zone="connmarkmatch">
        <primary>Match</primary>
	<secondary>Connmark</secondary>
	<seealso>Connmark match</seealso>
      </indexterm>
      
      <para>
La correspondance connmark est utilisée de la même façon que la
correspondance mark dans la combinaison de cible MARK/mark. Connmark sert
à sélectionner les marques qui ont été placées sur une connexion avec
la cible CONNMARK. Elle ne prend qu'une option.
      </para>
      
      <important>
        <para>
Pour sélectionner une marque sur le paquet qui est le premier à créer
la connexion marquée, vous devez utiliser la correspondance connmark après
que la cible CONNMARK ait placé la marque sur le premier paquet.
        </para>
      </important>
 
      <indexterm zone="table.connmarkmatch">
        <primary>Connmark match</primary>
        <secondary>--mark</secondary>
      </indexterm>
      <indexterm zone="table.connmarkmatch">
        <primary>--mark</primary>
      </indexterm>
      <indexterm zone="table.connmarkmatch">
        <primary>Mark match</primary>
      </indexterm>
 
      <table frame='all' xml:id="table.connmarkmatch">
        <title xml:id="table.connmarkmatch.title">Options de la correspondance Connmark</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>

          <colspec colwidth='1.5*'/>
          <colspec colwidth='8*'/>

          <tbody>
            <row>
              <entry>Correspondance</entry>
              <entry><command>--mark</command></entry>
            </row>
            <row>
              <entry>Noyau</entry>
              <entry>2.6</entry>
            </row>
            <row>
              <entry>Exemple</entry>
              <entry><command>iptables -A INPUT -m connmark --mark 12 -j ACCEPT</command></entry>
            </row>
            <row>
              <entry>Explication</entry>
              <entry><para>
L'option mark sert à sélectionner une marque spécifique associée à une
connexion. Le correspondance mark doit être exacte, Par exemple, si vous
avez une marque placée sur une connexion à 33 (10001 en binaire), et
voulez sélectionner le premier bit seulement, vous ferez quelque chose
comme ça <command>--mark 1/1</command>. Le masque (00001) sera masqué vers 
10001, ainsi 10001 et 00001 égale 1, et ensuite sélectionner le 1.
              </para></entry>
            </row>
	  </tbody>
	</tgroup>
      </table>

    </section>

    <section xml:id="conntrackmatch">
      <title xml:id="conntrackmatch.title">Correspondance Conntrack</title>
      <indexterm zone="conntrackmatch">
        <primary>Conntrack match</primary>
      </indexterm>
      <indexterm zone="conntrackmatch">
        <primary>Match</primary>
	<secondary>Conntrack</secondary>
	<seealso>Conntrack match</seealso>
      </indexterm>
      <indexterm zone="conntrackmatch">
        <primary>State</primary>
	<secondary>Conntrack match</secondary>
	<seealso>Conntrack match</seealso>
      </indexterm>
      
      <para>
La correspondance <command>conntrack</command> est une version étendue
de la correspondance d'état, qui rend possible la sélection des paquets
de façon un peu plus grossière. Ce qui vous permet d'avoir l'information
directement disponible dans un système de traçage de connexion, sans
applications frontales, comme dans la correspondance d'état. Pour plus  
de détails sur le système de traçage de connexion, regardez le chapitre 
<link linkend="statemachine" endterm="statemachine.title"></link>.
      </para>

      <para>
Il existe nombre de différentes options dans la correspondance 
conntrack, pour différents champs dans le système de traçage de connexion. 
Ils sont indiqués dans la liste ci-dessous. Pour charger ces 
options, vous devez spécifier <command>-m conntrack</command>.
      </para>
 
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctstate</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctstate</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctstate match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctproto</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctproto</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctproto match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctorigsrc</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctorigsrc</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctorigsrc match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctorigdst</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctorigdst</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctorigdst match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctreplsrc</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctreplsrc</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctreplsrc match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctrepldst</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctrepldst</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctrepldst match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctstatus</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctstatus</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctstatus match</primary>
        </indexterm>
  
        <indexterm zone="table.conntrackmatch">
          <primary>Conntrack match</primary>
          <secondary>--ctexpire</secondary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>--ctexpire</primary>
        </indexterm>
        <indexterm zone="table.conntrackmatch">
          <primary>Ctexpire match</primary>
        </indexterm>
 
    <table frame='all' xml:id="table.conntrackmatch">
     <title xml:id="table.conntrackmatch.title">options de la correspondance Conntrack</title>
     <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <colspec colwidth='1.5*'/>
      <colspec colwidth='8*'/>

      <tbody>
       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctstate</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctstate RELATED</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance est utilisée pour distinguer l'état d'un paquet, selon
l'état conntrack. Elle est utilisée pour sélectionner plus finement les mêmes
états que dans la correspondance <command>state</command> d'origine. 
Les entrées valides pour cette correspondance sont :
          </para><itemizedlist mark='opencircle'>
            <listitem><para>INVALID</para></listitem>
            <listitem><para>ESTABLISED</para></listitem>
            <listitem><para>NEW</para></listitem>
            <listitem><para>RELATED</para></listitem>
            <listitem><para>SNAT</para></listitem>
            <listitem><para>DNAT</para></listitem>
          </itemizedlist><para>
Les entrées peuvent être utilisées l'une avec l'autre en les séparant par
une virgule. Par exemple, 
<command>-m conntrack --ctstate ESTABLISHED,RELATED</command>. Elles peuvent 
aussi être interverties en mettant un ! avant <command>--ctstate</command>.  
Exemple : <command>-m conntrack ! --ctstate ESTABLISHED,RELATED</command>, qui 
sélectionne tout sauf les états <command>ESTABLISHED</command> et
<command>RELATED</command>.
          </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctproto</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctproto
TCP</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Ceci sélectionne le protocole, de la même façon que le fait 
<command>--protocol</command>. 
Il peut prendre les mêmes types de valeurs, et on peut l'intervertir en 
utilisant le signe !. Exemple, <command>-m conntrack ! --ctproto TCP</command> 
sélectionne tous les protocoles sauf <systemitem>TCP</systemitem>.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctorigsrc</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctorigsrc 
192.168.0.0/24</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
<command>--ctorigsrc</command> est une correspondance basée sur la
spécification de la source IP d'origine de l'entrée conntrack en rapport
avec le paquet. La correspondance peut être inversée en utilisant le ! 
entre le <command>--ctorigsrc</command> et la spécification IP, comme 
 <command>--ctorigsrc ! 192.168.0.1</command>. Elle peut aussi prendre 
un masque de réseau de forme CIDR, comme <command>--ctorigsrc 
192.168.0.0/24</command>. 
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctorigdst</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctorigdst
192.168.0.0/24</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance est utilisée de la même façon que
<command>--ctorigsrc</command>, sauf qu'elle sélectionne le champ
destination de l'entrée conntrack.
Elle possède la même syntaxe.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctreplsrc</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctreplsrc
192.168.0.0/24</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
La correspondance <command>--ctreplysrc</command> est utilisée pour 
la sélection fondée sur la réponse source du conntrack d'origine du paquet.
C'est à peu près la même chose que le <command>--ctorigsrc</command>, mais
nous sélectionnons la réponse source attendue des paquets envoyés. Cette cible
peut, bien sûr, être inversée et adresser une chaîne complète d'adresses,
de la même façon que la cible précédente dans ce préfixe.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctrepldst</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctrepldst
192.168.0.0/24</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
La correspondance <command>--ctreplydst</command> est la même que 
<command>--ctreplysrc</command>, avec la différence qu'elle sélectionne
la réponse de destination de l'entrée conntrack qui a sélectionné
la paquet. Elle peut être inversée, et accepte les chaînes, comme
la correspondance <command>--ctreplysrc</command>.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctstatus</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctstatus
RELATED</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Ceci sélectionne les statuts de la connexion, comme décrit dans la chapitre
 <link linkend="statemachine" endterm="statemachine.title"></link>.
Ces statuts sont les suivants : 
        </para><itemizedlist mark="opencircle">
          <listitem>
            <para>
NONE - La connexion ne possède aucun statut.
            </para>
          </listitem>
          <listitem>
            <para>
EXPECTED - Cette connexion est en attente et a été ajoutée par les
gestionnaires d'attente.
            </para>
          </listitem>
          <listitem>
            <para>
SEEN_REPLY - La connexion a vu une réponse mais n'en est cependant
pas assurée. 
            </para>
          </listitem>
          <listitem>
            <para>
ASSURED - La connexion est certaine et ne sera pas supprimée tant que le
délai d'attente ne sera pas atteint ou qu'elle sera interrompue d'une
autre façon.
            </para>
          </listitem>
        </itemizedlist><para>
Elle peut aussi être inversée par le signe !. Exemple, <command>-m 
conntrack ! --ctstatus ASSURED</command> qui sélectionne tout sauf le statut
ASSURED.
        </para></entry>
       </row>

       <row>
        <entry>Correspondance</entry>
        <entry><command>--ctexpire</command></entry>
       </row>
       <row>
        <entry>Noyau</entry>
        <entry>2.5 et 2.6</entry>
       </row>
       <row>
        <entry>Exemple</entry>
        <entry><command>iptables -A INPUT -p tcp -m conntrack --ctexpire 100:150
</command></entry>
       </row>
       <row>
        <entry>Explication</entry>
        <entry><para>
Cette correspondance sert à sélectionner les paquets basés sur la longueur
du temps d'expiration de l'entrée conntrack, mesuré en secondes. Elle peut
soit prendre une seule valeur, ou une chaîne comme dans l'exemple au-dessus.
Elle peut aussi être inversée avec le signe !, comme 
<command>-m conntrack ! --ctexpire 100</command>. Ceci sélectionne chaque
temps d'expiration, qui n'est pas exactement de 100 secondes.
        </para></entry>
       </row>

     </tbody>
     </tgroup>
    </table>
      
    </section>
    
    <section xml:id="dscpmatch">
<title xml:id="dscpmatch.title">Correspondance Dscp</title>
<indexterm zone="dscpmatch">
<primary>Dscp match</primary>
</indexterm>
<indexterm zone="dscpmatch">
<primary>Match</primary>
<secondary>Dscp</secondary>
<seealso>Dscp match</seealso>
</indexterm>
<indexterm zone="dscpmatch">
<primary>RFC</primary>
<secondary>2638</secondary>
</indexterm>

<para>
Cette correspondance est utilisée pour distinguer les paquets basés sur leur 
champ DSCP (Differentiated Services Code Point). C'est documenté dans 
la RFC <link linkend="rfc2638" endterm="rfc2638.title"></link>. 
La correspondance est chargée en spécifiant <command>-m dscp</command>. 
Elle peut prendre deux options mutuellement incompatibles, décrites ci-dessous.
</para>

<indexterm zone="table.dscpmatch">
  <primary>DSCP match</primary>
  <secondary>--dscp</secondary>
</indexterm>
<indexterm zone="table.dscpmatch">
  <primary>--dscp</primary>
</indexterm>

<indexterm zone="table.dscpmatch">
  <primary>Dscp match</primary>
  <secondary>--dscp-class</secondary>
</indexterm>
<indexterm zone="table.dscpmatch">
  <primary>--dscp-class</primary>
</indexterm>
<indexterm zone="table.dscpmatch">
  <primary>Dscp-class match</primary>
</indexterm>


<table frame='all' xml:id="table.dscpmatch">
<title xml:id="table.dscpmatch.title">Options de la correspondance Dscp</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--dscp</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m dscp --dscp 32</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette option prend une valeur DSCP soit en décimal soit en hexadécimal.
Si la valeur de l'option est en décimal, elle sera écrite comme 32 ou
16, etc. Si elle est écrite en hexadécimal, elle pourrait être préfixée
avec des 0x, comme ça : 0x20. Elle peut aussi être inversée par le signe
!, comme : <command>-m dscp ! --dscp 32</command>.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--dscp-class</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m dscp --dscp-class BE</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La correspondance <command>--dscp-class</command> sert à la sélection d'une
classe Diffserv d'un paquet. Les valeurs peuvent être l'une des classes
BE, EF, AFxx ou CSxx comme spécifié dans les diverses RFC. Elle peut être
inversée de la même façon qu'avec l'option <command>--dscp</command>.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

<note>
<para>
Notez que les options de classe --dscp et dscp-class sont mutuellement
exclusives et ne peuvent pas être utilisées conjointement l'une avec l'autre.
</para>
</note>

</section>

<section xml:id="ecnmatch">
<title xml:id="ecnmatch.title">Correspondance Ecn</title>
<indexterm zone="ecnmatch">
<primary>Ecn match</primary>
</indexterm>
<indexterm zone="ecnmatch">
<primary>Match</primary>
<secondary>Ecn</secondary>
<seealso>Ecn match</seealso>
</indexterm>
<indexterm zone="ecnmatch">
<primary>RFC</primary>
<secondary>3168</secondary>
</indexterm>

<para>
ECN est utilisé pour sélectionner les différents champs ECN dans les
en-têtes TCP et IPv4. ECN est décrit en détail dans la RFC 
<link linkend="rfc3168" endterm="rfc3168.title"></link>. La correspondance
est chargée par <command>-m ecn</command> dans la ligne de commande.
Elle prend trois options différentes, comme décrit ci-dessous.
</para>

<indexterm zone="table.ecnmatch">
<primary>Ecn match</primary>
<secondary>--ecn</secondary>
</indexterm>
<indexterm zone="table.ecnmatch">
<primary>--ecn</primary>
</indexterm>

<indexterm zone="table.ecnmatch">
<primary>Ecn match</primary>
<secondary>--ecn-tcp-ece</secondary>
</indexterm>
<indexterm zone="table.ecnmatch">
<primary>--ecn-tcp-ece</primary>
</indexterm>
<indexterm zone="table.ecnmatch">
<primary>Ecn-tcp-ece match</primary>
</indexterm>

<indexterm zone="table.ecnmatch">
<primary>Ecn match</primary>
<secondary>--ecn-ip-ect</secondary>
</indexterm>
<indexterm zone="table.ecnmatch">
<primary>--ecn-ip-ect</primary>
</indexterm>
<indexterm zone="table.ecnmatch">
<primary>Ecn-ip-ect match</primary>
</indexterm>

<table frame='all' xml:id="table.ecnmatch">
<title xml:id="table.ecnmatch.title">Options de la correspondance Ecn</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--ecn</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m ecn --ecn-tcp-cwr</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance est utilisée pour sélectionner le bit CWR (Congestion
Window Received), s'il a été placé. Le fanion CWR est placé pour notifier
l'autre point limite de la connexion reçue (ECE), et qui a été réactivée.
Par défaut elle vérifie si le bit CWR est placé, mais la correspondance
peut aussi être inversée par le signe !. 
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--ecn-tcp-ece</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m ecn --ecn-tcp-ece</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance peut être utilisée pour sélectionner le bit 
<systemitem>ECE</systemitem> (<systemitem>ECN-Echo</systemitem>). Le ECE
est placé une fois que les points limite aient reçu un paquet avec un bit CE
placé par un routeur. Le point limite place alors le ECE en renvoyant
la paquet ACK, pour le notifier à l'autre point limite. Cet autre point
limite envoie alors un paquet CWR comme décrit dans l'explication de 
<command>--ecn-tcp-cwr</command>. C'est le comportement par défaut si le
bit ECE est placé, mais peut être interverti par le signe !.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--ecn-ip-ect</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m ecn --ecn-ip-ect 1</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
<command>--ecn-ip-ect</command> est utilisée pour sélectionner les codes
caractères ECT (ECN Capable Transport). Les codes caractères ECT
possèdent plusieurs types. Principalement, ils sont utilisés pour 
savoir si la connexion a les possibilités ECN en plaçant un des deux
bits à 1. ECT est aussi utilisé par les routeurs pour indiquer qu'ils
sont en processus d'engorgement, en plaçant les deux points limite ECT à 1.
les valeurs ECT sont toutes disponibles dans la table 
 <link linkend="ecnfieldip" endterm="ecnfieldip.title"></link> ci-dessous.
        </para><para>
La correspondance peut être inversée par un !, exemple 
<command>! --ecn-ip-ect 2</command> qui va sélectionner toutes les valeurs ECN
sauf le point limite ECT(0). La chaîne de valeur correcte dans Iptables est
de 0 à 3. Voir ci-dessous pour les valeurs :
</para></entry>
</row>

</tbody>
</tgroup>
</table>

<indexterm zone="ecnfieldip">
<primary>ECN IP field</primary>
</indexterm>
<table xml:id="ecnfieldip">
 <title xml:id="ecnfieldip.title">Champ ECN dans IP</title>
  <tgroup cols='4' align='left' colsep='1' rowsep='1'>
  <colspec colwidth='2*'/>
  <colspec colwidth='1*'/>
  <colspec colwidth='1*'/>
  <colspec colwidth='8*'/>

  <thead>
   <row>
    <entry>Valeur Iptables</entry>
    <entry>ECT</entry>
    <entry>CE</entry>
    <entry>[Obsolète] Noms RFC 2481 pour les bits ECN.</entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry>0</entry>
    <entry>0</entry>
    <entry>0</entry>
    <entry>Not-ECT, ie. pas de possibilité de connexion non-ECN</entry>
   </row>

   <row>
    <entry>1</entry>
    <entry>0</entry>
    <entry>1</entry>
    <entry>ECT(1), nouvelle convention de nommage des points limite
ECT dans la RFC 3168
    </entry>
   </row>

   <row>
    <entry>2</entry>
    <entry>1</entry>
    <entry>0</entry>
    <entry>ECT(0),  nouvelle convention de nommage des points limite
ECT dans la RFC 3168
    </entry>
   </row>

   <row>
    <entry>3</entry>
    <entry>1</entry>
    <entry>1</entry>
    <entry>CE (Congestion Experienced), utilisé pour notifier les points 
limite pour l'engorgement.
    </entry>
   </row>
  </tbody>
  </tgroup>
</table>

</section>

<section xml:id="hashlimitmatch">
<title xml:id="hashlimitmatch.title">Correspondance Hashlimit</title>
<indexterm zone="hashlimitmatch">
<primary>Hashlimit match</primary>
</indexterm>
<indexterm zone="hashlimitmatch">
<primary>Match</primary>
<secondary>Hashlimit</secondary>
<seealso>Hashlimit match</seealso>
</indexterm>

<para>
Il s'agit d'une version modifiée de la <link linkend="limitmatch" 
endterm="limitmatch.title"></link>. Au lieu de placer une simple marque,
elle met en place une table de hachage pointant vers les marques pour
chaque destination IP, source IP, port source et destination. Par exemple, 
vous pouvez la placer pour chaque adresse IP qui reçoit au maximum 1000
paquets par seconde, ou vous pouvez dire que chaque service sur une
adresse IP spécifique doit recevoir un maximum de 200 paquets par seconde.
La correspondance hashlimit est chargée par le mot-clé 
<command>-m hashlimit</command>.
</para>

<para>
Chaque règle qui utilise la correspondance hashlimit crée une table
de hachage séparée ayant une taille maximale spécifique et un nombre
maximal de compartiments. Cette table de hachage contient une empreinte
numérique de chaque valeur unique ou multiple. Les valeurs peuvent être
la destination IP, la source IP,le port source ou le port destination, ou tout
en même temps. Chaque entrée pointe alors vers une empreinte numérique
qui fonctionne comme la correspondance limit. 
</para>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-mode</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-mode</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-mode match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-name</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-name</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-name match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-burst</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-burst</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-burst match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-htable-size</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-htable-size</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-htable-size match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-htable-max</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-htable-max</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-htable-max match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-htable-gcinterval</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-htable-gcinterval</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit-htable-gcinterval match</primary>
</indexterm>

<indexterm zone="table.hashlimitmatch">
  <primary>Hashlimit match</primary>
  <secondary>--hashlimit-htable-expire</secondary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-htable-expire</primary>
</indexterm>
<indexterm zone="table.hashlimitmatch">
  <primary>--hashlimit-htable-expire match</primary>
</indexterm>

<table frame='all' xml:id="table.hashlimitmatch">
<title xml:id="table.hashlimitmatch.title">Options de la correspondance Hashlimit</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000/sec --hashlimit-mode dstip,dstport --hashlimit-name 
hosts</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
--hashlimit spécifie la limite de chaque compartiment. Dans cet exemple, 
le hashlimit est placé à 1000. Nous avons placé le hashlimit-mode pour
dstip, dstport et destination 192.168.0.3. Pour chaque port ou service
le destinataire peut recevoir 1000 paquets par seconde. C'est le même
paramètrage que l'option limit pour la correspondance limit. Limit peut
prendre /sec, /minute, /hour, /day postfixé. Si aucun postfixage n'est
spécifié, le postfixage par défaut est la seconde.
</para><important><para>
Cette option est obligatoire pour toutes les correspondances hashlimit.
</para></important></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-mode</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.0/16 -m 
hashlimit --hashlimit 1000/sec --hashlimit-mode dstip --hashlimit-name 
hosts</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'option hashlimit-mode spécifie quelle valeur nous devrons utiliser
comme valeur de hachage. Dans cet exemple, nous utilisons seulement
dstip (destination IP) comme valeur de hachage. Ainsi, chaque hôte
dans le réseau 192.168.0.0/16 sera limité en réception d'un maximum
de 1000 paquets par seconde dans ce cas. Les valeurs possibles pour
le mode hashlimit sont dstip (IP destination), srcip (IP source), 
dstport (port de destination), et srcport (port source). Toutes ces
valeurs peuvent également être séparées par une virgule pour inclure plus
d'une valeur de hachage, comme par exemple 
<command>--hashlimit-mode dstip,dstport</command>.
</para><important><para>
Cette option est obligatoire pour toutes les correspondances hashlimit.
</para></important></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-name</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette option spécifie le nom du hachage dans lequel il sera disponible.
Il peut être vu dans le répertoire /proc/net/ipt_hashlimit. L'exemple ci-dessus
peut être visible dans le fichier /proc/net/ipt_hashlimit/hosts. Seul
le nom de fichier doit être spécifié.
</para><important><para>
Cette option est obligatoire pour toutes les correspondances hashlimit.
</para></important></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-burst</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts --hashlimit-burst 2000</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance est identique à --limit-burst en ce qu'elle indique
la taille maximum du compartiment. Chaque compartiment aura une limite,
qui est le montant maximal de paquets qui peuvent être sélectionnés pendant
une unité de temps. Pour un exemple, voir la 
<link linkend="limitmatch" endterm="limitmatch.title"></link>.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-htable-size</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts --hashlimit-htable-size 500</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Indique le maximum de compartiments disponibles. Dans cet exemple, 
ceci indique un maximum de 500 ports ouverts et actifs au même moment. 
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-htable-max</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts --hashlimit-htable-max 500</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La <command>--hashlimit-htable-max</command> indique le nombre maximum
d'entrées dans la table de hachage. Ce qui veut dire toutes les connexions,
incluant les connexions inactives qui ne requièrent pas de compartiment
pour l'instant.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-htable-gcinterval</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts --hashlimit-htable-gcinterval 1000</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
À quelle fréquence la fonction de récupération des informations parasites
doit elle être lancée. Cette valeur devra être plus basse que la valeur
expire. Elle est mesurée en millisecondes. Si elle est trop basse elle
consommera des ressources système et processeur non nécessaires, mais si
elle est trop haute elle peut laisser des compartiments inutilisés trop
longtemps et rendre d'autres connexions impossibles. Dans cet exemple la 
fonction de récupération est lancée chaque seconde.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hashlimit-htable-expire</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --dst 192.168.0.3 -m hashlimit 
--hashlimit 1000 --hashlimit-mode dstip,dstport --hashlimit-name 
hosts --hashlimit-htable-expire 10000</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Valeur qui indique la durée après laquelle une entrée dans la table
de hachage expirera. Si un compartiment a été inutilisé plus longtemps que,
il expirera et la fonction de récupération le supprimera de la table
de hachage, ainsi que toutes les afférentes. 
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="helpermatch">
<title xml:id="helpermatch.title">Correspondance Helper</title>
<indexterm zone="helpermatch">
<primary>Helper match</primary>
</indexterm>
<indexterm zone="helpermatch">
<primary>Match</primary>
<secondary>Helper</secondary>
<seealso>Helper match</seealso>
</indexterm>

<para>
C'est plutôt une correspondance pas très orthodoxe en comparaison des autres,
dans ce sens qu'elle utilise une syntaxe spécifique. Elle est utilisée
pour sélectionner les paquets, basés sur l'assistant conntrack en relation
avec le paquet. Par exemple, regardons une session FTP. La session Contrôle
est ouverte, et les ports/connexion sont négociés pour la session Data dans
la session Control. 
Le module assistant <command>ip_conntrack_ftp</command> va trouver cette
information, et créer une entrée dans la table conntrack. Maintenant, quand
un paquet entre, nous pouvons voir quel protocole est en relation, et pouvons
sélectionner le paquet dans nos propres tables de règles basées sur 
l'assistant qui a été utilisé.
</para>

<indexterm zone="table.helpermatch">
<primary>Helper match</primary>
<secondary>--helper</secondary>
</indexterm>
<indexterm zone="table.helpermatch">
<primary>--helper</primary>
</indexterm>

<table frame='all' xml:id="table.helpermatch">
<title xml:id="table.helpermatch.title">Options de la correspondance Helper</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--helper</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m helper --helper ftp-21</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'option <command>--helper</command> est utilisée pour spécifier une
valeur de chaîne, indiquant à la correspondance quelle assistant conntrack
sélectionner. Dans sa forme basique, elle peut ressembler à 
<command>--helper irc</command>. C'est l'endroit où la syntaxe démarre
en variant par rapport à la syntaxe normale. Nous pouvons aussi choisir 
de sélectionner seulement les paquets basés sur tel port que l'original a pris.
Exemple, la session Control FTP est normalement transférée sur le port 21,
mais elle peut aussi bien l'être sur le port 954 ou un autre. Nous pouvons 
alors spécifier quel port  sera utilisé, comme 
<command>--helper ftp-954</command>.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>
    
<section xml:id="iprangematch">
<title xml:id="iprangematch.title">Correspondance de plage IP</title>
<indexterm zone="iprangematch">
<primary>IP range match</primary>
</indexterm>
<indexterm zone="iprangematch">
<primary>Match</primary>
<secondary>IP range</secondary>
<seealso>IP range match</seealso>
</indexterm>

<para>
La correspondance de plage IP est utilisée pour sélectionner les plages IP,
comme les correspondances <command>--source</command> et 
<command>--destination</command> peuvent le faire. 
Cependant, cette correspondance ajoute une sorte de tri différent
dans le sens qu'elle peut faire la sélection dans la forme IP à IP, ce que les 
correspondances <command>--source</command> et <command>--destination</command> sont incapables de faire. 
Ceci peut être nécessaire dans certains réglages de réseaux spécifiques, 
et elle est légèrement plus souple.
</para>

<indexterm zone="table.iprangematch">
<primary>IP range match</primary>
<secondary>--src-range</secondary>
</indexterm>
<indexterm zone="table.iprangematch">
<primary>--src-range</primary>
</indexterm>
<indexterm zone="table.iprangematch">
<primary>Src-range match</primary>
</indexterm>

<indexterm zone="table.iprangematch">
<primary>IP range match</primary>
<secondary>--dst-range</secondary>
</indexterm>
<indexterm zone="table.iprangematch">
<primary>--dst-range</primary>
</indexterm>
<indexterm zone="table.iprangematch">
<primary>Dst-range match</primary>
</indexterm>

<table frame='all' xml:id="table.iprangematch">
<title xml:id="table.iprangematch.title">Options de la correspondance de plage IP</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--src-range</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m iprange --src-range 192.168.1.13-192.168.2.19</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Ceci sélectionne une plage d'adresses source IP. La plage inclut chaque adresse
depuis la première jusqu'à la dernière, ainsi l'exemple ci-dessus inclut
toutes les adresses depuis 192.168.1.13 jusqu'à 192.168.2.19.
Elle peut aussi être inversée avec le !. L'exemple du dessus ressemblera
alors à <command>-m iprange ! --src-range 192.168.1.13-192.168.2.19</command>,
qui va sélectionner chaque adresse, sauf celles spécifiées.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--dst-range</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m iprange --dst-range 192.168.1.13-192.168.2.19</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
<command>--dst-range</command> fonctionne exactement de la même façon que
la correspondance <command>--src-range</command>, sauf qu'elle sélectionne la
destination IP au lieu de la source IP.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="lengthmatch">
<title xml:id="lengthmatch.title">Correspondance Length</title>
<indexterm zone="lengthmatch">
<primary>Length match</primary>
</indexterm>
<indexterm zone="lengthmatch">
<primary>Match</primary>
<secondary>Length</secondary>
<seealso>Length match</seealso>
</indexterm>

<para>
La correspondance Length est utilisée pour sélectionner les paquets basés sur
leur longueur. C'est très simple. Si vous voulez limiter la longueur des
paquets pour quelque étrange raison, ou bloquer ce qui ressemble à un
ping-of-death, utilisez cette correspondance.
</para>

<indexterm zone="table.lengthmatch">
<primary>Length match</primary>
<secondary>--length</secondary>
</indexterm>
<indexterm zone="table.lengthmatch">
<primary>--length</primary>
</indexterm>

<table frame='all' xml:id="table.lengthmatch">
<title xml:id="table.lengthmatch.title">Options de la correspondance Length</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--length</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m length --length 1400:1500</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'exemple <command>--length</command> va sélectionner tous les paquets de 
longueur comprise entre 1400 et 1500 octets. Elle peut être inversée en 
utilisant le signe <command>!</command>, comme ça : 
<command>-m length ! --length 1400:1500</command>.
Elle peut aussi être utilisée pour sélectionner certaines tailles seulement, 
en supprimant le signe :, comme ceci : 
<command>-m length --length 1400</command>. La plage est bien sûr inclusive,
ce qui inclut tous les paquets dont la longueur est comprise dans les valeurs
que vous avez spécifiées.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="limitmatch">
<title xml:id="limitmatch.title">Correspondance Limit</title>
<indexterm zone="limitmatch">
<primary>Limit match</primary>
</indexterm>
<indexterm zone="limitmatch">
<primary>Match</primary>
<secondary>Limit</secondary>
<seealso>Limit match</seealso>
</indexterm>

<para> 
L'extension de correspondance <command>limit</command> doit être
chargée explicitement avec l'option <command>-m limit</command>. Cette
correspondance peut être employée avantageusement pour limiter la
journalisation de certaines règles, etc. Par exemple, vous pouvez établir une
correspondance avec tous les paquets qui n'excèdent pas une quantité donnée,
et au-delà de ce seuil, limiter la journalisation de l'évènement en question.
Considérez ce seuil comme une limite temporelle : vous pouvez limiter le
nombre de correspondances d'une certaine règle dans un certain laps
de temps, par exemple pour atténuer l'impact des attaques de type déni de
service (<emphasis>DoS</emphasis>). C'est d'ailleurs la principale
application qu'on en fait, mais naturellement, il en existe d'autres. La
correspondance <command>limit</command> peut également être inversée en
ajoutant le symbole <command>!</command> juste après le mot
<command>limit</command>. Elle s'exprime alors sous la forme
<command>-m limit ! --limit 5/s</command>, autrement dit tous les paquets
sont sélectionnés quand la limite est dépassée.
</para>

<para> 
 Pour décrire plus précisément la correspondance
<command>limit</command>, c'est essentiellement un filtre à jetons.
Considérez un seau percé qui laisse fuir N paquets 
par unité de temps. N est défini en fonction du nombre de paquets que nous
voulons sélectionner, ainsi si nous voulons 3 paquets, le seau laisse
fuir 3 paquets par unité de temps. L'option <command>--limit</command>
détermine le nombre de paquets qui peuvent remplir le seau par unité de
temps, alors que l'option <command>--limit-burst</command> définit la
contenance initiale du seau. Par conséquent, en définissant
<command>--limit 3/minute --limit-burst 5</command>, puis en recevant
5 correspondances, le seau sera vidé. Après une attente de
20 secondes, le seau est rempli d'un nouveau jeton, et ainsi de
suite jusqu'à ce que le paramètre <command>--limit-burst</command> soit
atteint ou jusqu'à ce que les jetons soient tous utilisés.
</para>

	<para>
Considérez l'exemple ci-dessous pour approfondir ce fonctionnement.
	</para>

	<orderedlist numeration="arabic">
		<listitem>
		<para>
On définit une règle avec les paramètres -m limit --limit 5/second
--limit-burst 10/second. Le paramètre limit-burst du seau à jetons est fixé
initialement à 10. Chaque paquet qui établit une correspondance avec la règle
consomme un jeton.
		</para>
		</listitem>

		<listitem>
		<para>
On reçoit alors des paquets qui correspondent à la règle, 1-2-3-4-5-6-7-8-9-10,
tous arrivent dans un intervalle de 1/1000ème de seconde.
		</para>
		</listitem>

		<listitem>
		<para>
Le seau de jetons se retrouve complètement vide. Et puisque le seau est vide,
les paquets qui rencontrent la règle ne peuvent plus correspondre et
poursuivent leur route vers la règle suivante, ou subissent le comportement
par défaut de la chaîne.
		</para>
		</listitem>

		<listitem>
		<para>
Pour chaque tranche de 1/5ème de seconde sans qu'un paquet ne corresponde,
le compteur de jetons augmente de 1, jusqu'à un maximum de 10. Et
1 seconde après avoir reçu 10 paquets, on aura de nouveau
5 jetons de moins.
		</para>
		</listitem>

		<listitem>
		<para>
Et naturellement, le seau sera vidé d'1 jeton par paquet reçu.
		</para>
		</listitem>
	</orderedlist>

<indexterm zone="table.limitmatch">
<primary>Limit match</primary>
<secondary>--limit</secondary>
</indexterm>
<indexterm zone="table.limitmatch">
<primary>--limit</primary>
</indexterm>

<indexterm zone="table.limitmatch">
<primary>Limit match</primary>
<secondary>--limit-burst</secondary>
</indexterm>
<indexterm zone="table.limitmatch">
<primary>--limit-burst</primary>
</indexterm>
<indexterm zone="table.limitmatch">
<primary>Limit-burst match</primary>
</indexterm>

<table frame='all' xml:id="table.limitmatch">
<title xml:id="table.limitmatch.title">Options de la correspondance Limit</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--limit</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m limit --limit
3/hour</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Ceci définit le taux de correspondance moyen maximum pour la
correspondance <command>limit</command>. Il est spécifié par un nombre
suivi éventuellement d'une unité de temps. Les unités suivantes sont
actuellement reconnues : <command>/second</command>,
<command>/minute</command>, <command>/hour</command> et
<command>/day</command>. La valeur par défaut est fixée à
3 correspondances par heure, soit <command>3/hour</command>. Ceci
indique à la correspondance <command>limit</command> combien de fois la
correspondance avec un paquet est autorisé par unité de temps (par exemple
par minute).
</entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--limit-burst</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m limit --limit-burst
5</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Ceci définit la <emphasis>réserve maximale</emphasis> (ou la
salve) de la correspondance <command>limit</command>. Il indique à
<command>iptables</command> le nombre maximum de paquets pouvant
correspondre pendant l'unité de temps donnée. Ce nombre est décrémenté de 1
après chaque unité de temps (spécifiée par l'option
<command>--limit</command>) pendant laquelle l'évènement ne s'est pas
produit, jusqu'à atteindre la plus faible valeur, 1. Si l'évènement se
produit de façon répétée, le compteur est alors incrémenté jusqu'à atteindre
la valeur de réserve maximale, et ainsi de suite.
La valeur par défaut de <command>--limit-burst</command> est 5. Pour
comprendre simplement comment ceci fonctionne, utilisez le script d'exemple
<link linkend="limit-matchtxt" endterm="limit-matchtxt.title"></link>
composé d'une règle. Grâce à ce script, vous pouvez voir vous-mêmes comment
fonctionne la règle limit, en envoyant des paquets d'écho (de type ping) à
des intervalles différents et en différentes rafales. Toutes les
<systemitem>réponses d'écho</systemitem> seront bloquées jusqu'à ce que le
seuil de réserve maximale soit de nouveau atteint.
</entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="macmatch">
<title xml:id="macmatch.title">Correspondance Mac</title>
<indexterm zone="macmatch">
<primary>Mac match</primary>
</indexterm>
<indexterm zone="macmatch">
<primary>Match</primary>
<secondary>Mac</secondary>
<seealso>Mac match</seealso>
</indexterm>

<para>
La correspondance <systemitem>MAC</systemitem>
(<systemitem>Ethernet Media Access Control</systemitem> - Interface réseau 
ethernet) permet de sélectionner des paquets à partir de leur 
<systemitem>adresse MAC source</systemitem>. 
Lors de l'écriture de ce document, cette correspondance 
s'avère quelque peu limitée, cependant elle pourrait être plus évoluée à
l'avenir, donc plus utile. 
Cette correspondance peut être utilisée pour sélectionner les paquets
sur la source de l'adresse MAC seulement comme précédemment indiqué.
</para>

<note>
<para>
Remarquez que l'utilisation de ce module impose de le charger explicitement
avec l'option <command>-m mac</command>. Il est nécessaire de le rappeler
ici vu le nombre de personne croyant pouvoir l'invoquer seulement par
<command>-m mac-source</command>, ce qui n'est pas possible.
</para>
</note>

<indexterm zone="table.macmatch">
<primary>Mac match</primary>
<secondary>--mac-source</secondary>
</indexterm>
<indexterm zone="table.macmatch">
<primary>--mac-source</primary>
</indexterm>
<indexterm zone="table.macmatch">
<primary>Mac-source match</primary>
</indexterm>

<table frame='all' xml:id="table.macmatch">
<title xml:id="table.macmatch.title">Options de la correspondance Mac</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--mac-source</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m mac --mac-source
00:00:00:00:00:01</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance permet de sélectionner des paquets à
partir de leur <systemitem>adresse MAC source</systemitem>.
L'<systemitem>adresse MAC</systemitem> doit être spécifiée de la forme
<emphasis>XX:XX:XX:XX:XX:XX</emphasis>, autrement elle n'est pas valide.
La correspondance peut être inversée avec le signe <command>!</command> et
ressemble alors à <command>--mac-source ! 00:00:00:00:00:01</command>.
Autrement dit, ceci inverse le sens de la corrrespondance, en sélectionnant
tous les paquets sauf ceux possédant l'<systemitem>adresse MAC</systemitem>
spécifiée. Notez que comme les <systemitem>adresses MAC</systemitem> ne sont
utilisées que dans les réseaux de type Ethernet, cette correspondance ne
s'applique qu'aux interfaces Ethernet. La correspondance
<command>MAC</command> est valide seulement dans les chaînes
<systemitem>PREROUTING</systemitem>, <systemitem>FORWARD</systemitem> et
<systemitem>INPUT</systemitem>, et nulle part ailleurs.
</entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="markmatch">
<title xml:id="markmatch.title">Correspondance Mark</title>
<indexterm zone="markmatch">
<primary>Mark match</primary>
</indexterm>
<indexterm zone="markmatch">
<primary>Match</primary>
<secondary>Mark</secondary>
<seealso>Mark match</seealso>
</indexterm>

<para>
L'extension de correspondance <command>mark</command> permet de sélectionner
des paquets à partir de leur marquage. Le <command>marquage</command>
désigne un champ particulier, pris en charge uniquement au sein du noyau, et
lié aux paquets circulant à travers la machine. Le marquage peut être
employé par différentes routines du noyau pour des tâches comme de la
régulation de trafic ou du filtrage. Aujourd'hui, il n'existe qu'un seul
moyen de définir un marquage sous Linux, c'est la cible 
<command>MARK</command> dans <command>iptables</command>. Auparavant, il
s'agissait de la cible <command>FWMARK</command> dans
<command>ipchains</command>, et c'est pourquoi nombre de gens se réfèrent 
encore à <command>FWMARK</command> dans les documentations avancées sur
le routage.
Le champ de marquage est actuellement défini comme un entier non signé, soit
4294967296 valeurs possibles sur un système 32 bits. En d'autres
termes, vous ne risquez pas de sitôt de dépasser cette limite et vous êtes
tranquille pour quelques temps.
</para>

<indexterm zone="table.markmatch">
<primary>Mark match</primary>
<secondary>--mark</secondary>
</indexterm>
<indexterm zone="table.markmatch">
<primary>--mark</primary>
</indexterm>

<table frame='all' xml:id="table.markmatch">
<title xml:id="table.markmatch.title">Options de la correspondance Mark</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--mark</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -t mangle -A INPUT -m mark --mark
1</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance permet de sélectionner des paquets qui
ont été préalablement marqués. Les marquages peuvent être positionnés avec
la cible <command>MARK</command> développée dans la section suivante. Tous
les paquets transitant par <systemitem>Netfilter</systemitem> se voient
affectés d'un <systemitem>champ de marquage</systemitem> spécial.
Notez que ce <systemitem>champ de marquage</systemitem> n'est propagé en
aucune manière, que ce soit à l'intérieur ou à l'extérieur du paquet. Il
reste exclusivement à l'intérieur de la machine qui l'a créé. Si le
<systemitem>champ de marquage</systemitem> est égal à la valeur de
l'option <command>--mark</command>, il y a correspondance. Le
<systemitem>champ de marquage</systemitem> est un entier non signé, par
conséquent 4294967296 différents marquages peuvent exister. Vous pouvez
également utiliser un masque avec le marquage. Dans ce cas, la spécification
de marquage ressemble, par exemple, à <command>--mark 1/1</command>. Quand
un masque est spécifié, on effectue un ET logique avec le marquage spécifié
avant de réaliser la comparaison réelle.
</entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="multiportmatch">
<title xml:id="multiportmatch.title">Correspondance Multiport</title>
<indexterm zone="multiportmatch">
<primary>Multiport match</primary>
</indexterm>
<indexterm zone="multiportmatch">
<primary>Match</primary>
<secondary>Multiport</secondary>
<seealso>Multiport match</seealso>
</indexterm>

<para>
L'extension de correspondance <command>multiport</command> permet de
spécifier plusieurs ports et intervalles et ports destination. Sans cette
possibilité, vous devriez utiliser différentes règles du même genre, juste
pour établir une correspondance avec différents ports. 
</para>

<note>
<para>
Vous ne pouvez pas utiliser simultanément la correspondance de port standard
et la correspondance multiport. Par exemple, il est inutile d'écrire :
<command>--sport 1024:63353 -m multiport --dport 21,23,80</command>, car ça
ne marchera pas. Si vous le faites quand même, iptables considèrera le
premier élément de la règle et ignorera l'instruction multiport.
</para>
</note>

<indexterm zone="table.multiportmatch">
<primary>Multiport match</primary>
<secondary>--source-port</secondary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>--source-port</primary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>Source-port match</primary>
</indexterm>

<indexterm zone="table.multiportmatch">
<primary>Multiport match</primary>
<secondary>--destination-port</secondary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>--destination-port</primary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>Destination-port match</primary>
</indexterm>

<indexterm zone="table.multiportmatch">
<primary>Multiport match</primary>
<secondary>--port</secondary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>--port</primary>
</indexterm>
<indexterm zone="table.multiportmatch">
<primary>Port match</primary>
</indexterm>

<table frame='all' xml:id="table.multiportmatch">
<title xml:id="table.multiportmatch.title">Options de la correspondance Multiport</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--source-port</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m multiport --source-port
22,53,80,110</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance sélectionne plusieurs ports source. Au
maximum, 15 ports peuvent être spécifiés. Les ports doivent être
séparés par des virgules, comme dans l'exemple ci-dessus. Cette
correspondance ne peut être employée qu'avec les correspondances
<command>-p tcp</command> ou <command>-p udp</command>. C'est principalement
une version améliorée de la correspondance classique
<command>--source-port</command>.
</entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--destination-port</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m multiport
--destination-port
22,53,80,110</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance sélectionne plusieurs ports
destination. Elle fonctionne exactement de la même façon que la
correspondance de port source mentionnée précédemment, excepté qu'elle
s'applique aux ports destination. Elle dispose aussi d'une limite de
15 ports, et ne peut être employée qu'avec <command>-p tcp</command> et
<command>-p udp</command>.
</entry>

</row>

<row>
<entry>Correspondance</entry>
<entry><command>--port</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m multiport --port
22,53,80,110</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette extension de correspondance permet de sélectionner les
paquets à partir à la fois de leur port destination et de leur port source.
Elle fonctionne de la même façon que les correspondances
<command>--source-port</command> et <command>--destination-port</command>
présentées ci-dessus. Elle accepte 15 ports au maximum, et ne peut être
employée qu'avec <command>-p tcp</command> et <command>-p udp</command>.
Notez que la correspondance <command>--port</command> ne peut sélectionner
que les paquets qui viennent et vont vers le même port, par exemple, du port
80 au port 80, du port 110 au port 110, etc.
</entry>
</row>

</tbody>
</tgroup>
</table>
</section>

<section xml:id="ownermatch">
<title xml:id="ownermatch.title">Correspondance Owner</title>
<indexterm zone="ownermatch">
<primary>Owner match</primary>
</indexterm>
<indexterm zone="ownermatch">
<primary>Match</primary>
<secondary>Owner</secondary>
<seealso>Owner match</seealso>
</indexterm>

<para>
L'extension de correspondance <command>owner</command> permet de
sélectionner des paquets à partir de l'identité du processus qui les a
créés. Le propriétaire (<command>owner</command>) peut être spécifié comme
étant l'identifiant de l'utilisateur qui a lancé la commande en question,
de son groupe, du processus, de la session, ou bien de la commande
elle-même. À l'origine, cette extension a été écrite pour donner un exemple
des utilisations possibles d'<command>iptables</command>.
La correspondance <command>owner</command> fonctionne seulement dans la
chaîne <systemitem>OUTPUT</systemitem> pour des raisons évidentes : il
est presque impossible d'extraire des éléments d'information sur l'identité
de l'instance ayant envoyé un paquet à partir de l'autre extrémité, et où
a lieu le saut intermédiaire avant la destination finale. Et même dans la
chaîne <systemitem>OUTPUT</systemitem>, ce n'est pas vraiment fiable puisque
certains paquets peuvent ne pas avoir de propriétaire. Les célèbres paquets
de ce genre sont, entre-autres, les <systemitem>réponses ICMP</systemitem>.
Donc les <systemitem>réponses ICMP</systemitem> ne correspondront jamais.
</para>

<indexterm zone="table.ownermatch">
<primary>Owner match</primary>
<secondary>--cmd-owner</secondary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>--cmd-owner</primary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>Cmd-owner match</primary>
</indexterm>

<indexterm zone="table.ownermatch">
<primary>Owner match</primary>
<secondary>--uid-owner</secondary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>--uid-owner</primary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>Uid-owner match</primary>
</indexterm>

<indexterm zone="table.ownermatch">
<primary>Owner match</primary>
<secondary>--gid-owner</secondary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>--gid-owner</primary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>Gid-owner match</primary>
</indexterm>

<indexterm zone="table.ownermatch">
<primary>Owner match</primary>
<secondary>--pid-owner</secondary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>--pid-owner</primary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>Pid-owner match</primary>
</indexterm>

<indexterm zone="table.ownermatch">
<primary>Owner match</primary>
<secondary>--sid-owner</secondary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>--sid-owner</primary>
</indexterm>
<indexterm zone="table.ownermatch">
<primary>Sid-owner match</primary>
</indexterm>

<table frame='all' xml:id="table.ownermatch">
<title xml:id="table.ownermatch.title">Options de la correspondance Owner</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>

<row>
<entry>Correspondance</entry>
<entry><command>--cmd-owner</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m owner --cmd-owner
httpd</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
C'est la correspondance de la commande owner, utilisée pour faire la
sélection sur la base du nom de commande du processus qui a envoyé le paquet.
Dans l'exemple, httpd est sélectionné. Cette correspondance peut aussi 
être intervertie par un point d'exclamation, par exemple 
<command>-m owner ! --cmd-owner ssh</command>
</para></entry>
</row>


<row>
<entry>Correspondance</entry>
<entry><command>--uid-owner</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m owner --uid-owner
500</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Avec cette correspondance, le paquet est sélectionné s'il a
été créé par l'<computeroutput>identifiant d'utilisateur</computeroutput>
(UID) donné. Ceci permet d'établir une correspondance avec les paquets
sortants basée sur celui qui les a créés. Une utilisation possible serait
d'empêcher tout utilisateur autre que root d'ouvrir de nouvelles connexions
extérieures au pare-feu. Une autre possibilité pourrait être d'empêcher tout
le monde sauf l'utilisateur <computeroutput>http</computeroutput> d'envoyer
des paquets à partir du port <systemitem>HTTP</systemitem>.
 </entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--gid-owner</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m owner --gid-owner
0</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance permet de sélectionner des paquets à
partir de leur <computeroutput>identifiant de groupe</computeroutput> (GID).
Ainsi on établit une correspondance avec tous les paquets associés au
groupe auquel appartient l'utilisateur ayant créé le paquet. Par exemple,
ceci permet d'empêcher tous les utilisateurs sauf ceux appartenant au
groupe <computeroutput>network</computeroutput> de naviguer sur Internet, ou
comme précédemment, d'autoriser seulement les membres du groupe 
<computeroutput>http</computeroutput> à créer des paquets sortants par le
port <systemitem>HTTP</systemitem>.
</entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--pid-owner</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m owner --pid-owner
78</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance permet de sélectionner des paquets à
partir de l'<systemitem>identifiant de processus</systemitem> (PID) qui est
responsable d'eux. Cette correspondance est un peu plus difficile à
utiliser, mais il est possible, par exemple, d'autoriser seulement le 
<systemitem>PID</systemitem> 94 à envoyer des paquets par le port
<systemitem>HTTP</systemitem> (si le processus <systemitem>HTTP</systemitem>
n'est pas un fil d'exécution, bien sûr). Une autre alternative serait
d'écrire un petit script qui récupère le <systemitem>PID</systemitem> à
partir de la sortie d'une commande <command>ps</command> pour un "démon"
spécifique, et qui ajoute ensuite une règle pour le numéro récupéré.
Pour donner un exemple, vous pouvez élaborer une règle comme celle présente
dans l'exemple <link linkend="pid-ownertxt" endterm="pid-ownertxt.title">
</link>.
</entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--sid-owner</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m owner --sid-owner
100</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance permet de sélectionner des paquets à
partir de l'<systemitem>identifiant de session</systemitem> (SID) utilisé
par le programme en question. La valeur du <systemitem>SID</systemitem> d'un
processus est celle du processus lui-même et de tous les processus
découlant du processus d'origine. Ces derniers peuvent être un fil
d'exécution ("thread"), ou un processus fils du processus d'origine. Donc
par exemple, tous les processus <systemitem>HTTPD</systemitem> devraient
posséder le même <systemitem>SID</systemitem> que leur processus parent (le
processus <systemitem>HTTPD</systemitem> d'origine), si le
<systemitem>HTTPD</systemitem> appartient à un fil d'exécution (comme la
plupart des processus <systemitem>HTTPD</systemitem>, Apache et Roxen par
exemple). Ceci est illustré par un petit script qui s'appelle <link 
linkend="sid-ownertxt" endterm="sid-ownertxt.title"></link>. Celui-ci
pourrait éventuellement être lancé toutes les heures et enrichi de code
supplémentaire pour vérifier que l'exécution du processus
<systemitem>HTTPD</systemitem> est toujours en cours et le redémarrer sinon,
avant de vider et redéfinir la chaîne <systemitem>OUTPUT</systemitem> si
nécessaire.
</entry>
</row>

</tbody>
</tgroup>
</table>

<note>
<para>
La sélection des pid et sid ne fonctionne pas avec les noyaux SMP car
ils utilisent différents processus pour chaque processeur. Ce devrait
être réglé dans le futur.
</para>
</note>

</section>

<section xml:id="pkttypematch">
<title xml:id="pkttypematch.title">Correspondance type de paquet</title>
<indexterm zone="pkttypematch">
<primary>Packet type match</primary>
</indexterm>
<indexterm zone="pkttypematch">
<primary>Match</primary>
<secondary>Packet type</secondary>
<seealso>Packet type match</seealso>
</indexterm>

<para>
Cette correspondance sert à sélectionner les paquets basés sur leur type.
C'est à dire, ceux destinés à une personne précise, à tout le monde
ou à un groupe de machines spécifique ou encore des utilisateurs.
Ces trois groupes sont généralement appelés unicast, broadcast et
multicast, comme nous l'avons vu dans le chapitre 
<link linkend="tcpiprepetition" endterm="tcpiprepetition.title"></link>. 
La correspondance est chargée par la commande : <command>-m pkttype</command>.
</para>

<indexterm zone="table.pkttypematch">
<primary>Packet type match</primary>
<secondary>--pkt-type</secondary>
</indexterm>
<indexterm zone="table.pkttypematch">
<primary>--pkt-type</primary>
</indexterm>
<indexterm zone="table.pkttypematch">
<primary>--pkt-type match</primary>
</indexterm>

<table frame='all' xml:id="table.pkttypematch">
<title xml:id="table.pkttypematch.title">Options de la correspondance type de paquet</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--pkt-type</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m pkttype --pkt-type unicast</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La correspondance <command>--pkttype</command> sert à indiquer quel type de 
paquet sélectionner. Elle peut prendre soit <systemitem>unicast</systemitem>, 
<systemitem>broadcast</systemitem> ou <systemitem>multicast</systemitem> 
comme argument, voir l'exemple. Elle peut aussi être inversée par <command>!
</command> comme ceci : <command>-m pkttype --pkttype ! broadcast</command>, 
qui va sélectionner tous les autres types de paquets.
</para></entry>
</row>

</tbody>
</tgroup>
</table>
</section>

<section xml:id="realmmatch">
<title xml:id="realmmatch.title">Correspondance Realm</title>
<indexterm zone="realmmatch">
<primary>Realm match</primary>
</indexterm>
<indexterm zone="realmmatch">
<primary>Match</primary>
<secondary>Realm</secondary>
<seealso>Realm match</seealso>
</indexterm>
<indexterm zone="realmmatch">
<primary>Routing realm</primary>
</indexterm>

<para>
La correspondance realm est utilisée pour sélectionner les paquets basés
sur le domaine de routage dont il font partie. Les domaines de routage
sont utilisés dans Linux pour les scénarios de routage complexe comme
BGP, etc. La correspondance realm est chargée en ajoutant le mot-clé
<command>-m realm</command> à la ligne de commande.
</para>

<para>
Un domaine de routage est utilisé dans Linux pour classer les routes en
groupes logiques. Dans la plupart des routeurs dédiés aujourd'hui, la
Base d'Information de Routage (Routing Information Base - RIB) et le
moteur de transfert sont très proches. Dans le noyau par exemple.
Linux n'est pas réellement un système de routage dédié, il a été forcé
de séparer ses RIB et FIB (Base d'Information de Transfert). Le RIB
se situe au niveau domaine utilisateur et le FIB au niveau du noyau.
À cause de cette séparation, il devient gourmand en ressource de faire
des recherches rapides dans le RIB. Le domaine de routage est la solution 
Linux pour ça, il rend le système plus flexible et plus riche. 
</para>

<para>
Les domaines Linux peuvent être utilisés avec BGP et autres protocoles de
routage qui délivrent une grande quantité de routes. Le démon de routage
peut alors trier les routes par leur préfixe, chemin ou source par exemple, et
les placer dans différents domaines. Le domaine est numérique, mais peut aussi
être nommé par le fichier <filename>/etc/iproute2/rt_realms</filename>.
</para>

<indexterm zone="table.realmmatch">
<primary>Realm match</primary>
<secondary>--realm</secondary>
</indexterm>
<indexterm zone="table.realmmatch">
<primary>--realm</primary>
</indexterm>

<table frame='all' xml:id="table.realmmatch">
<title xml:id="table.realmmatch.title">Options de la correspondance Realm</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--realm</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m realm --realm 4</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette option sélectionne le nombre de domaines et optionnellement un masque.
Si ce n'est pas un nombre, il résoudra le domaine par le fichier 
<filename>/etc/iproute2/rt_realms</filename>. Si un domaine nommé est utilisé, 
aucun masque ne devra être utilisé. Le domaine peut aussi être interverti
en plaçant un point d'exclamation, par exemple <command>--realm ! cosmos</command>.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="recentmatch">
<title xml:id="recentmatch.title">Correspondance Recent</title>
<indexterm zone="recentmatch">
<primary>Recent match</primary>
</indexterm>
<indexterm zone="recentmatch">
<primary>Match</primary>
<secondary>Recent</secondary>
<seealso>Recent match</seealso>
</indexterm>

<para>
La correspondance recent est une système plutôt important et complexe, qui
nous permet de sélectionner des paquets basés sur les événements récents. 
Exemple, si nous voulons voir une sortie de connexion IRC, nous pouvons placer
l'adresse IP dans une liste d'hôtes, et avoir une autre règle qui permet
des requêtes d'identification en retour d'un serveur IRC dans les 15 secondes
de veille du paquet d'origine.
</para>

<para>
Avant nous pouvons avoir une vue plus précise de cette correspondance, 
voyons comment elle fonctionne. En premier, nous utilisons différentes règles
pour utiliser l'appariement récent. Celui-ci se sert de plusieurs listes
d'événements récents. Par défaut la liste utilisée est DEFAULT. Nous créons
une nouvelle entrée dans la liste avec cette option, ainsi une fois qu'une 
règle est complètement vérifiée (l'option placée est toujours une 
correspondance), nous pouvons ajouter une entrée dans la liste récente
spécifiée. L'entrée de la liste contient un horodatage, et l'adresse source IP
utilisée dans le paquet qui déclenche l'option. Une fois ceci fait, nous
pouvons utiliser une série d'options différentes pour sélectionner cette
information, comme la mise à jour des entrées d'horodatage, etc. 
</para>
 
 <para>
Enfin, si nous voulons pour quelque raison supprimer une entrée de la liste,
nous pouvons le faire en supprimant la correspondance du module récent.
Toutes les règles utilisant la correspondance Recent, doivent charger ce
module (<command>-m recent</command>). Voyons en les options.
 </para>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--name</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--name</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Name match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--set</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--set</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Set match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--rcheck</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--rcheck</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Rcheck match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--update</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--update</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Update match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--remove</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--remove</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Remove match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--seconds</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--seconds</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Seconds match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--hitcount</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--hitcount</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Hitcount match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--rttl</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--rttl</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Rttl match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--rsource</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--rsource</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Rsource match</primary>
</indexterm>

<indexterm zone="table.recentmatch">
<primary>Recent match</primary>
<secondary>--rdest</secondary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>--rdest</primary>
</indexterm>
<indexterm zone="table.recentmatch">
<primary>Rdest match</primary>
</indexterm>

<table frame='all' xml:id="table.recentmatch">
<title xml:id="table.recentmatch.title">Options de la correspondance Recent</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>
<row>
<entry>Correspondance</entry>
<entry><command>--name</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m recent --name examplelist</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'option "name" donne le nom de la liste à utiliser. Par défaut la liste
DEFAULT est utilisée, ce qui n'est probablement pas ce que nous voulons si
nous nous servons de plus d'une liste.
</para></entry>
</row>
   
   <row>
<entry>Correspondance</entry>
<entry><command>--set</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m recent --set</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Ceci crée une nouvelle entrée dans la liste récente, qui contient un
horodatage et l'adresse source IP de l'hôte qui a déclenché la règle.
Cette correspondance retournera toujours vrai, sauf si elle précédée
du signe !, auquel cas elle renverra faux.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--rcheck</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m recent --name examplelist --rcheck</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'option <command>--rcheck</command> vérifie si l'adresse IP source du
paquet est dans la liste nommée. Si c'est le cas, la correspondance renvoit
un "vrai", dans le cas contraire elle renverra un "faux". Cette option
peut être inversée avec le signe !. Dans ce dernier cas, elle renverra
vrai si l'adresse IP source n'est pas dans la liste, et faux si elle est
dans la liste.
</para></entry>
</row>
   
<row>
<entry>Correspondance</entry>
<entry><command>--update</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A OUTPUT -m recent --name examplelist --update</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance est vraie si la source est disponible dans la liste
spécifiée et met à jour le dernier horodatage dans la liste. Elle peut aussi
être inversée par le ! devant le module. Exemple, 
<command>! --update</command>. 
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--remove</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --remove</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance essaie de trouver l'adresse source du paquet
dans la liste, et renvoie un vrai si le paquet est présent.
Elle supprimera aussi l'entrée de liste correspondante de la liste.
Cette commande peut être inversée avec le signe <command>!</command>.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--seconds</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --check --seconds 60</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette correspondance n'est valide seulement qu'avec les commandes 
 <command>--check</command> et
<command>--update</command>. Le module <command>--seconds</command> est
utilisé pour spécifier le délai de mise à jour de la colonne "dernier
apperçu" dans la liste récente. Si la colonne dernier apperçu est plus
ancienne qu'un certain nombre de secondes, la correspondance renvoit faux.
Si la correspondance récent fonctionne normalement, l'adresse source
doit toujours être dans la liste pour un retour vrai de la correspondance.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--hitcount</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --check --hitcount 20</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La correspondance <command>--hitcount</command> doit être utilisée avec les
commandes <command>--check</command> ou <command>--update</command>, elle
limitera la sélection aux seuls paquets vus par le compteur.
Si cette correspondance est utilisée avec la commande 
<command>--seconds</command>, cela nécessite que le compteur de paquets
spécifié soit vu dans le bloc de temps. Elle peut être inversée par le signe 
<command>!</command> devant la commande. Avec la commande 
<command>--seconds</command>, elle indique le maximum de paquets qui peuvent
avoir été vus durant le bloc de temps spécifié. Si les deux correspondances 
sont inversées, alors un maximum de paquets peuvent avoir été vus durant
le dernier minimum de secondes.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--rttl</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --check --rttl</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La correspondance <command>--rttl</command> vérifie que la valeur TTL du
paquet est la même que celle du paquet original utilisé pour placer
l'entrée dans la liste récente. Ceci peut être utilisé pour vérifier que
les adresses sources de personnes n'ont pas été mystifiées (spoofing)
pour interdire aux autres l'accès à leur serveur en faisant usage de la
correspondance recent.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--rsource</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --rsource</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
La correspondance <command>--rsource</command> indique au module recent
de sauvegarder l'adresse source et les ports dans la liste recent. C'est
le comportement par défaut.
</para></entry>
</row>

<row>
<entry>Correspondance</entry>
<entry><command>--rdest</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m recent --name example --rdest</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
<command>--rdest</command> est l'opposé de  
<command>--rsource</command> en ce qu'elle indique à la correspondance
recent d'enregistrer l'adresse et le port de destination dans la liste recent.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

<indexterm zone="recentmatch.example">
<primary>Recent match example</primary>
</indexterm>
<indexterm zone="recentmatch.example">
<primary>Example scripts</primary>
<secondary>Recent-match.txt</secondary>
</indexterm>

<para xml:id="recentmatch.example">
j'ai créé un petit exemple de script sur la façon d'utiliser la
correspondance recent, vous pouvez le trouver dans la section 
<link linkend="recent-matchtxt" endterm="recent-matchtxt.title"></link>. 
</para>

<para>
En bref, c'est une pauvre variation de la machine d'état disponible dans
netfilter. Cette version fut créé avec à l'esprit un serveur http, mais
qui fonctionnera avec n'importe quelle connexion TCP. En premier, nous avons 
créé deux chaînes nommées http-recent et http-final. La chaîne http-recent
est utilisée aux étapes du démarrage de la connexion, et pour la 
transmission des données, tandis que la chaîne http-final est utilisée
pour les derniers FIN, FIN/ACK dans l'établissement de la liaison.
</para>

<warning>
<para>
C'est une très mauvaise alternative pour la machine d'état et elle ne
dispose pas de toutes les possibilités de la machine d'état. Cependant,
c'est un bon exemple de ce qui peut être fait avec la correspondance Recent
sans être trop spécifique. N'utilisez pas cet exemple en production.
Il est lent, gère mal les cas spéciaux, et ne doit être jamais être utilisé 
que comme un exemple.
</para>

<para>
Par exemple, il ne gère pas les ports fermés dans une connexion, les
établissements de liaison FIN asynchrones (où une des parties connectée
se ferme, tandis que l'autre continue d'envoyer des données), etc.
</para>
</warning>

<para>
Suivons un paquet à travers l'exemple de la table de règles. D'abord le 
paquet entre dans la chaîne <systemitem>INPUT</systemitem>, et nous l'envoyons
à la chaîne <systemitem>http-recent</systemitem>. 
</para>

<orderedlist numeration="arabic" inheritnum="inherit">
<listitem>
<para>
Le premier paquet sera un paquet SYN, et n'aura pas de bit ACK, FIN ou RST 
placé. Il est sélectionné en utilisant la ligne
<command>--tcp-flags SYN,ACK,FIN,RST SYN</command>. À ce niveau nous ajoutons
la connexion à httplist avec la ligne 
<command>-m recent --name httplist --set</command>. Enfin nous acceptons
le paquet.
</para>
</listitem>

<listitem>
<para>
Après le premier paquet nous recevons un paquet SYN/ACK indiquant que
le paquet SYN a été reçu. Ceci peut être vérifié en utilisant la ligne 
<command>--tcp-flags SYN,ACK,FIN,RST SYN,ACK</command>. FIN et RST 
sont illégaux à ce niveau. Nous mettons à jour l'entrée dans httplist par 
<command>-m recent --name httplist --update</command> et finalement nous avons 
l'ACCEPT du paquet.
</para>
</listitem>

<listitem>
<para>
Maintenant nous obtenons un paquet final ACK, venant du créateur de la
connexion, nous permettant de savoir que le SYN/ACK a été envoyé par
le serveur. SYN, FIN et RST devraient être illégaux à ce point de la 
connexion, et la ligne ressemblera à 
<command>--tcp-flags SYN,ACK,FIN,RST ACK</command>. 
Nous mettons à jour la liste de la même façon que dans l'étape précédente,
et nous ACCEPTons.
</para>
</listitem>

<listitem>
<para>
À ce niveau, la transmission de données peut démarrer. La connexion ne
contiendra jamais aucun paquet SYN maintenant, mais contiendra des paquets
ACK pour permettre de savoir que les données sont envoyées. Chaque fois
que nous voyons un paquet comme celui-là, nous mettons à jour la liste
et ACCEPTons les paquets.
</para>
</listitem>

<listitem>
<para>
La transmission peut se terminer de deux façons, la plus simple est
le paquet RST. RST réinitialisera la connexion et la coupera. Avec 
FIN/ACK le correspondant répond avec un FIN, et ferme la connexion
ainsi l'expéditeur du FIN/ACK ne peut plus envoyer de données.
L'hôte qui reçoit le FIN pourra toujours envoyer des données, et nous
arrivons à l'étape finale de la connexion.
</para>
</listitem>

<listitem>
<para>
Dans les chaînes http-recent-final nous vérifions si le paquet est toujours
dans la httplist, et si c'est le cas, nous l'envoyons à la chaîne
http-recent-final1. Dans cette chaîne nous supprimons la connexion de la 
httplist l'ajoutons à la liste http-recent-final. Si la connexion a déjà
été supprimée et déplacée vers la liste http-recent-final, nous envoyons
le paquet vers la chaîne http-recent-final2.
</para>
</listitem>

<listitem>
<para>
Dans la chaîne http-recent-final2, nous attendons que la partie non fermée
finisse d'envoyer ses données, et fermons ensuite la connexion. Une fois
ceci fait, la connexion est définitivement fermée.
</para>
</listitem>
</orderedlist>

<para>
Comme nous l'avons vu la liste recent peut devenir tout à fait complexe, 
mais elle nous donne un vaste éventail de possibilités si nécessaire.
Encore une fois, nous ne réinventons pas la roue. Si la fonctionnalité
que vous désirez est déjà implémentée, utilisez la au lieu d'essayer de
créer votre propre solution.
</para>
</section>


<section xml:id="statematch">
<title xml:id="statematch.title">Correspondance State</title>
<indexterm zone="statematch">
<primary>State match</primary>
</indexterm>
<indexterm zone="statematch">
<primary>Match</primary>
<secondary>State</secondary>
<seealso>State match</seealso>
</indexterm>

<para>
L'extension de correspondance <command>state</command> est associée
au code de traçage de connexion dans le noyau. La correspondance d'état
accède à l'état du traçage de connexion des paquets grâce à la machine de
"conntracking". Elle permet de savoir dans quel état se trouve la connexion,
et fonctionne pour quasiment tous les protocoles y compris les protocoles
sans état tels que <systemitem>ICMP</systemitem> et
<systemitem>UDP</systemitem>. Dans tous les cas, la connexion est
sujette à un dépassement de temps établi par défaut ("default timeout")
et sera, le cas échéant, supprimée de la base de données du traçage de
connexion. Cette correspondance exige d'être chargée explicitement en
ajoutant la directive <command>-m state</command> à la règle. Vous
disposerez alors d'une nouvelle correspondance appelée
<command>state</command>. Le concept de correspondance d'état est couvert
plus en détail dans le chapitre <link linkend="statemachine"
endterm="statemachine.title"></link>, étant donné que le sujet est assez
vaste.
</para>

<indexterm zone="table.statematches">
<primary>State match</primary>
<secondary>--state</secondary>
</indexterm>
<indexterm zone="table.statematches">
<primary>--state</primary>
</indexterm>

<table frame='all' xml:id="table.statematches">
<title xml:id="table.statematches.title">Options de la correspondance State</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>

<row>
<entry>Correspondance</entry>
<entry><command>--state</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -m state --state
RELATED,ESTABLISHED</command>
</entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
Cette option indique à la correspondance <command>state</command> 
dans quels états doivent être les paquets pour être
sélectionnés. Actuellement, 4 états sont disponibles :
<command>INVALID</command>, <command>ESTABLISHED</command>,
<command>NEW</command> et <command>RELATED</command>.
<command>INVALID</command> signifie que le paquet n'est associé à aucun
flux, ni à aucune connexion connus, et qu'il peut contenir des données ou
des en-têtes erronés. <command>ESTABLISHED</command> signifie que le paquet
est lié à une connexion déjà établie, qui a vu passer des paquets dans
les deux directions et qui est considérée comme valide. <command>NEW</command>
signifie que le paquet a démarré ou démarrera une nouvelle connexion, ou
bien qu'il est associé à une connexion qui n'a pas vu passer des paquets
dans les deux directions. Enfin, <command>RELATED</command> signifie que le
paquet démarre une nouvelle connexion et qu'il est associé à une connexion
déjà établie. Ceci peut évoquer par exemple un <systemitem>transfert de
données par FTP</systemitem>, ou une <systemitem>erreur ICMP</systemitem>
associée à une connexion <systemitem>TCP</systemitem> ou 
<systemitem>UDP</systemitem>. Notez que l'état <command>NEW</command>
n'examine pas les bits <systemitem>SYN</systemitem> des paquets
<systemitem>TCP</systemitem> qui tentent de démarrer une nouvelle connexion.
Par conséquent, cet état ne devrait pas être utilisé tel quel dans les
situations où il n'existe qu'un seul pare-feu, ou quand il n'y a pas
d'équilibrage de charge entre les différents pare-feux. Cependant, cet état
se révèle utile dans certains cas. Pour en savoir plus, consultez le
chapitre <link linkend="statemachine" endterm="statemachine.title"></link>.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="tcpmssmatch">
<title xml:id="tcpmssmatch.title">Correspondance Tcpmss</title>
<indexterm zone="tcpmssmatch">
<primary>Tcpmss match</primary>
</indexterm>
<indexterm zone="tcpmssmatch">
<primary>Match</primary>
<secondary>Tcpmss</secondary>
<seealso>Tcpmss match</seealso>
</indexterm>
<indexterm zone="tcpmssmatch">
<primary>RFC</primary>
<secondary>793</secondary>
</indexterm>
<indexterm zone="tcpmssmatch">
<primary>RFC</primary>
<secondary>1122</secondary>
</indexterm>

<para>
La correspondance <command>tcpmss</command> est utilisée pour sélectionner 
un paquet basé sur le
<systemitem>Maximum Segment Size</systemitem> (Taille maximum de segment) 
dans <systemitem>TCP</systemitem>. 
Ceci vérifie seulement la validité des paquets 
<systemitem>SYN</systemitem> 
et <systemitem>SYN/ACK</systemitem>. Pour une explication plus détaillée de
la valeur MSS, voir l'annexe, 
<link linkend="tcpoptions" endterm="tcpoptions.title"></link> 
la <link linkend="rfc793" endterm="rfc793.title"></link> et la 
<link linkend="rfc1122" endterm="rfc1122.title"></link>. Cette correspondance 
est chargée en utilisant <command>-m tcpmss</command> et prend uniquement
cette option.
</para>

<indexterm zone="table.tcpmssmatch">
<primary>Tcpmss match</primary>
<secondary>--mss</secondary>
</indexterm>
<indexterm zone="table.tcpmssmatch">
<primary>--mss</primary>
</indexterm>
<indexterm zone="table.tcpmssmatch">
<primary>Mss match</primary>
</indexterm>

<table frame='all' xml:id="table.tcpmssmatch">
<title xml:id="table.tcpmssmatch.title">Options de la correspondance Tcpmss</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>

<row>
<entry>Correspondance</entry>
<entry><command>--mss</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp --tcp-flags SYN,ACK,RST SYN -m tcpmss --mss 2000:2500</command>
</entry>
</row>
<row>
<entry>Explication</entry>
<entry><para>
L'option <command>--mss</command> indique à la correspondance tcpmss
quel <systemitem>Maximum Segment Size</systemitem> sélectionner. Ceci 
peut être soit une simple valeur MSS, soit une plage de valeurs MSS 
séparées par <command>:</command>. La valeur peut être inversée par le signe 
 <command>!</command>, comme dans l'exemple suivant : 
</para><para>
<command>-m tcpmss ! --mss 2000:2500</command>
</para><para>
Cet exemple vérifiera toutes les valeurs MSS, sauf les valeurs comprises
dans la plage 2000 à 2500.
</para></entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="tosmatch">
<title xml:id="tosmatch.title">Correspondance Tos</title>
<indexterm zone="tosmatch">
<primary>Tos match</primary>
</indexterm>
<indexterm zone="tosmatch">
<primary>Match</primary>
<secondary>Tos</secondary>
<seealso>Tos match</seealso>
</indexterm>

<para>
La correspondance <command>TOS</command> peut servir à sélectionner les
paquets à partir de leur <systemitem>champ de TOS</systemitem>.
<systemitem>TOS</systemitem> signifie <systemitem>type de service
</systemitem>; il est constitué de 8 bits et se situe dans
l'en-tête IP. Cette correspondance est chargée explicitement en ajoutant
<command>-m tos</command> à la règle. Elle est normalement utilisée afin
d'informer les hôtes intermédiaires de l'ordre de priorité du flux et de son
contenu (ce n'est pas vraiment le cas, mais il informe des besoins
spécifiques au flux, comme une réexpédition aussi rapide que possible,
ou un impératif de débit). Les différents routeurs et administrateurs gèrent
ces valeurs de façon variable. La plupart ne s'en préoccupent pas du tout,
alors que d'autres font de leur mieux pour gérer les paquets en question et
les données qu'ils fournissent.
</para>

<indexterm zone="table.tosmatch">
<primary>Tos match</primary>
<secondary>--tos</secondary>
</indexterm>
<indexterm zone="table.tosmatch">
<primary>--tos</primary>
</indexterm>

<table frame='all' xml:id="table.tosmatch">
<title xml:id="table.tosmatches.title">Options de la correspondance Tos</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>

<colspec colwidth='1.5*'/>
<colspec colwidth='8*'/>

<tbody>

<row>
<entry>Correspondance</entry>
<entry><command>--tos</command></entry>
</row>
<row>
<entry>Noyau</entry>
<entry>2.3, 2.4, 2.5 et 2.6</entry>
</row>
<row>
<entry>Exemple</entry>
<entry><command>iptables -A INPUT -p tcp -m tos --tos
0x16</command></entry>
</row>
<row>
<entry>Explication</entry>
<entry>
Cette correspondance s'utilise tel que décrit
ci-dessus. Elle sélectionne les paquets à partir de leur <systemitem>champ
de TOS</systemitem> et de sa valeur. Ceci peut être employé avec le
programme <command>iproute2</command> et les fonctions avancées de routage
de Linux pour effectuer un <command>marquage</command> des paquets pour un
usage ultérieur. La correspondance prend en option une valeur hexadécimale
ou numérique, ou éventuellement un des noms fournis par la commande
'<command>iptables -m tos -h</command>'. Actuellement, elle fournit les noms
suivants :
<computeroutput>Minimize-Delay 16 (0x10)</computeroutput>,
<computeroutput>Maximize-Throughput 8 (0x08)</computeroutput>,
<computeroutput>Maximize-Reliability 4 (0x04)</computeroutput>,
<computeroutput>Minimize-Cost 2 (0x02)</computeroutput>, et
<computeroutput>Normal-Service 0 (0x00)</computeroutput>.
<computeroutput>Minimize-Delay</computeroutput> signale de minimiser le
retard pour les paquets qui traversent - les services classiques qui
requièrent ceci peuvent être, par exemple, <systemitem>telnet</systemitem>,
<systemitem>SSH</systemitem> et <systemitem>FTP-control</systemitem>.
<computeroutput>Maximize-Throughput</computeroutput> précise de trouver un
chemin qui offre le plus haut débit possible - un protocole typique est
<systemitem>FTP-data</systemitem>.
<computeroutput>Maximize-Reliability</computeroutput> indique de maximiser
la fiabilité de la connexion, donc d'utiliser des lignes aussi fiables que
possible - deux exemples typiques sont <systemitem>BOOTP</systemitem> et
<systemitem>TFTP</systemitem>.
<computeroutput>Minimize-Cost</computeroutput> signale de minimiser le coût
des paquets qui traversent tous les liens vers le client ou le
serveur ; par exemple, déterminer la route qui offre le voyage le moins
onéreux de bout en bout. Des exemples de protocoles classiques qui peuvent
l'utiliser sont <systemitem>RTSP</systemitem> ("Real Time Stream Control
Protocol" ou protocole de contrôle de flux en temps-réel) et d'autres
protocoles de flux vidéo/audio.
Enfin, <computeroutput>Normal-Service</computeroutput> désigne tout
protocole classique n'ayant aucun besoin particulier.
</entry>
</row>

</tbody>
</tgroup>
</table>

</section>

<section xml:id="ttlmatch">
<title xml:id="ttlmatch.title">Correspondance Ttl</title>
<indexterm zone="ttlmatch">
<primary>Ttl match</primary>
</indexterm>
<indexterm>
<primary>Match</primary>
<secondary>Ttl</secondary>
<seealso>Ttl match</seealso>
</indexterm>

<para>
La correspondance <command>TTL</command> permet de sélectionner les paquets
à partir de leur champ <systemitem>TTL</systemitem> ("Time To Live" ou durée
de vie) localisé dans l'en-tête IP. Le <systemitem>champ TTL</systemitem>
contient 8 bits de données, et il est décrémenté de 1 à chaque fois
qu'il est traité par un hôte intermédiaire entre le client et l'hôte
destinataire. Si le <systemitem>TTL</systemitem> atteint 0, un message
<systemitem>ICMP</systemitem> type 11 code 0 (TTL égal à 0 pendant le
transit) ou code 1 (TTL égal à 0 pendant le réassemblage) est transmis à
l'expéditeur du paquet pour l'informer du problème. Cette correspondance
est utilisée seulement pour sélectionner les paquets à partir de leur 
<systemitem>TTL</systemitem>, et non pour effectuer une modification 
quelle qu'elle soit. Ce comportement, soit dit en passant, s'applique 
à tout type de correspondance. Pour charger cette correspondance, 
vous devez ajouter <command>-m ttl</command> à la règle.    
</para>

<indexterm zone="table.ttlmatch">
<primary>Ttl match</primary>
<secondary>--ttl-eq</secondary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>--ttl-eq</primary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>Ttl-eq match</primary>
</indexterm>

<indexterm zone="table.ttlmatch">
<primary>Ttl match</primary>
<secondary>--ttl-gt</secondary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>--ttl-gt</primary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>Ttl-gt match</primary>
</indexterm>

<indexterm zone="table.ttlmatch">
<primary>Ttl match</primary>
<secondary>--ttl-lt</secondary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>--ttl-lt</primary>
</indexterm>
<indexterm zone="table.ttlmatch">
<primary>Ttl-lt match</primary>
</indexterm>

<table frame='all' xml:id="table.ttlmatch">
<title xml:id="table.ttlmatch.title">Options de la correspondance Ttl</title>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>

          <colspec colwidth='1.5*'/>
          <colspec colwidth='8*'/>

          <tbody>

            <row>
              <entry>Correspondance</entry>
              <entry><command>--ttl-eq</command></entry>
            </row>
            <row>
              <entry>Noyau</entry>
              <entry>2.3, 2.4, 2.5 et 2.6</entry>
            </row>
            <row>
              <entry>Exemple</entry>
              <entry><command>iptables -A OUTPUT -m ttl --ttl-eq 60</command></entry>
            </row>
            <row>
              <entry>Explication</entry>
              <entry>
Cette option de correspondance permet de spécifier la valeur
<systemitem>TTL</systemitem> à sélectionner. Cette option requiert une
valeur numérique et établit une correspondance avec cette valeur dans le
paquet. Aucune inversion n'est disponible et il n'y a rien d'autre, en
particulier, à sélectionner. Mais ceci peut être utile, par exemple, pour
déboguer votre réseau local - c'est-à-dire les hôtes de votre LAN qui
semblent présenter des problèmes de connexion avec un hôte sur Internet - ou
pour trouver d'éventuelles entrées de chevaux de Troie, etc. Les
possibilités de cette option sont relativement limitées, cependant son
intérêt dépend essentiellement de votre imagination. Un exemple pourrait
être de trouver des hôtes avec de mauvaises valeurs par défaut de
<systemitem>TTL</systemitem> (pouvant être la conséquence d'un pile
<systemitem>TCP/IP</systemitem> mal implémentée, ou simplement d'un défaut
de configuration).
           </entry>
         </row>

         <row>
           <entry>Correspondance</entry>
           <entry><command>--ttl-gt</command></entry>
         </row>
         <row>
           <entry>Noyau</entry>
           <entry>2.3, 2.4, 2.5 et 2.6</entry>
         </row>
         <row>
           <entry>Exemple</entry>
           <entry><command>iptables -A OUTPUT -m ttl --ttl-gt 64</command></entry>
         </row>
         <row>
           <entry>Explication</entry>
           <entry>
Cette option sert à sélectionner un TTL plus grand que la valeur spécifiée.
La valeur peut être comprise entre 0 et 255 et la correspondance ne peut 
pas être intervertie. Elle peut, par exemple sélectionner un TTL plus 
grand qu'une valeur spécifiée et ensuite la forcer vers une valeur 
standardisée. Elle peut être utilisée pour contourner certaines formes
d'espionnage de la part des fournisseurs d'accès qui cherchent à savoir
si vous avez plusieurs machines derrière un pare-feu, à l'encontre de leurs
règlements.
           </entry>
         </row>

         <row>
           <entry>Correspondance</entry>
           <entry><command>--ttl-lt</command></entry>
         </row>
         <row>
           <entry>Noyau</entry>
           <entry>2.3, 2.4, 2.5 et 2.6</entry>
         </row>
         <row>
           <entry>Exemple</entry>
           <entry><command>iptables -A OUTPUT -m ttl --ttl-lt 64</command></entry>
         </row>
         <row>
           <entry>Explication</entry>
             <entry>
La correspondance <command>--ttl-lt</command> est utilisée pour sélectionner
les TTL plus petits qu'une valeur spécifiée. C'est à peu près la même que 
<command>--ttl-gt</command>, mais sélectionne les TTL plus petits. Elle
peut être utilisée également de la même façon que <command>--ttl-gt</command>, 
ou pour simplement homogénéiser les paquets quittant votre réseau en général.
             </entry>
           </row>
         </tbody>
       </tgroup>
      </table>
    </section>

    <section xml:id="uncleanmatch">
     <title xml:id="uncleanmatch.title">Correspondance Unclean</title>
    <indexterm zone="uncleanmatch">
      <primary>Unclean match</primary>
    </indexterm>
    <indexterm zone="uncleanmatch">
      <primary>Match</primary>
      <secondary>Unclean</secondary>
      <seealso>Unclean match</seealso>
    </indexterm>

     <para>
La correspondance <command>unclean</command> ne prend aucune
option et ne nécessite rien de plus qu'un chargement explicite si vous
souhaitez l'utiliser. Notez que cette option est considérée comme
expérimentale, qu'elle peut ne pas fonctionner en toutes circonstances et
qu'elle ne prendra pas en charge tous les paquetages ou problèmes relatifs à
unclean. La correspondance <command>unclean</command> tente de sélectionner
les paquets qui paraissent malformés ou inhabituels, comme des paquets avec
des en-têtes ou des sommes de contrôle (checksums) erronés. Elle peut être
utilisée pour rejeter des connexions (avec la cible <command>DROP</command>)
et pour rechercher les flux douteux par exemple. Cela dit, vous devez être
conscient qu'il existe un risque d'interruption de connexions saines.    
     </para>
    </section>
   </section>

   <section>
     <title>Prochain chapitre</title>

     <para>
Dans le prochain chapitre nous parlerons des cibles en détail et ce
qu'elles sont capables de faire. Vous y verrez les possibilités de
développement de pare-feux de Linux.
     </para>
   </section>

</chapter>
