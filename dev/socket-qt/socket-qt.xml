<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

]>

<article xml:id='socket-qt' xml:lang='fr'>

<info>
  <title>Initiation au développement Qt sur les sockets</title>

  &author;
  <abstract>
    <para>Ce support est la suite de l'initiation au développement en Langage C
    sur les sockets. L'objectif est à nouveau le même ; utiliser un code
    minimaliste accessible aux débutants. Les bibliothèques Qt présentent un
    grand intérêt lorsque l'on souhaite produire du code indépendant du système
    d'exploitation sous-jacent. On aborde aussi la programmation orientée objet
    avec ces bibliothèques.</para>
  </abstract>
  <keywordset>
    <keyword>GNU</keyword>
    <keyword>Linux</keyword>
    <keyword>inetdoc</keyword>
    <keyword>socket</keyword>
    <keyword>udp</keyword>
    <keyword>tcp</keyword>
    <keyword>client</keyword>
    <keyword>serveur</keyword>
    <keyword>qt</keyword>
    <keyword>qtcreator</keyword>
  </keywordset>
</info>

<sect1 xml:id='socket-qt.legal.meta'>
  &legal;

  <sect2 xml:id='socket-qt.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="http://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='socket-qt.context'>
  <title>Contexte de développement</title>

  <para>Comme ce support est la suite de celui sur le Langage C, on reprend le
  même découpage en deux programmes distincts : un serveur et un client. À la
  différence du support précédent, on ne présente pas le code des deux
  programmes. Dans le but de limiter le volume du document, on introduit
  uniquement le code de la partie serveur qui reçoit le message, le traite et
  le réexpédie au client. On peut très bien réutiliser le programme client déjà
  développé en Langage C : &url.socket-c.udp-client;</para>

  <para>Le principe d'illustration des communications réseau reste le même :
  l'échange de chaînes de caractères. Le <emphasis>client</emphasis> émet un
  message que le <emphasis>serveur</emphasis> traite et retransmet vers le
  <emphasis>client</emphasis>. Le traitement est toujours aussi minimaliste ;
  le <emphasis>serveur</emphasis> convertit la chaîne de caractères en
  majuscules.</para>

  <sect2 xml:id='socket-qt.context.archi'>
    <title>Bibliothèques Qt</title>

  <para>Le diagramme ci-dessous présente l'architecture des bibliothèques Qt.
  Il met en évidence l'indépendance entre les développements et les systèmes
  d'exploitation cibles.</para>

  <mediaobject xml:id='socket-qt-arch'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/qt-architecture.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/qt-architecture.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Architecture Qt - source qt.nokia.com</phrase>
    </textobject>
  </mediaobject>

  <para>Dans notre contexte, on utilise le Langage C++ et l'environnement de
  développement intégré <citetitle>Qt Creator</citetitle>. Cet environnement de
  développement intègre les bibliothèques Qt réseau dont nous avons
  besoin.</para>

  <para>On se propose de développer le programme serveur en deux temps.</para>

  <itemizedlist>
    <listitem>
    <para>Une version sans graphisme mettant en évidence les appels de
    bibliothèques propres à l'utilisation des
    <wordasword>sockets</wordasword>.</para>
    </listitem>
    <listitem>
    <para>Une version avec une fenêtre graphique dans laquelle on affiche les
    messages reçus depuis un programme client ainsi que l'adresse
    <acronym>IP</acronym> et le numéro de port utilisés par ce programme
    client.</para> 
    </listitem>
  </itemizedlist>
  </sect2>

  <sect2 xml:id='socket-qt.context.run'>
    <title>Instructions d'exécution</title>

  <para>On exécute le programme <emphasis>client</emphasis> déjà développé en
  Langage C dans un <wordasword>Shell</wordasword> alors que le programme
  <emphasis>serveur</emphasis> est géré directement par l'environnement
  <citetitle>Qt Creator</citetitle>. On peut exécuter ces deux programmes sur
  le même hôte en utilisant l'interface de boucle locale pour les
  communications réseau.</para>

  <variablelist>
    <varlistentry xml:id='socket-qt.context.run-server'>
      <term>Le programme serveur</term>
      <term>nogui-udp-receiver</term>
      <listitem>

  <mediaobject xml:id='socket-qt.context.run-server-qtcreator'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/qt-creator-nogui-udp-receiver.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/qt-creator-nogui-udp-receiver.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Qt Creator - exécution du programme serveur</phrase>
    </textobject>
  </mediaobject>

    <note>
      <para>Déplacer le pointeur de la souris sur l'image, clicker sur le
      bouton droit et lancer «Afficher l'image» pour lire les messages.</para>
    </note>

      <para>C'est dans la partie inférieure droite de la copie d'écran que l'on
      retrouve en rouge les messages échangés entre les programmes
      <emphasis>client</emphasis> et <emphasis>serveur</emphasis>. Le code
      utilisé ici correspond à la version sans graphisme du programme
      <emphasis>serveur</emphasis>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.context.run-client'>
      <term>Le programme client</term>
      <term>udp-client.o</term>
      <listitem>
<screen width='80'><prompt>$</prompt> ./udp-client.o
Entrez le nom du serveur ou son adresse IP : 
127.0.0.1                  
Entrez le numéro de port du serveur : 
8888

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
        texte de test avec tabulation et espaces
Message traité : TEXTE DE TEST AVEC TABULATION ET ESPACES
Saisie du message : 
_exit_
Message traité : _EXIT_
Saisie du message : 
serveur arrêté
** Le serveur n'a répondu dans la seconde.
Saisie du message : 
.</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>Lorsque le programme <emphasis>serveur</emphasis> est en cours
  d'exécution, il est possible de visualiser la correspondance entre le
  processus en cours d'exécution et le numéro de port en écoute à l'aide de la
  commande <command>netstat</command>.</para>

<screen width='80'><prompt>$</prompt> netstat -aup | grep -e Proto -e 8888
(Tous les processus ne peuvent être identifiés, les infos sur les processus
non possédés ne seront pas affichées, vous devez être root pour les voir toutes.)
Proto Recv-Q Send-Q Adresse locale    Adresse distante  Etat  PID/Program name
udp        0      0 *:8888            *:*                     3321/QtCreator_UDP</screen>

  <para>Dans l'exemple ci-dessus, le numéro de port <literal>8888</literal>
  apparaît dans la colonne <option>Adresse locale</option> et processus numéro
  <literal>3321</literal> correspond bien au programme
  <literal>QtCreator_UDP_receiver</literal> dans la colonne <option>PID/Program
  name</option>.</para>
  </sect2>

  <sect2 xml:id='socket-qt.context.library'>
    <title>Bibliothèques utilisées</title>

  <para>Les bibliothèques standards du Langage C utilisées par le programme
  <emphasis>client</emphasis> sont présentées dans le document &url.socket-c;.
  On ne s'intéresse ici qu'à l'utilisation de la «brique» réseau des
  bibliothèques Qt.</para>

  <mediaobject xml:id='socket-qt.context.library-calls'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/qt-udp-socket-receiver.png' width='9cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/qt-udp-socket-receiver.png' width='480px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Bibliothèques Qt et sockets</phrase>
    </textobject>
  </mediaobject>

  <variablelist>
    <varlistentry xml:id='socket-qt.context.library.bind'>
      <term><systemitem class='library'>bind</systemitem></term>
      <listitem>
      <para>Cette méthode de la classe <systemitem
      class='library'>QUdpSocket</systemitem> assure la liaison d'un socket
      avec les adresses et le numéro de port spécifiés.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-qt.context.library.waitForReadyRead'>
      <term><systemitem class='library'>waitForReadyRead</systemitem></term>
      <listitem>
      <para>C'est une fonction bloquante qui attend que de nouvelles données
      soient disponibles en lecture et que le signal <systemitem
      class='library'>readyRead()</systemitem> ait été émis. Le blocage expire
      après <systemitem class='library'>msecs</systemitem> millisecondes. La
      valeur par défaut est 30000 millisecondes.</para>

      <para>La fonction retourne la valeur booléenne vrai si le signal
      <systemitem class='library'>readyRead()</systemitem> est émis.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-qt.context.library.readDatagram'>
      <term><systemitem class='library'>readDatagram</systemitem></term>
      <listitem>
      <para>Cette fonction assure la réception d'un datagramme de taille
      inférieure à <systemitem class='library'>maxSize</systemitem> octets et
      le stocke dans <systemitem class='library'>data</systemitem>. L'adresse
      et le numéro de port de l'émetteur sont stockées dans les pointeurs
      <systemitem class='library'>*address</systemitem> et <systemitem
      class='library'>*port</systemitem> (à moins que les pointeurs aient une
      valeur nulle).</para>

      <para>Si <systemitem class='library'>maxSize</systemitem> est trop petit,
      le reste du datagramme est perdu. Pour éviter les pertes de données, on
      fait appel à <systemitem
      class='library'>pendingDatagramSize()</systemitem> pour déterminer la
      taille du datagramme en attente avant d'essayer de le lire. Si
      <systemitem class='library'>maxSize</systemitem> vaut 0, le datagramme
      sera éliminé.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-qt.context.library.writeDatagram'>
      <term><systemitem class='library'>writeDatagram</systemitem></term>
      <listitem>
      <para>Cette fonction assure l'émission d'un datagramme de taille
      <systemitem class='library'>size</systemitem> à destination de l'adresse
      <systemitem class='library'>address</systemitem> et du port <systemitem
      class='library'>port</systemitem>. Elle renvoie le nombre d'octets émis
      avec succès ou -1 en cas d'erreur.</para>

      <para>Les datagrammes sont toujours écrits en un bloc. La taille maximum
      d'un datagramme dépend beaucoup du système utilisé. Elle peut atteindre
      8192 octets. Si le datagremme est trop grand, la fonction renvoie -1 et
      la fonction <systemitem class='library'>error()</systemitem> renvoie
      <systemitem class='library'>DatagramTooLargeError</systemitem>. Il est
      déconseillé d'émettre des datagrammes de plus de 512 octets est en
      général. Même s'ils sont émis avec succès, ils seront probablement
      fragmentés au niveau de la couche <acronym>IP</acronym> avant d'arriver à
      leur destination finale.</para>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.udp.server'>
  <title>Programme serveur UDP en mode console</title>

  <para>Avec l'environnement intégré de développement
  <application>QtCreator</application>, il est possible de créer une
  application en mode console.</para>

  <para>À partir de l'écran d'accueil, il faut créer un nouveau projet et
  choisir <guimenuitem>Application Qt4 en console</guimenuitem> dans la
  catégorie <guimenuitem>Autre Projet</guimenuitem>.</para>

  <para>L'intérêt de cette étape est de produire un fichier source unique de
  taille réduite dans lequel on trouve l'ensemble des appels de bibliothèques
  Qt.</para>

  <sect2 xml:id='socket-qt.udp.server.socket'>
    <title>Utilisation des sockets avec le serveur UDP</title>

  <para>Avec les bibliothèques Qt, on retrouve les éléments classiques de
  représentation des communications réseau.</para>

<programlisting width='80'>
QUdpSocket listenSocket;
QByteArray datagram;
QHostAddress senderAddress;
quint16 senderPort;
</programlisting>

  <variablelist>
    <varlistentry>
    <term>listenSocket</term>
    <listitem>
    <para>Objet de la classe <systemitem
    class='library'>QUdpSocket</systemitem> constituant le canal de
    communication entre le sous-système réseau du noyau du système
    d'exploitation et l'application.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>datagram</term>
    <listitem>
    <para>Objet de la classe <systemitem
    class='library'>QByteArray</systemitem> contenant les données vues de la
    couche application de la modélisation réseau.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>senderAddress</term>
    <listitem>
    <para>Objet de la classe <systemitem
    class='library'>QHostAddress</systemitem> contenant la représentation de
    l'adresse de l'hôte qui a émis le datagramme reçu par le serveur.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>senderPort</term>
    <listitem>
    <para>Entier en format court contenant le numéro de port utilisé par l'hôte
    qui a émis le datagramme reçu par le serveur.</para>
    </listitem>
    </varlistentry>
  </variablelist>

<programlisting width='80'>&lt;snipped/>
if (listenSocket.bind(QHostAddress::Any<co xml:id='addr_any'/>, 8888<co xml:id='portnumber'/>) &lt; 0) {
  qDebug("Impossible de créer le socket en écoute");
  go_on_like_this<co xml:id='go_on'/> = false;
  }
else
  go_on_like_this = true;</programlisting>

  <calloutlist>
    <callout arearefs='addr_any'>
    <para><option>QHostAddress::Any</option> spécifie que le programme est en
    écoute sur toutes les adresses <acronym>IP</acronym> de l'hôte.</para>
    </callout>
    <callout arearefs='portnumber'>
    <para>L'application est en écoute sur le port numéro <option>8888</option>
    uniquement.</para>
    </callout>
    <callout arearefs='go_on'>
    <para>Le booléen <option>go_on_like_this</option> est un indicateur d'état
    sur la poursuite de l'exécution de l'application. Dès qu'il passe la valeur
    <option>false</option>, le programme s'interrompt.</para>
    </callout>
  </calloutlist>

  <para>Une fois la liaison en place, le programme attend les datagrammes
  provenant du client.</para>

<programlisting width='80'>&lt;snipped/>
if (listenSocket.waitForReadyRead(100))<co xml:id='wait'/> {
  if (listenSocket.hasPendingDatagrams()<co xml:id='pending'/>) {
    datagram.resize(listenSocket.pendingDatagramSize());<co xml:id='resize'/>
    listenSocket.readDatagram(datagram.data(), datagram.size(), &amp;senderAddress, &amp;senderPort);
    msg = datagram.data();<co xml:id='store'/></programlisting>

  <calloutlist>
    <callout arearefs='wait'>
    <para>La méthode <function>waitForReadyRead(100)</function> bloque
    l'exécution du programme pendant 100ms, le temps de détecter un évènement
    de réception de données sur le <wordasword>socket</wordasword> en
    écoute.</para>
    </callout>
    <callout arearefs='pending'>
    <para>Si un datagramme est en attente, on procède à sa lecture.</para>
    </callout>
    <callout arearefs='resize'>
    <para>On redimensionne le tableau des données en fonction de la taille du
    datagramme reçu.</para>
    </callout>
    <callout arearefs='store'>
    <para>On stocke les données du datagramme dans la chaîne de caractères
    <option>msg</option>.</para>
    </callout>
  </calloutlist>

  <para>Enfin, l'émissions de datagramme du serveur vers le client utilise la
  fonction <function>writeDatagram</function> avec un jeu de paramètres
  identique à l'opération de lecture.</para>
  </sect2>

  <sect2 xml:id='socket-qt.udp.server.source'>
    <title>Code source complet</title>

<programlisting width='80'><xi:include href='qtcreator/nogui-udp-receiver/main.cpp'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.refdocs'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='socket-qt.refdocs.modelisation'>
      <term><citetitle>Modélisations réseau</citetitle></term>
      <listitem>
	<para>&url.modelisations; : présentation et comparaison des
	modélisations <acronym>OSI</acronym> et Internet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.refdocs.adressage.ipv4'>
      <term><citetitle>Adressage IPv4</citetitle></term>
      <listitem>
	<para>&url.adressage.ipv4; : support complet sur l'adressage du
	protocole de couche réseau de l'Internet
	(<acronym>IP</acronym>).</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.refdocs.config.interface.lan'>
      <term><citetitle>Configuration d'une interface réseau</citetitle></term>
      <listitem>
        <para>&url.config.interface.lan; : support sur la configuration des
	interfaces réseau. Il permet notamment de relever les adresses
	<acronym>IP</acronym> des hôtes en communication.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>
</article>
