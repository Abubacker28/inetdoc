<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

]>

<article xml:id='socket-qt' xml:lang='fr'>

<info>
  <title>Initiation au développement Qt sur les sockets</title>

  &author;
  <abstract>
    <para>Ce support est la suite de l'initiation au développement en Langage C
    sur les sockets. L'objectif est à nouveau le même ; utiliser un code
    minimaliste accessible aux débutants. Les bibliothèques Qt présentent un
    grand intérêt lorsque l'on souhaite produire du code indépendant du système
    d'exploitation sous-jacent. On aborde aussi la programmation orientée objet
    avec ces bibliothèques.</para>
  </abstract>
  <keywordset>
    <keyword>GNU</keyword>
    <keyword>Linux</keyword>
    <keyword>inetdoc</keyword>
    <keyword>socket</keyword>
    <keyword>udp</keyword>
    <keyword>tcp</keyword>
    <keyword>client</keyword>
    <keyword>serveur</keyword>
    <keyword>qt</keyword>
    <keyword>qtcreator</keyword>
  </keywordset>
</info>

<sect1 xml:id='socket-qt.legal.meta'>
  &legal;

  <sect2 xml:id='socket-qt.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="http://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='socket-qt.context'>
  <title>Contexte de développement</title>

  <para>Comme ce support est la suite de celui sur le Langage C, on reprend le
  même découpage en deux programmes distincts : un serveur et un client. À la
  différence du support précédent, on ne présente pas le code des deux
  programmes. Dans le but de limiter le volume du document, on introduit
  uniquement le code de la partie serveur qui reçoit le message, le traite et
  le réexpédie au client. On peut très bien réutiliser le programme client déjà
  développé en Langage C : &url.socket-c.udp-client;</para>

  <para>Le principe d'illustration des communications réseau reste le même :
  l'échange de chaînes de caractères. Le <emphasis>client</emphasis> émet un
  message que le <emphasis>serveur</emphasis> traite et retransmet vers le
  <emphasis>client</emphasis>. Le traitement est toujours aussi minimaliste ;
  le <emphasis>serveur</emphasis> convertit la chaîne de caractères en
  majuscules.</para>

  <sect2 xml:id='socket-qt.context.archi'>
    <title>Bibliothèques Qt</title>

  <para>Le diagramme ci-dessous présente l'architecture des bibliothèques Qt.
  Il met en évidence l'indépendance entre les développements et les systèmes
  d'exploitation cibles.</para>

  <mediaobject xml:id='socket-qt-arch'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/qt-architecture.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/qt-architecture.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Architecture Qt - source qt.nokia.com</phrase>
    </textobject>
  </mediaobject>

  <para>Dans notre contexte, on utilise le Langage C++ et l'environnement de
  développement intégré <citetitle>Qt Creator</citetitle>. Cet environnement de
  développement intègre les bibliothèques Qt réseau dont nous avons
  besoin.</para>

  <para>On se propose de développer le programme serveur en deux temps.</para>

  <itemizedlist>
    <listitem>
    <para>Une version sans graphisme mettant en évidence les appels de
    bibliothèques propres à l'utilisation des
    <wordasword>sockets</wordasword>.</para>
    </listitem>
    <listitem>
    <para>Une version avec une fenêtre graphique dans laquelle on affiche les
    messages reçus depuis un programme client ainsi que l'adresse
    <acronym>IP</acronym> et le numéro de port utilisés par ce programme
    client.</para> 
    </listitem>
  </itemizedlist>
  </sect2>

  <sect2 xml:id='socket-qt.context.run'>
    <title>Instructions d'exécution</title>

  <para>On exécute le programme <emphasis>client</emphasis> déjà développé en
  Langage C dans un <wordasword>Shell</wordasword> alors que le programme
  <emphasis>serveur</emphasis> est géré directement par l'environnement
  <citetitle>Qt Creator</citetitle>. On peut exécuter ces deux programmes sur
  le même hôte en utilisant l'interface de boucle locale pour les
  communications réseau.</para>

  <variablelist>
    <varlistentry xml:id='socket-qt.context.run-server'>
      <term>Le programme serveur</term>
      <term>nogui-udp-receiver</term>
      <listitem>

  <mediaobject xml:id='socket-qt.context.run-server-qtcreator'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/qt-creator-nogui-udp-receiver.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/qt-creator-nogui-udp-receiver.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Qt Creator - exécution du programme serveur</phrase>
    </textobject>
  </mediaobject>

    <note>
      <para>Déplacer le pointeur de la souris sur l'image, clicker sur le
      bouton droit et lancer «Afficher l'image» pour lire les messages.</para>
    </note>

      <para>C'est dans la partie inférieure droite de la copie d'écran que l'on
      retrouve en rouge les messages échangés entre les programmes
      <emphasis>client</emphasis> et <emphasis>serveur</emphasis>. Le code
      utilisé ici correspond à la version sans graphisme du programme
      <emphasis>serveur</emphasis>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.context.run-client'>
      <term>Le programme client</term>
      <term>udp-client.o</term>
      <listitem>
<screen width='80'><prompt>$</prompt> ./udp-client.o
Entrez le nom du serveur ou son adresse IP : 
127.0.0.1                  
Entrez le numéro de port du serveur : 
8888

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
        texte de test avec tabulation et espaces
Message traité : TEXTE DE TEST AVEC TABULATION ET ESPACES
Saisie du message : 
_exit_
Message traité : _EXIT_
Saisie du message : 
serveur arrêté
** Le serveur n'a répondu dans la seconde.
Saisie du message : 
.</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>Lorsque le programme <emphasis>serveur</emphasis> est en cours
  d'exécution, il est possible de visualiser la correspondance entre le
  processus en cours d'exécution et le numéro de port en écoute à l'aide de la
  commande <command>netstat</command>.</para>

<screen width='80'><prompt>$</prompt> netstat -aup | grep -e Proto -e 8888
(Tous les processus ne peuvent être identifiés, les infos sur les processus
non possédés ne seront pas affichées, vous devez être root pour les voir toutes.)
Proto Recv-Q Send-Q Adresse locale    Adresse distante  Etat  PID/Program name
udp        0      0 *:8888            *:*                     3321/QtCreator_UDP</screen>

  <para>Dans l'exemple ci-dessus, le numéro de port <literal>8888</literal>
  apparaît dans la colonne <option>Adresse locale</option> et processus numéro
  <literal>3321</literal> correspond bien au programme
  <literal>QtCreator_UDP_receiver</literal> dans la colonne <option>PID/Program
  name</option>.</para>
  </sect2>

  <sect2 xml:id='socket-qt.context.library'>
    <title>Bibliothèques utilisées</title>

  <para>Les bibliothèques standards du Langage C utilisées par le programme
  <emphasis>client</emphasis> sont présentées dans le document &url.socket-c;.
  On ne s'intéresse ici qu'à l'utilisation de la «brique» réseau des
  bibliothèques Qt.</para>

  <variablelist>
    <varlistentry xml:id='socket-qt.context.library.libc6.netdb'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netdb.h</systemitem></term>
      <listitem>
      <para>Opérations sur les bases de données réseau. Ici, c'est la fonction
      <function>gethostbyname()</function> qui est utilisée. Elle renvoie une
      structure de type <parameter>hostent</parameter> pour l'hôte
      <parameter>name</parameter>. La chaîne <parameter>name</parameter> est
      soit un nom d'hôte, soit une adresse <acronym>IPv4</acronym>, soit une
      adresse <acronym>IPv6</acronym>. Pour obtenir plus d'informations, il
      faut consulter les pages de manuels : <userinput>man
      gethostbyname</userinput>.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-qt.context.library.libc6.in'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netinet/in.h</systemitem></term>
      <listitem>
      <para>Famille du protocole Internet. Ici, plusieurs fonctions sont
      utilisées à partir du paramètre de description de socket
      <parameter>sockaddr_in</parameter>. Les quatre fonctions importantes
      traitent de la conversion des nombres représentés suivant le format hôte
      (octet le moins significatif en premier sur processeur Intel x86) ou
      suivant le format défini dans les en-têtes réseau (octet le plus
      significatif en premier). Ici le format hôte fait référence à
      l'architecture du processeur utilisé. Cette architecture est dite
      «petit-boutiste» pour les processeurs de marque
      <trademark>Intel</trademark> majoritairement utilisés dans les
      ordinateurs de type <acronym>PC</acronym>. À l'inverse, le format défini
      dans les en-têtes réseau est dit «gros-boutiste». Cette définition
      appelée <wordasword>Network Byte Order</wordasword> provient à la fois du
      protocole <acronym>IP</acronym> et de la couche liaison du modèle
      <acronym>OSI</acronym>.</para>
      <itemizedlist>
        <listitem>
	<para><function>htonl()</function> et
	<function>htons()</function> : conversion d'un entier long et d'un
	entier court depuis la représentation hôte (octet le moins significatif
	en premier ou <wordasword>Least Significant Byte First</wordasword>)
	vers la représentation réseau standard (octet le plus significatif en
	premier ou <wordasword>Most Significant Byte
	First</wordasword>).</para>
	</listitem>
	<listitem>
	<para><function>ntohl()</function> et
	<function>ntohs()</function> : fonctions opposées aux précédentes.
	Conversion de la représentation réseau vers la représentation
	hôte.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-qt.context.library.libc6.iostream'>
      <term><systemitem class='library'>libstdc++6-dev</systemitem></term>
      <term><systemitem>stdio.h</systemitem></term>
      <listitem>
      <para>Opérations sur les flux d'entrées/sorties de base tels que l'écran
      et le clavier. Ici, toutes les opérations de saisie de nom d'hôte,
      d'adresse <acronym>IP</acronym>, de numéro de port ou de texte sont
      gérées à l'aide des fonctions usuelles du langage C.</para>

      <para>Les fonctions d'affichage sans formatage <function>puts</function>
      et <function>fputs</function> ainsi que la fonction d'affichage avec
      formatage <function>printf</function> sont utilisées de façon
      classique.</para>

      <para>En revanche, la saisie des chaînes de caractères à l'aide de la
      fonction <function>scanf</function> est plus singulière. Comme le but des
      communications réseau évaluées ici est d'échanger des chaînes de
      caractères, il est nécessaire de transmettre ou recevoir des suites de
      caractères comprenant aussi bien des espaces que des tabulations.</para>

      <para>La syntaxe usuelle de saisie d'une chaîne de caractère est :</para>

<screen width='80'>scanf("%s", msg);</screen>

      <para>Si on se contente de cette syntaxe par défaut, la chaîne saisie est
      transmise par le programme <emphasis>client</emphasis> mot par mot. En
      conséquence, le traitement par le programme <emphasis>serveur</emphasis>
      est aussi effectué mot par mot.</para>

      <para>Pour transmettre une chaîne complète, on utilise une syntaxe du
      type suivant :</para>

<screen width='80'>scanf(" %[^\n]%*c", msg);</screen>

      <para>Le caractère espace situé entre les guillemets de gauche et le
      signe pourcentage a pour but d'éliminer les caractères <literal>'
      '</literal>, <literal>'\t'</literal> et <literal>'\n'</literal> qui
      subsisteraient dans la mémoire tampon du flux d'entrée standard
      <literal>stdin</literal> avant la saisie de nouveaux caractères.</para> 

      <para>La syntaxe <literal>[^\n]</literal> précise que tous les caractères
      différents du saut de ligne sont admis dans la saisie. On évite ainsi que
      les caractères <literal>' '</literal> et <literal>'\t'</literal> soient
      considérés comme délimiteurs.</para>

      <para>L'ajout de <literal>%*c</literal> permet d'éliminer le
      délimiteur <literal>'\n'</literal> et tout caractère situé après dans la
      mémoire tampon du flux d'entrée standard.</para>

      <para>Enfin, pour éviter tout débordement de la mémoire tampon du même
      flux d'entrée standard, on limite le nombre maximum des caractères saisis
      à la quantité de mémoire réservée pour stocker la chaîne de caractères.
      La «constante» <literal>MAX_MSG</literal> définie via une directive de
      préprocesseur est introduite dans la syntaxe de formatage de la saisie.
      Pour cette manipulation, on fait appel à une fonction macro qui renvoie
      la valeur de <literal>MAX_MSG</literal> comme nombre maximum de
      caractères à saisir.</para>

      <para>On obtient donc finalement le formatage de la saisie d'une chaîne
      de caractères suivant :</para>

<screen width='80'>scanf(" %"xstr(MAX_MSG)"[^\n]%*c", msg);</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>D'une manière générale, toutes les fonctions sont documentées à l'aide
  des pages de manuels Unix classiques. Soit on entre directement à la console
  une commande du type : <userinput>man inet_ntoa</userinput>, soit on
  utilise l'aide du gestionnaire graphique pour accéder aux mêmes informations
  en saisissant une <acronym>URL</acronym> du type suivant à partir du
  gestionnaire de fichiers : <userinput>man:/inet_ntoa</userinput>.</para>
  </sect2>

  <sect2 xml:id='socket-qt.context.protocol'>
    <title>Choix du premier protocole de transport étudié</title>

  <para>Au dessus du protocole de couche réseau <acronym>IP</acronym>, on doit
  choisir entre deux protocoles de couche transport :
  <acronym>TCP</acronym> ou <acronym>UDP</acronym>.</para>
  
  <para>Dans l'ordre chronologique, le protocole <acronym>TCP</acronym> est le
  premier protocole à avoir été développé. Il «porte la moitié» de la
  philosophie du modèle Internet. Cette philosophie veut que la couche
  transport soit le lieu de la fiabilisation des communications. Ce protocole
  fonctionne donc en mode connecté et contient tout les outils nécessaires à
  l'établissement, au maintien et à la libération de connexion. De plus, des
  numéros de séquences garantissent l'intégrité de la transmission et le
  fenêtrage de ces numéros de séquences assure un contrôle de flux. Tout ces
  mécanismes ne sont pas évidents à appréhender pour un public débutant.</para>

  <para>Le protocole <acronym>UDP</acronym> a été développé après
  <acronym>TCP</acronym>. La philosophie de ce mode de transport suppose que le
  réseau de communication est intrinsèquement fiable et qu'il n'est pas
  nécessaire de garantir l'intégrité des transmissions et de contrôler les
  flux. On dit que le protocole <acronym>UDP</acronym> n'est pas orienté
  connexion ; ce qui a pour conséquence d'alléger considérablement les
  mécanismes de transport.</para>

  <para>L'objectif du présent document étant d'initier à l'utilisation des
  sockets, on s'appuie dans un premier temps sur le protocole de transport le
  plus simple : <acronym>UDP</acronym>. Les programmes «client» et
  «serveur» sont repris dans un second temps en utilisant le protocole
  <acronym>TCP</acronym>. En termes de développement, les différences de mise
  en œuvre des sockets sont minimes. C'est à l'analyse réseau que la différence
  se fait sachant que les mécanismes de fonctionnement des deux protocoles sont
  très différents.</para>

  <para>Pour plus d'informations, consulter le support <xref
  linkend='socket-qt.refdocs.modelisation'/>.</para>
  </sect2>

  <sect2 xml:id='socket-qt.context.udp_schema'>
    <title>Sockets &amp; protocole de transport UDP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  client et côté serveur pour la mise en œuvre des sockets avec le protocole de
  transport <acronym>UDP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Serveur : <xref linkend='socket-qt.udp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-qt-udp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole UDP</phrase>
    </textobject>
  </mediaobject>
  </sect2>

  <sect2 xml:id='socket-qt.context.tcp_schema'>
    <title>Sockets &amp; protocole de transport TCP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  client et côté serveur pour la mise en œuvre des sockets avec le protocole de
  transport <acronym>TCP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Serveur : <xref linkend='socket-qt.tcp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-qt-tcp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole TCP</phrase>
    </textobject>
  </mediaobject>
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.udp.server'>
  <title>Programme serveur UDP</title>

  <sect2 xml:id='socket-qt.udp.server.socket'>
    <title>Utilisation des sockets avec le serveur UDP</title>

  <para>Au niveau du serveur, l'objectif est aussi
  <emphasis>d'ouvrir</emphasis> un nouveau socket ; ce qui revient aussi à
  ouvrir un canal de communication réseau avec la fonction
  <function>socket</function>.</para>

<programlisting width='80'>
  int listenSocket;

&lt;snipped/>
listenSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
if (listenSocket &lt; 0) {
  fputs("Impossible de créer le socket en écoute", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>Cette étape ne présentant aucune différence avec le niveau client, on
  relie le numéro de socket avec le numéro de port choisi.</para>

<programlisting width='80'>
  int listenSocket;
  struct sockaddr_in serverAddress;

&lt;snipped/>
serverAddress.sin_family = PF_INET;
serverAddress.sin_addr.s_addr = htonl(INADDR_ANY)<co xml:id='inaddr_any'/>;
serverAddress.sin_port = htons(listenPort);

if (bind(listenSocket<co xml:id='bind_listenSocket'/>,
         (struct sockaddr *) &amp;serverAddress,
         sizeof(serverAddress)<co xml:id='bind_Address'/>) &lt; 0) {
  fputs("Impossible de lier le socket en écoute", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='inaddr_any'>
    <para><option>INADDR_ANY</option> spécifie que le programme est en écoute
    sur toutes les adresses <acronym>IP</acronym> sources.</para>
    </callout>
    <callout arearefs='bind_listenSocket'>
    <para><option>listenSocket</option> contient le résultat de l'appel de
    la fonction <function>socket</function> ; le numéro du canal de
    communication entre le programme et la pile des protocoles réseau.</para>
    </callout>
    <callout arearefs='bind_Address'>
    <para><option>(struct sockaddr *) &amp;serverAddress</option> et
    <option>sizeof(serverAddress)</option> correspondent à la structure de
    désignation de l'adresse <acronym>IP</acronym> et du numéro de port du
    serveur puis à la taille de cette structure.</para>
    </callout>
  </calloutlist>

  <para>Une fois la liaison en place, le programme attend les datagrammes
  provenant du client.</para>

<programlisting width='80'>  int listenSocket;
  struct sockaddr_in clientAddress;
  char line[(MAX_MSG+1)];

&lt;snipped/>
listen(listenSocket, 5)<co xml:id='listen'/>;

&lt;snipped/>
if (recvfrom(listenSocket, msg, MAX_MSG<co xml:id='recvfrom_line'/>, 0,
             (struct sockaddr *) &amp;clientAddress,
             &amp;clientAddressLength) &lt; 0) {
  fputs("Problème de réception du messsage", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='listen'>
    <para>La fonction <function>listen</function> «active» l'utilisation du
    canal de communication initié avec la fonction
    <function>socket</function>. Le second paramètre <option>5</option> définit
    le nombre maximal de demandes de «connexions» en attente.</para>
    </callout>
    <callout arearefs='recvfrom_line'>
    <para>Les paramètres <option>msg</option> et <option>MAX_MSG</option>
    correspondent au datagramme et à sa longueur.</para>
    </callout>
  </calloutlist>

  <para>Enfin, les émissions de datagramme du serveur vers le client utilisent
  exactement les mêmes appels à la fonction <function>sendto</function> que les
  émissions du client vers le serveur.</para>
  </sect2>

  <sect2 xml:id='socket-qt.udp.server.source'>
    <title>Code source complet</title>

  <para>Code du programme <systemitem>udp-server.c</systemitem> :</para>

<!--<programlisting width='80'><xi:include href='files/udp-server.c'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>-->
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.tcp.server'>
  <title>Programme serveur TCP</title>

  <sect2 xml:id='socket-qt.tcp.server.socket'>
    <title>Utilisation des sockets avec le serveur TCP</title>

  <para>Comme dans le cas du programme client, le fait que le protocole
  <acronym>TCP</acronym> soit un  <emphasis>service orienté
  connexion</emphasis> entraîne un changement important dans le code source du
  programme serveur précédent. Le contrôle d'erreur est directement intégré
  dans la couche transport.</para>

  <para>Si le client fait appel à la fonction <function>connect</function> pour
  demander l'établissement d'une connexion, le serveur fait appel à la fonction
  <function>accept</function> pour recevoir les nouvelles demandes de
  connexion.</para>

<programlisting width='80'>  int socketDescriptor;
  struct sockaddr_in serverAddress;

&lt;snipped/>
connectSocket = accept(listenSocket,
                       (struct sockaddr *) &amp;clientAddress,
		       &amp;clientAddressLength);

if (connectSocket &lt; 0) {
  fputs("Impossible d'accepter une connexion", stderr);
  close(listenSocket);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>En cas d'échec de l'ouverture du socket de réception des demandes
  d'établissement de connexion, on abandonne le traitement.</para>
  </sect2>

  <sect2 xml:id='socket-qt.tcp.server.source'>
    <title>Patch code source</title>

  <para>Patch du programme <systemitem>tcp-server.c</systemitem> :</para>

<!--<programlisting width='80'><xi:include href='files/tcp-server.c.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>-->
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.capture'>
  <title>Analyse réseau avec Wireshark</title>

  <para>L'analyse réseau présente un grand intérêt dans la validation des
  développements. Elle permet de contrôler le bon fonctionnement des
  communications suivant les jeux de protocoles utilisés. Ici, on peut
  différencier le fonctionnement des deux protocoles de la couche transport en
  analysant les échanges entre les deux programmes <emphasis>client</emphasis>
  et <emphasis>serveur</emphasis>.</para>

  <para>L'utilisation de l'analyseur <application>wireshark</application> est
  présentée dans le support &url.intro.analyse;.</para>

  <para>Les analyses présentées ci-après ont été réalisées dans les conditions
  suivantes :</para>

  <itemizedlist>
    <listitem>
    <para>Le programme <emphasis>serveur</emphasis> est exécuté sur l'hôte
    ayant l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.200.0.1</systemitem>. Ce programme est toujours en
    écoute sur le port <literal>4000</literal>.</para>
    </listitem>
    <listitem>
    <para>Le programme <emphasis>client</emphasis> est exécuté sur l'hôte ayant
    l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.200.0.30</systemitem>.</para>
    </listitem>
  </itemizedlist>

  <para>Voici deux captures réseau d'échange de datagramme entre un client avec
  l'adresse <acronym>IP</acronym> <systemitem
  class='ipaddress'>192.168.1.1</systemitem> et un serveur avec l'adresse
  <acronym>IP</acronym> <systemitem
  class='ipaddress'>192.168.1.101</systemitem>. Le serveur est en
  <emphasis>écoute</emphasis> sur le port <systemitem>4000</systemitem>.</para>

  <sect2 xml:id='socket-qt.capture-udp'>
    <title>Analyse avec le protocole UDP</title>

  <para>Avant de passer à l'analyse, voici les copies d'écran de l'exécution
  des programmes.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen width='80'><prompt>$</prompt> ./udp-server.o 
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) : 
4000
Attente de requête sur le port 4000
>>  depuis 192.200.0.30:45686
  Message reçu : message de test UDP
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen width='80'><prompt>$</prompt> ./udp-client.o 
Entrez le nom du serveur ou son adresse IP : 
192.200.0.1
Entrez le numéro de port du serveur : 
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse MAX_MSG caractères,
seuls les MAX_MSG premiers caractères seront utilisés.

Saisie du message : 
        message de test UDP
Message traité : MESSAGE DE TEST UDP
Saisie du message : 
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  énoncés auparavant.</para>

  <itemizedlist>
    <listitem>
    <para>Chaîne de caractères traitée dans la partie données de la couche
    application.</para>
    </listitem>
    <listitem>
    <para>Numéros de ports utilisés dans les en-têtes de la couche transport.</para>
    </listitem>
    <listitem>
    <para>Adresses <acronym>IP</acronym> utilisées dans les en-têtes de la
    couche réseau.</para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='wireshark-udp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole UDP</phrase>
    </textobject>
  </mediaobject>

  <para>Enfin, le fait que la capture se limite à deux échanges illustre la
  principale caractéristique du protocole <acronym>UDP</acronym> : un service
  de datagramme non orienté connexion qui suppose un réseau sous-jacent fiable
  et sans erreur.</para> 
  </sect2>

  <sect2 xml:id='socket-qt.capture-tcp'>
    <title>Analyse avec le protocole TCP</title>

  <para>Comme dans le cas précédent, voici les copies d'écran de l'exécution
  des programmes avant de passer à l'analyse réseau.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen width='80'><prompt>$</prompt> ./tcp-server.o 
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) : 
4000
Attente de connexion TCP sur le port 4000
>>  connecté à 192.200.0.30:59490
  --  message   de test TCP
  --  nouveau message avant clôture de la connexion
Attente de connexion TCP sur le port 4000
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen width='80'><prompt>$</prompt> ./tcp-client.o 
Entrez le nom du serveur ou son adresse IP : 
192.200.0.1
Entrez le numéro de port du serveur : 
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse MAX_MSG caractères,
seuls les MAX_MSG premiers caractères seront utilisés.

Saisie du message : 
message de test TCP
Message traité : MESSAGE        DE TEST TCP
Saisie du message : 
nouveau message avant clôture de la connexion
Message traité : NOUVEAU MESSAGE AVANT CLôTURE DE LA CONNEXION
Saisie du message : 
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  déjà connus : chaîne de caractères traitée, numéros de port en couche
  transport et adresses <acronym>IP</acronym> en couche réseau.</para>

  <mediaobject xml:id='wireshark-tcp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole TCP</phrase>
    </textobject>
  </mediaobject>

  <para>Cette copie d'écran se distingue de la précédente, par le nombre de
  trames capturées alors que le traitement effectué est quasiment le même. La
  capture réseau fait apparaître les phases d'établissement, de maintien et de
  libération d'une connexion. On illustre ainsi toutes les fonctions de
  fiabilisation apportées par le protocole <acronym>TCP</acronym>.</para>
  
  <para>À partir de ces quelques trames, on peut reprendre l'analyse de la
  poignée de main à trois voies, de l'évolution des numéros de séquence et de
  l'évolution de la fenêtre d'acquittement.</para>
  </sect2>
</sect1>

<sect1 xml:id='socket-qt.refdocs'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='socket-qt.refdocs.modelisation'>
      <term><citetitle>Modélisations réseau</citetitle></term>
      <listitem>
	<para>&url.modelisations; : présentation et comparaison des
	modélisations <acronym>OSI</acronym> et Internet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.refdocs.adressage.ipv4'>
      <term><citetitle>Adressage IPv4</citetitle></term>
      <listitem>
	<para>&url.adressage.ipv4; : support complet sur l'adressage du
	protocole de couche réseau de l'Internet
	(<acronym>IP</acronym>).</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-qt.refdocs.config.interface.lan'>
      <term><citetitle>Configuration d'une interface réseau</citetitle></term>
      <listitem>
        <para>&url.config.interface.lan; : support sur la configuration des
	interfaces réseau. Il permet notamment de relever les adresses
	<acronym>IP</acronym> des hôtes en communication.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>
</article>
