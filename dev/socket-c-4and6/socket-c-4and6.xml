<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.tutorial.archive
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://web.archive.org/web/20080703122104/http://sage.mc.yu.edu/kbeen/teaching/networking/resources/sockets.html">
   <citetitle>brief socket tutorial</citetitle></link>'>

<!ENTITY url.guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://beej.us/guide/bgnet/">
   <citetitle>Beej&#39;s Guide to Network Programming</citetitle></link>'>
]>

<article xml:id='socket-c-4and6' xml:lang='fr'>

<info>
  <title>Initiation au développement C sur les sockets IPv4 &amp; IPv6</title>

  &author;
  <abstract>
    <para>Ce support est le second volet sur l'initiation au développement
    réseau sur les <wordasword>sockets</wordasword> à partir du code le plus
    minimaliste. On utilise à nouveau les fonctions des bibliothèques standard
    du Langage C et on s'appuie sur les protocoles IPv4 &amp; IPv6 en couche
    réseau. Les exemples de code présentés ici sont dits <wordasword>dual
    stack</wordasword>. Ils fonctionnent indifféremment avec l'un et|ou l'autre
    des deux versions des protocoles de couche réseau.</para>
  </abstract>
  <keywordset>
    <keyword>Langage C</keyword>
    <keyword>dual stack</keyword>
    <keyword>ipv4</keyword>
    <keyword>ipv6</keyword>
    <keyword>socket</keyword>
    <keyword>udp</keyword>
    <keyword>tcp</keyword>
    <keyword>client</keyword>
    <keyword>serveur</keyword>
  </keywordset>
</info>

<sect1 xml:id='socket-c-4and6.legal.meta'>
  &legal;

  <sect2 xml:id='socket-c-4and6.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="http://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='socket-c-4and6.context'>
  <title>Contexte de développement</title>

  <para>Le parti pris de ce document est l'utilisation conjointe des deux
  protocoles de la couche réseau : <acronym>IPv4</acronym> et
  <acronym>IPv6</acronym>. Dans ce but, on commence par mettre en place une
  petite infrastructure de test comprenant trois hôtes ayant chacun un rôle
  défini. Les rôles dépendent de l'application reprise du premier document
  &url.socket-c;. Un hôte <emphasis>serveur</emphasis> ou
  <wordasword>listener</wordasword> reçoit les chaînes de caractères émises par
  les hôtes <emphasis>client</emphasis> ou <wordasword>talker</wordasword>. Le
  <emphasis>serveur</emphasis> convertit les chaînes de caractères en
  majuscules et les retransmet vers les <emphasis>client</emphasis>.</para>

  <mediaobject xml:id='socket-c-4and6-lab'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/dual-stack-lab.png' width='9cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/dual-stack-lab.png' width='480px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Infrastructure de test</phrase>
    </textobject>
  </mediaobject>

  <para>Voici le tableau des paramètres d'affection des rôles, de noms de
  domaine, d'adressage <acronym>IPv4</acronym> et
  <acronym>IPv6</acronym>.</para>

  <table xml:id='socket-c-4and6-lab-addressing' frame='all' pgwide='1'>
    <title>Paramètres des hôtes</title>
    <tgroup cols='4'>
    <colspec colnum='1' colwidth='1*'/>
    <colspec colnum='2' colwidth='1*'/>
    <colspec colnum='3' colwidth='1*'/>
    <colspec colnum='4' colwidth='1*'/>
    <thead>
      <row>
        <entry>Nom</entry>
	<entry>Rôle</entry>
	<entry>Adresse IPv4</entry>
	<entry>Adresse IPv6</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry><citetitle>cooper.fake.domain</citetitle></entry>
	<entry><emphasis>routeur</emphasis>, <emphasis>serveur DNS</emphasis></entry>
	<entry><systemitem class='ipaddress'>192.0.2.1/27</systemitem></entry>
	<entry><systemitem class='ipaddress'>2001:db8:feb2:10::1/64</systemitem></entry>
      </row>
      <row>
        <entry><citetitle>vm1.fake.domain</citetitle></entry>
	<entry><emphasis>serveur</emphasis>, <wordasword>listener</wordasword></entry>
	<entry><systemitem class='ipaddress'>192.0.2.11/27</systemitem></entry>
	<entry><systemitem class='ipaddress'>2001:db8:feb2:10::11/64</systemitem></entry>
      </row>
      <row>
        <entry><citetitle>vm2.fake.domain</citetitle></entry>
	<entry><emphasis>client</emphasis>, <wordasword>talker</wordasword></entry>
	<entry><systemitem class='ipaddress'>192.0.2.12/27</systemitem></entry>
	<entry><systemitem class='ipaddress'>2001:db8:feb2:10::12/64</systemitem></entry>
      </row>
      <row>
        <entry><citetitle>vm3.fake.domain</citetitle></entry>
	<entry><emphasis>client</emphasis>, <wordasword>talker</wordasword></entry>
	<entry><systemitem class='ipaddress'>192.0.2.13/27</systemitem></entry>
	<entry><systemitem class='ipaddress'>-</systemitem></entry>
      </row>
    </tbody>
    </tgroup>
  </table>

  <para>Du point de vue système, on reprend le modèle en trois couches :
  <wordasword>kernel</wordasword>, <wordasword>shell</wordasword> et
  <wordasword>application</wordasword>. Nos applications sont exécutées à
  partir du <wordasword>shell</wordasword> et font appel au sous-système réseau
  du noyau (<wordasword>kernel</wordasword>) via des appels systèmes utilisant
  les bibliothèques standard.</para>

  <para>Du point de vue modélisation réseau, les niveaux allant de la couche
  physique jusqu'à la couche transport sont intégrés dans le sous-système
  réseau du noyau et nos applications sont placées dans la couche éponyme. Le
  canal de communication entre la couche application et les niveaux inférieurs
  est appelé «prise» ou <wordasword>socket</wordasword>.</para>

  <mediaobject xml:id='socket-c-4and6-model'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/kernel-network-subsystem.png' width='9cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/kernel-network-subsystem.png' width='480px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Modélisation système &amp; réseau</phrase>
    </textobject>
  </mediaobject>

  <para>Relativement au premier document &url.socket-c;, les instructions de
  compilation et d'exécution des applications ne changent pas. Un exemple de
  <link linkend='socket-c-4and6.appendix-makefile'>Makefile</link> est donné en
  <link linkend='socket-c-4and6.appendix-makefile'>annexe</link>.</para>

  <para>L'utilisation du service de noms de domaine (<acronym>DNS</acronym>)
  est une nouveauté. L'utilisation conjointe des deux versions de protocole
  réseau suppose qu'à un même nom d'hôte on associe plusieurs adresses
  <acronym>IP</acronym>. Ainsi, les tests pourront se faire de façon
  transparente. La même application doit pouvoir s'exécuter sur un système qui
  ne supporte qu'une version de protocole ou sur un système qui supporte les
  deux versions. On parle alors de système <wordasword>single
  stack</wordasword> ou <wordasword>dual stack</wordasword>. Le service
  <acronym>DNS</acronym> est donc une solution pratique d'évaluation des
  différentes combinaisons. La configuration du service sort du cadre de ce
  document. Les fichiers de déclaration de la <link
  linkend='socket-c-4and6.appendix-zone'>zone
  <systemitem>fake.domain</systemitem></link> sont donnés en <link
  linkend='socket-c-4and6.appendix-zone'>annexe</link>.</para>

  <para>Côté bibliothèques standard, le remplacement de la fonction
  <function>gethostbyname()</function> par <function>getaddrinfo()</function>
  constitue le premier gros changement. Cette évolution dans l'utilisation des
  appels système justifie une section à part entière dans la description du
  code. Là encore, l'utilisation des protocoles <acronym>IPv4</acronym> et
  <acronym>IPv6</acronym> entraîne une modification des enregistrements
  utilisés pour décrire les attributs des adresses associées à un hôte ou une
  interface réseau.</para>
</sect1>

<sect1 xml:id='socket-c-4and6.getaddrinfo'>
  <title>Utilisation de getaddrinfo()</title>

  <para>L'objectif de cette section est de fournir un programme minimaliste qui
  affiche les adresses <acronym>IP</acronym> associées à un hôte ou à une
  interface réseau. Le code source de ce programme fait donc appel à la
  fonction <function>getaddrinfo()</function>. Cette fonction offre de
  nombreuses options mais son utilisation reste simple. Elle s'appuie sur
  l'enregistrement de type <parameter>addrinfo</parameter>. Ce type permet de
  constituer une liste chaînée des différentes adresses disponibles.</para>
 
<note>
  <para>Cette section suit la démarche proposée dans le livre &url.guide;.
  Relativement au code proposé dans cet excellent guide, les modifications
  apportées ici sont marginales. Elles ont cependant une incidence sur
  l'organisation du code des sections suivantes.</para>
</note>

  <para>Le programme <application>showip</application> est constitué d'un appel
  à la fonction <function>getaddrinfo()</function> suivi d'une boucle de
  parcours des enregistrements renseignés lors de l'appel. Cette boucle de
  parcours est reprise ensuite dans tous les autres programmes de ce
  document.</para>

  <bridgehead renderas='sect2'>Appel à getaddrinfo()</bridgehead>

<programlisting>
  struct addrinfo hints, *res, *p;<co xml:id='addrinfo'/>

&lt;snipped/>
  memset(&amp;hints, 0, sizeof hints);<co xml:id='hints'/>
  hints.ai_family = AF_UNSPEC; // IPv4 ou IPv6
  hints.ai_socktype = SOCK_STREAM; // Une seule famille de socket

  if ((status = <emphasis>getaddrinfo</emphasis>(argv[1]<co xml:id='argv'/>, NULL, &amp;hints, &amp;res<co xml:id='result'/>)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status)<co xml:id='strerror'/>);
    return 2;
  }</programlisting>

  <calloutlist>
    <callout arearefs='addrinfo'>
    <para>On utilise 3 variables de type <option>addrinfo</option>.
    L'enregistrement <option>hints</option> sert à positionner des options
    avant l'appel à <function>getaddrinfo()</function> et les deux pointeurs
    servent respectivement à adresser le premier résultat et à parcourir la
    liste des enregistrements contenant les informations sur les adresses
    <acronym>IP</acronym>.</para>
    </callout>
    <callout arearefs='hints'>
    <para>Les options choisies pour l'appel à
    <function>getaddrinfo()</function> permettent d'orienter les résultats.
    Ici, on souhaite obtenir les informations sur les adresses
    <acronym>IPv4</acronym> (et|ou) <acronym>IPv6</acronym>. De plus, on est
    obligé de choisir une famille de <wordasword>socket</wordasword> même si
    nous n'avons pas l'intention de poursuivre avec l'ouverture d'un
    <wordasword>socket</wordasword>.</para>
    </callout>
    <callout arearefs='argv'>
    <para>Les paramètres du programme <application>showip</application> sont
    passés directement en ligne de commande de façon classique ;
    <option>argv[1]</option> correspond à la chaîne de caractères décrivant
    l'hôte dont on souhaite obtenir la liste des adresses réseau.</para>
    </callout>
    <callout arearefs='result'>
    <para>Le pointeur <option>*res</option> indique l'adresse du premier
    enregistrement réponse au retour de l'appel à
    <function>getaddrinfo()</function>.</para>
    </callout>
    <callout arearefs='strerror'>
    <para>En cas d'erreur sur l'interprétation de la chaîne fournie dans
    <option>argv[1]</option>, la variable <option>status</option> reçoit une
    valeur interprétée par la fonction
    <function>gai_strerror()</function>.</para>
    </callout>
  </calloutlist>

  <bridgehead renderas='sect2'>Boucle de parcours des enregistrements</bridgehead>

<programlisting>
&lt;snipped/>

  printf("IP addresses for %s:\n\n", argv[1]);

  p = res;<co xml:id='first'/>
  while (p != NULL) {<co xml:id='last'/>

    // Identification de l'adresse courante

&lt;snipped/>

    // Adresse suivante
    p = p->ai_next;<co xml:id='next'/>
  }</programlisting>

  <calloutlist>
    <callout arearefs='first'>
    <para>Le pointeur <option>p</option> reçoit l'adresse du premier
    enregistrement suite à l'appel à la fonction
    <function>getaddrinfo()</function>.</para>
    </callout>
    <callout arearefs='last'>
    <para>Si cette adresse vaut <option>NULL</option>, il n'y a plus
    d'enregistrement d'adresse dans la liste et on sort de la boucle.</para>
    </callout>
    <callout arearefs='next'>
    <para>On fait pointer <option>p</option> sur l'enregistrement d'adresse
    suivant.</para>
    </callout>
  </calloutlist>

  <para>Cette technique de parcours des enregistrements de type
  <parameter>addrinfo</parameter> est reprise dans les sections suivantes pour
  définir les conditions d'ouverture des «prises» réseau ou
  <wordasword>sockets</wordasword>.</para>

  <bridgehead renderas='sect2'>Code source complet du programme showip.c</bridgehead>

  <programlisting><xi:include href='files/showip/showip.c'
  parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
</sect1>

<sect1 xml:id='socket-c-4and6.refdocs'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='socket-c-4and6.refdocs.tutorial'>
      <term><citetitle>A Brief Socket Tutorial</citetitle></term>
      <listitem>
	<para>&url.tutorial.archive; : support proposant des exemples de
	programmes de communication réseau basés sur les sockets. Le présent
	document est <emphasis>très fortement inspiré</emphasis> des exemples
	utilisant le protocole de transport<acronym>UDP</acronym>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.guide'>
      <term><citetitle>Beej's Guide to Network Programming</citetitle></term>
      <listitem>
	<para>&url.guide; : support très complet sur les sockets proposant
	de nombreux exemples de	programmes.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.modelisation'>
      <term><citetitle>Modélisations réseau</citetitle></term>
      <listitem>
	<para>&url.modelisations; : présentation et comparaison des
	modélisations <acronym>OSI</acronym> et Internet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.adressage.ipv4'>
      <term><citetitle>Adressage IPv4</citetitle></term>
      <listitem>
	<para>&url.adressage.ipv4; : support complet sur l'adressage du
	protocole de couche réseau de l'Internet
	(<acronym>IP</acronym>).</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.config.interface.lan'>
      <term><citetitle>Configuration d'une interface réseau</citetitle></term>
      <listitem>
        <para>&url.config.interface.lan; : support sur la configuration des
	interfaces réseau. Il permet notamment de relever les adresses
	<acronym>IP</acronym> des hôtes en communication.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>

<appendix xml:id='socket-c-4and6.appendix'>
  <title>Annexes</title>

  <section xml:id='socket-c-4and6.appendix-makefile'>
    <title>Instructions de compilation</title>

  <para>Exemple de <citetitle>Makefile</citetitle> permettant de compiler
  n'importe lequel des programmes étudiés dans ce document.</para>

<programlisting><xi:include href='files/showip/Makefile'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </section>

  <section xml:id='socket-c-4and6.appendix-zone'>
    <title>Zone DNS fake.domain</title>

  <para>La mise en œuvre du service de noms de domaine est décrite dans le
  support de travaux pratiques &url.sysadm-net.dns;. On donne ci-dessous les
  fichiers de configuration utilisés avec l'infrastructure de test. Dans ces
  fichiers, les noms d'hôtes sont associés à des adresses <acronym>IP</acronym>
  des deux versions.</para>

  <itemizedlist>
    <listitem>
    <para>Options globales du service : <filename>/etc/bind/named.conf.options</filename></para>

<programlisting><xi:include href='files/dns/named.conf.options'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
    </listitem>
    <listitem>
    <para>Déclaration des zones sur lesquelles le service a autorité : 
    <filename>/etc/bind/named.conf.local</filename></para>

<programlisting><xi:include href='files/dns/named.conf.local'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
    </listitem>
    <listitem>
    <para>Déclaration des enregistrements de la zone directe
    <systemitem>fake.domain</systemitem> :
    <filename>/var/cache/bind/fake.domain</filename></para>

<programlisting><xi:include href='files/dns/fake.domain'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
    </listitem>
    <listitem>
    <para>Déclaration des enregistrements de la zone inverse correspondant au
    réseau <systemitem class='ipaddress'>192.0.2.0/27</systemitem> :
    <filename>/var/cache/bind/2.0.192</filename></para>

<programlisting><xi:include href='files/dns/2.0.192'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
    </listitem>
    <listitem>
    <para>Déclaration des enregistrements de la zone inverse correspondant au
    réseau <systemitem class='ipaddress'>2001:db8:feb2:10/64</systemitem> :
    <filename>/var/cache/bind/10-feb2-db8-2001</filename></para>

<programlisting><xi:include href='files/dns/10-feb2-db8-2001'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
    </listitem>
  </itemizedlist>
  </section>
</appendix>
</article>
