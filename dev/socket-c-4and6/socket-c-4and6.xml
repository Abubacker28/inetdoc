<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
  "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [

<!ENTITY author		SYSTEM "author.xml">
<!ENTITY legal		SYSTEM "legal.xml">

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.tutorial.archive
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://web.archive.org/web/20080703122104/http://sage.mc.yu.edu/kbeen/teaching/networking/resources/sockets.html">
   <citetitle>brief socket tutorial</citetitle></link>'>

<!ENTITY url.guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://beej.us/guide/bgnet/">
   <citetitle>Beej&#39;s Guide to Network Programming</citetitle></link>'>
]>

<article xml:id='socket-c-4and6' xml:lang='fr'>

<info>
  <title>Initiation au développement C sur les sockets IPv4 &amp; IPv6</title>

  &author;
  <abstract>
    <para>Ce support est le second volet sur l'initiation au développement
    réseau sur les sockets à partir du code le plus minimaliste. On utilise à
    nouveau les fonctions des bibliothèques standard du Langage C et on
    s'appuie sur les protocoles IPv4 &amp; IPv6 en couche réseau. Les exemples
    de code présentés ici sont dits <wordasword>dual stack</wordasword>. Ils
    fonctionnent indifféremment avec l'un et|ou l'autre des deux versions des
    protocoles de couche réseau.</para>
  </abstract>
  <keywordset>
    <keyword>Langage C</keyword>
    <keyword>dual stack</keyword>
    <keyword>ipv4</keyword>
    <keyword>ipv6</keyword>
    <keyword>socket</keyword>
    <keyword>udp</keyword>
    <keyword>tcp</keyword>
    <keyword>client</keyword>
    <keyword>serveur</keyword>
  </keywordset>
</info>

<sect1 xml:id='socket-c-4and6.legal.meta'>
  &legal;

  <sect2 xml:id='socket-c-4and6.meta'>
    <title>Meta-information</title>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="http://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
  </sect2>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='socket-c-4and6.context'>
  <title>Contexte de développement</title>

  <para>L'objectif de développement étant l'initiation, on se limite à un code
  minimaliste utilisant deux programmes distincts : un serveur et un
  client. Ces deux programmes échangent des chaînes caractères. Le
  <emphasis>client</emphasis> émet un message que le
  <emphasis>serveur</emphasis> traite et retransmet vers le
  <emphasis>client</emphasis>. Le traitement est tout aussi minimaliste ; il
  convertit la chaîne de caractères en majuscules.</para>

  <sect2 xml:id='socket-c-4and6.context.archi'>
    <title>Système d'exploitation</title>

  <para>Le schéma ci-dessous permet de faire la correspondance entre les
  couches de la modélisation contemporaine et celles de la représentation
  macroscopique d'un système d'exploitation.</para>

  <mediaobject xml:id='socket-c-4and6-model'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/modelisation-noyau.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/modelisation-noyau.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Modélisation des communications réseau et d'un système d'exploitation</phrase>
    </textobject>
  </mediaobject>


  <para>Le logiciel correspondant aux protocoles allant de la couche physique
  jusqu'à la couche transport fait partie du sous-système réseau du noyau du
  système d'exploitation.</para>

  <para>Le programme utilisateur est lancé à partir de la couche
  <wordasword>Shell</wordasword> et est exécuté au niveau application.</para>

  <para>L'utilisation de sockets revient à ouvrir un canal de communication
  entre la couche application et la couche transport. La programmation des
  sockets se fait à l'aide de bibliothèques standard présentées ci-après :
  <xref linkend='socket-c-4and6.context.library'/>.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.gcc'>
    <title>Instructions de compilation</title>

  <para>Il est possible de compiler les deux programmes
  <emphasis>client</emphasis> et <emphasis>serveur</emphasis> en l'état sur
  n'importe quel système GNU/Linux. Il suffit d'appeler le compilateur C de la
  chaîne de développement <acronym>GNU</acronym> en désignant le nom du
  programme exécutable avec l'option <option>-o</option>.</para>

<screen width='80'><prompt>$</prompt> gcc -Wall -o udp-client.o udp-client.c
<prompt>$</prompt> gcc -Wall -o udp-server.o udp-server.c
<prompt>$</prompt> ls udp*
udp-client.c  udp-client.o  udp-server.c  udp-server.o</screen>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.run'>
    <title>Instructions d'exécution</title>

  <para>L'évaluation des deux programmes <emphasis>client</emphasis> et
  <emphasis>serveur</emphasis> est assez simple. On peut les exécuter sur le
  même hôte dans deux <wordasword>Shells</wordasword> distincts en utilisant
  l'interface de boucle locale pour les communications réseau.</para>

  <variablelist>
    <varlistentry xml:id='socket-c-4and6.context.run-server'>
      <term>Le programme serveur</term>
      <term>udp-server.o</term>
      <listitem>
<screen width='80'><prompt>$</prompt> ./udp-server.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) :
4500
Attente de requête sur le port 4500
>>  depuis 127.0.0.1:39311
  Message reçu : texte avec tabulation et espaces</screen>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.context.run-client'>
      <term>Le programme client</term>
      <term>udp-client.o</term>
      <listitem>
<screen width='80'><prompt>$</prompt> ./udp-client.o
Entrez le nom du serveur ou son adresse IP :
127.0.0.1
Entrez le numéro de port du serveur :
4500

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message :
        texte avec tabulation et espaces
Message traité : TEXTE AVEC TABULATION ET ESPACES
Saisie du message :
.</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>Lorsque le programme <emphasis>serveur</emphasis> est en cours
  d'exécution, il est possible de visualiser la correspondance entre le
  processus en cours d'exécution et le numéro de port en écoute à l'aide de la
  commande <command>netstat</command>.</para>

<screen width='80'><prompt>$</prompt> netstat -aup | grep -e Proto -e udp-server
(Tous les processus ne peuvent être identifiés, les infos sur les processus
non possédés ne seront pas affichées, vous devez être root pour les voir toutes.)
Proto Recv-Q Send-Q Adresse locale    Adresse distante  Etat  PID/Program name
udp        0      0 *:4500            *:*                     3157/udp-server.o</screen>

  <para>Dans l'exemple ci-dessus, le numéro de port <literal>4500</literal>
  apparaît dans la colonne <option>Adresse locale</option> et processus numéro
  <literal>3157</literal> correspond bien au programme
  <literal>udp-server.o</literal> dans la colonne <option>PID/Program
  name</option>.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.library'>
    <title>Bibliothèques utilisées</title>

  <para>Les deux programmes utilisent les mêmes fonctions disponibles à partir
  des bibliothèques standards.</para>

  <variablelist>
    <varlistentry xml:id='socket-c-4and6.context.library.libc6.netdb'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netdb.h</systemitem></term>
      <listitem>
      <para>Opérations sur les bases de données réseau. Ici, c'est la fonction
      <function>gethostbyname()</function> qui est utilisée. Elle renvoie une
      structure de type <parameter>hostent</parameter> pour l'hôte
      <parameter>name</parameter>. La chaîne <parameter>name</parameter> est
      soit un nom d'hôte, soit une adresse <acronym>IPv4</acronym>, soit une
      adresse <acronym>IPv6</acronym>. Pour obtenir plus d'informations, il
      faut consulter les pages de manuels : <userinput>man
      gethostbyname</userinput>.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-c-4and6.context.library.libc6.in'>
      <term><systemitem class='library'>libc6-dev</systemitem></term>
      <term><systemitem>netinet/in.h</systemitem></term>
      <listitem>
      <para>Famille du protocole Internet. Ici, plusieurs fonctions sont
      utilisées à partir du paramètre de description de socket
      <parameter>sockaddr_in</parameter>. Les quatre fonctions importantes
      traitent de la conversion des nombres représentés suivant le format hôte
      (octet le moins significatif en premier sur processeur Intel x86) ou
      suivant le format défini dans les en-têtes réseau (octet le plus
      significatif en premier). Ici le format hôte fait référence à
      l'architecture du processeur utilisé. Cette architecture est dite
      «petit-boutiste» pour les processeurs de marque
      <trademark>Intel</trademark> majoritairement utilisés dans les
      ordinateurs de type <acronym>PC</acronym>. À l'inverse, le format défini
      dans les en-têtes réseau est dit «gros-boutiste». Cette définition
      appelée <wordasword>Network Byte Order</wordasword> provient à la fois du
      protocole <acronym>IP</acronym> et de la couche liaison du modèle
      <acronym>OSI</acronym>.</para>
      <itemizedlist>
        <listitem>
	<para><function>htonl()</function> et
	<function>htons()</function> : conversion d'un entier long et d'un
	entier court depuis la représentation hôte (octet le moins significatif
	en premier ou <wordasword>Least Significant Byte First</wordasword>)
	vers la représentation réseau standard (octet le plus significatif en
	premier ou <wordasword>Most Significant Byte
	First</wordasword>).</para>
	</listitem>
	<listitem>
	<para><function>ntohl()</function> et
	<function>ntohs()</function> : fonctions opposées aux précédentes.
	Conversion de la représentation réseau vers la représentation
	hôte.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='socket-c-4and6.context.library.libc6.iostream'>
      <term><systemitem class='library'>libstdc++6-dev</systemitem></term>
      <term><systemitem>stdio.h</systemitem></term>
      <listitem>
      <para>Opérations sur les flux d'entrées/sorties de base tels que l'écran
      et le clavier. Ici, toutes les opérations de saisie de nom d'hôte,
      d'adresse <acronym>IP</acronym>, de numéro de port ou de texte sont
      gérées à l'aide des fonctions usuelles du langage C.</para>

      <para>Les fonctions d'affichage sans formatage <function>puts</function>
      et <function>fputs</function> ainsi que la fonction d'affichage avec
      formatage <function>printf</function> sont utilisées de façon
      classique.</para>

      <para>En revanche, la saisie des chaînes de caractères à l'aide de la
      fonction <function>scanf</function> est plus singulière. Comme le but des
      communications réseau évaluées ici est d'échanger des chaînes de
      caractères, il est nécessaire de transmettre ou recevoir des suites de
      caractères comprenant aussi bien des espaces que des tabulations.</para>

      <para>La syntaxe usuelle de saisie d'une chaîne de caractère est :</para>

<screen width='80'>scanf("%s", msg);</screen>

      <para>Si on se contente de cette syntaxe par défaut, la chaîne saisie est
      transmise par le programme <emphasis>client</emphasis> mot par mot. En
      conséquence, le traitement par le programme <emphasis>serveur</emphasis>
      est aussi effectué mot par mot.</para>

      <para>Pour transmettre une chaîne complète, on utilise une syntaxe du
      type suivant :</para>

<screen width='80'>scanf(" %[^\n]%*c", msg);</screen>

      <para>Le caractère espace situé entre les guillemets de gauche et le
      signe pourcentage a pour but d'éliminer les caractères <literal>'
      '</literal>, <literal>'\t'</literal> et <literal>'\n'</literal> qui
      subsisteraient dans la mémoire tampon du flux d'entrée standard
      <literal>stdin</literal> avant la saisie de nouveaux caractères.</para> 

      <para>La syntaxe <literal>[^\n]</literal> précise que tous les caractères
      différents du saut de ligne sont admis dans la saisie. On évite ainsi que
      les caractères <literal>' '</literal> et <literal>'\t'</literal> soient
      considérés comme délimiteurs.</para>

      <para>L'ajout de <literal>%*c</literal> permet d'éliminer le
      délimiteur <literal>'\n'</literal> et tout caractère situé après dans la
      mémoire tampon du flux d'entrée standard.</para>

      <para>Enfin, pour éviter tout débordement de la mémoire tampon du même
      flux d'entrée standard, on limite le nombre maximum des caractères saisis
      à la quantité de mémoire réservée pour stocker la chaîne de caractères.
      La «constante» <literal>MAX_MSG</literal> définie via une directive de
      préprocesseur est introduite dans la syntaxe de formatage de la saisie.
      Pour cette manipulation, on fait appel à une fonction macro qui renvoie
      la valeur de <literal>MAX_MSG</literal> comme nombre maximum de
      caractères à saisir.</para>

      <para>On obtient donc finalement le formatage de la saisie d'une chaîne
      de caractères suivant :</para>

<screen width='80'>scanf(" %"xstr(MAX_MSG)"[^\n]%*c", msg);</screen>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>D'une manière générale, toutes les fonctions sont documentées à l'aide
  des pages de manuels Unix classiques. Soit on entre directement à la console
  une commande du type : <userinput>man inet_ntoa</userinput>, soit on
  utilise l'aide du gestionnaire graphique pour accéder aux mêmes informations
  en saisissant une <acronym>URL</acronym> du type suivant à partir du
  gestionnaire de fichiers : <userinput>man:/inet_ntoa</userinput>.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.protocol'>
    <title>Choix du premier protocole de transport étudié</title>

  <para>Au dessus du protocole de couche réseau <acronym>IP</acronym>, on doit
  choisir entre deux protocoles de couche transport :
  <acronym>TCP</acronym> ou <acronym>UDP</acronym>.</para>
  
  <para>Dans l'ordre chronologique, le protocole <acronym>TCP</acronym> est le
  premier protocole à avoir été développé. Il «porte la moitié» de la
  philosophie du modèle Internet. Cette philosophie veut que la couche
  transport soit le lieu de la fiabilisation des communications. Ce protocole
  fonctionne donc en mode connecté et contient tout les outils nécessaires à
  l'établissement, au maintien et à la libération de connexion. De plus, des
  numéros de séquences garantissent l'intégrité de la transmission et le
  fenêtrage de ces numéros de séquences assure un contrôle de flux. Tout ces
  mécanismes ne sont pas évidents à appréhender pour un public débutant.</para>

  <para>Le protocole <acronym>UDP</acronym> a été développé après
  <acronym>TCP</acronym>. La philosophie de ce mode de transport suppose que le
  réseau de communication est intrinsèquement fiable et qu'il n'est pas
  nécessaire de garantir l'intégrité des transmissions et de contrôler les
  flux. On dit que le protocole <acronym>UDP</acronym> n'est pas orienté
  connexion ; ce qui a pour conséquence d'alléger considérablement les
  mécanismes de transport.</para>

  <para>L'objectif du présent document étant d'initier à l'utilisation des
  sockets, on s'appuie dans un premier temps sur le protocole de transport le
  plus simple : <acronym>UDP</acronym>. Les programmes «client» et
  «serveur» sont repris dans un second temps en utilisant le protocole
  <acronym>TCP</acronym>. En termes de développement, les différences de mise
  en œuvre des sockets sont minimes. C'est à l'analyse réseau que la différence
  se fait sachant que les mécanismes de fonctionnement des deux protocoles sont
  très différents.</para>

  <para>Pour plus d'informations, consulter le support <xref
  linkend='socket-c-4and6.refdocs.modelisation'/>.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.udp_schema'>
    <title>Sockets &amp; protocole de transport UDP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  client et côté serveur pour la mise en œuvre des sockets avec le protocole de
  transport <acronym>UDP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Client : <xref linkend='socket-c-4and6.udp.client.socket'/></para>
    </listitem>
    <listitem>
      <para>Serveur : <xref linkend='socket-c-4and6.udp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-c-4and6-udp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/udp-socket.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole UDP</phrase>
    </textobject>
  </mediaobject>
  </sect2>

  <sect2 xml:id='socket-c-4and6.context.tcp_schema'>
    <title>Sockets &amp; protocole de transport TCP</title>

  <para>Le schéma ci-dessous présente les sous-programmes sélectionnés côté
  client et côté serveur pour la mise en œuvre des sockets avec le protocole de
  transport <acronym>TCP</acronym>.</para>

  <para>Les appels de sous-programmes avec les passages de paramètres sont
  détaillés dans les sections suivantes.</para>

  <itemizedlist>
    <listitem>
      <para>Client : <xref linkend='socket-c-4and6.tcp.client.socket'/></para>
    </listitem>
    <listitem>
      <para>Serveur : <xref linkend='socket-c-4and6.tcp.server.socket'/></para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='socket-c-4and6-tcp-socket'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/tcp-socket.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Socket et protocole TCP</phrase>
    </textobject>
  </mediaobject>
  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.udp.client'>
 <title>Programme client UDP</title>

  <sect2 xml:id='socket-c-4and6.udp.client.socket'>
    <title>Utilisation des sockets avec le client UDP</title>

  <para>Au niveau du client, l'objectif est <emphasis>d'ouvrir</emphasis> un
  nouveau socket ; ce qui revient à ouvrir un canal de communication
  réseau avec la fonction <function>socket</function>.</para>

<programlisting width='80'>
  int socketDescriptor;

&lt;snipped/>
  socketDescriptor = socket(PF_INET<co xml:id='socket_family'/>, SOCK_DGRAM<co xml:id='socket_type'/>, IPPROTO_UDP<co xml:id='socket_protocol'/>);
  if (socketDescriptor &lt; 0) {
    fputs("Impossible de créer le socket", stderr);
    exit(EXIT_FAILURE);
    }</programlisting>

  <calloutlist>
    <callout arearefs='socket_family'>
    <para><option>PF_INET</option> désigne la famille de protocole de couche
    réseau <acronym>IPv4</acronym>.</para>
    </callout>
    <callout arearefs='socket_type'>
    <para><option>SOCK_DGRAM</option> désigne un service de transmission de
    datagrammes non orienté connexion.</para>
    </callout>
    <callout arearefs='socket_protocol'>
    <para><option>IPPROTO_UDP</option> désigne l'utilisation du protocole
    <acronym>UDP</acronym> au niveau de la couche transport.</para>
    </callout>
  </calloutlist>

  <para>Une fois le canal de communication réseau correctement ouvert, on peut
  passer à l'émission des datagrammes avec la fonction
  <function>sendto</function>.</para>

<programlisting width='80'>
  int socketDescriptor;
  char msg[MSG_ARRAY_SIZE];
  struct sockaddr_in serverAddress;

&lt;snipped/>
if (sendto(socketDescriptor<co xml:id='sendto_Descriptor'/>, msg, msgLength<co xml:id='sendto_msg'/>, 0,
           (struct sockaddr *) &amp;serverAddress,
           sizeof(serverAddress)<co xml:id='sendto_Address'/>) &lt; 0) {
  fputs("Émission du message impossible", stderr);
  close(socketDescriptor);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='sendto_Descriptor'>
    <para><option>socketDescriptor</option> contient le résultat de l'appel de
    la fonction <function>socket</function> ; le numéro du canal de
    communication entre le programme et la pile des protocoles réseau.</para>
    </callout>
    <callout arearefs='sendto_msg'>
    <para><option>msg</option> et <option>msgLength</option> correspondent au
    datagramme et à sa longueur. Ici, on émet des chaînes de caractères
    directement vers le correspondant réseau.</para>
    </callout>
    <callout arearefs='sendto_Address'>
    <para><option>(struct sockaddr *) &amp;serverAddress</option> et
    <option>sizeof(serverAddress)</option> correspondent à la structure de
    désignation de l'adresse <acronym>IP</acronym> et du numéro de port du
    serveur puis à la taille de cette structure.</para>
    </callout>
  </calloutlist>

  <para>Ensuite, il ne manque plus que la description de la réception des
  datagrammes renvoyés par le serveur.</para>

<programlisting width='80'>
&lt;snipped/>
if (recv(socketDescriptor<co xml:id='recv_Descriptor'/>, msg, MAX_MSG<co xml:id='recv_msg'/>, 0) &lt; 0) {
  fputs("Aucune réponse du serveur ?", stderr);
  close(socketDescriptor);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='recv_Descriptor'>
    <para><option>socketDescriptor</option> contient le résultat de l'appel de
    la fonction <function>socket</function> ; le numéro du canal de
    communication entre le programme et la pile des protocoles réseau.</para>
    </callout>
    <callout arearefs='recv_msg'>
    <para><option>msg</option> et <option>MAX_MSG</option> correspondent au
    datagramme reçu et à sa longueur. Ici, on reçoit des chaînes de caractères
    venant directement du correspondant réseau.</para>
    </callout>
  </calloutlist>

  <para>Pour toute information complémentaire sur les fonctions utilisées,
  consulter les pages de manuels correspondantes. Pour la fonction
  <function>socket</function> on peut utiliser
  <userinput>man 2 socket</userinput> ou
  <userinput>man 7 socket</userinput> par exemple.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.udp.client.source'>
    <title>Code source complet</title>

  <para>Code du programme <systemitem>udp-client.c</systemitem> :</para>

<programlisting width='80'><xi:include href='files/udp-client.c'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>

  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.udp.server'>
  <title>Programme serveur UDP</title>

  <sect2 xml:id='socket-c-4and6.udp.server.socket'>
    <title>Utilisation des sockets avec le serveur UDP</title>

  <para>Au niveau du serveur, l'objectif est aussi
  <emphasis>d'ouvrir</emphasis> un nouveau socket ; ce qui revient aussi à
  ouvrir un canal de communication réseau avec la fonction
  <function>socket</function>.</para>

<programlisting width='80'>
  int listenSocket;

&lt;snipped/>
listenSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
if (listenSocket &lt; 0) {
  fputs("Impossible de créer le socket en écoute", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>Cette étape ne présentant aucune différence avec le niveau client, on
  relie le numéro de socket avec le numéro de port choisi.</para>

<programlisting width='80'>
  int listenSocket;
  struct sockaddr_in serverAddress;

&lt;snipped/>
serverAddress.sin_family = PF_INET;
serverAddress.sin_addr.s_addr = htonl(INADDR_ANY)<co xml:id='inaddr_any'/>;
serverAddress.sin_port = htons(listenPort);

if (bind(listenSocket<co xml:id='bind_listenSocket'/>,
         (struct sockaddr *) &amp;serverAddress,
         sizeof(serverAddress)<co xml:id='bind_Address'/>) &lt; 0) {
  fputs("Impossible de lier le socket en écoute", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='inaddr_any'>
    <para><option>INADDR_ANY</option> spécifie que le programme est en écoute
    sur toutes les adresses <acronym>IP</acronym> sources.</para>
    </callout>
    <callout arearefs='bind_listenSocket'>
    <para><option>listenSocket</option> contient le résultat de l'appel de
    la fonction <function>socket</function> ; le numéro du canal de
    communication entre le programme et la pile des protocoles réseau.</para>
    </callout>
    <callout arearefs='bind_Address'>
    <para><option>(struct sockaddr *) &amp;serverAddress</option> et
    <option>sizeof(serverAddress)</option> correspondent à la structure de
    désignation de l'adresse <acronym>IP</acronym> et du numéro de port du
    serveur puis à la taille de cette structure.</para>
    </callout>
  </calloutlist>

  <para>Une fois la liaison en place, le programme attend les datagrammes
  provenant du client.</para>

<programlisting width='80'>  int listenSocket;
  struct sockaddr_in clientAddress;
  char line[(MAX_MSG+1)];

&lt;snipped/>
if (recvfrom(listenSocket, msg, MAX_MSG<co xml:id='recvfrom_line'/>, 0,
             (struct sockaddr *) &amp;clientAddress,
             &amp;clientAddressLength) &lt; 0) {
  fputs("Problème de réception du messsage", stderr);
  exit(EXIT_FAILURE);
  }</programlisting>

  <calloutlist>
    <callout arearefs='recvfrom_line'>
    <para>Les paramètres <option>msg</option> et <option>MAX_MSG</option>
    correspondent au datagramme et à sa longueur.</para>
    </callout>
  </calloutlist>

  <para>Enfin, les émissions de datagramme du serveur vers le client utilisent
  exactement les mêmes appels à la fonction <function>sendto</function> que les
  émissions du client vers le serveur.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.udp.server.source'>
    <title>Code source complet</title>

  <para>Code du programme <systemitem>udp-server.c</systemitem> :</para>

<programlisting width='80'><xi:include href='files/udp-server.c'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.tcp.client'>
  <title>Programme client TCP</title>

  <sect2 xml:id='socket-c-4and6.tcp.client.socket'>
    <title>Utilisation des sockets avec le client TCP</title>

  <para>Le fait que le protocole <acronym>TCP</acronym> soit un
  <emphasis>service orienté connexion</emphasis> entraîne un changement
  important dans le code source du programme client précédent. Le contrôle
  d'erreur est directement intégré dans la couche transport et n'est plus à la
  charge de la couche application. Il n'est donc plus nécessaire de mettre en
  œuvre un mécanisme de gestion de temporisation.</para>

  <para>Autre changement, il est maintenant nécessaire d'établir la connexion
  avant d'échanger la moindre information. Cette opération ce fait à l'aide de
  la fonction <function>connect</function>.</para>

<programlisting width='80'>  int socketDescriptor;
  struct sockaddr_in serverAddress;

&lt;snipped/>
if (connect(socketDescriptor,
            (struct sockaddr *) &amp;serverAddress,
            sizeof(serverAddress)) &lt; 0) {
  fputs("Connexion impossible", stderr);
  close(socketDescriptor);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>En cas d'échec de cette demande d'établissement de connexion, on
  abandonne le traitement.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.tcp.client.source'>
    <title>Patch code source</title>

  <para>Patch du programme <systemitem>tcp-client.c</systemitem> :</para>

<programlisting width='80'><xi:include href='files/tcp-client.c.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.tcp.server'>
  <title>Programme serveur TCP</title>

  <sect2 xml:id='socket-c-4and6.tcp.server.socket'>
    <title>Utilisation des sockets avec le serveur TCP</title>

  <para>Comme dans le cas du programme client, le fait que le protocole
  <acronym>TCP</acronym> soit un  <emphasis>service orienté
  connexion</emphasis> entraîne un changement important dans le code source du
  programme serveur précédent. Le contrôle d'erreur est directement intégré
  dans la couche transport.</para>

  <para>La fonction <function>listen</function> active l'utilisation du canal
  de communication initié avec la fonction <function>socket</function>. Le
  second paramètre <option>5</option> définit le nombre maximal de demandes de
  connexions en attente.</para>

<programlisting width='80'>  int listenSocket, connectSocket, i;

&lt;snipped/>
<emphasis>listen(listenSocket, 5);</emphasis>

while (1) {
  printf("Attente de connexion TCP sur le port %hu\n", listenPort);
&lt;snipped/></programlisting>

  <para>Si le client fait appel à la fonction <function>connect</function> pour
  demander l'établissement d'une connexion, le serveur fait appel à la fonction
  <function>accept</function> pour recevoir les nouvelles demandes de
  connexion.</para>

<programlisting width='80'>  int socketDescriptor;
  struct sockaddr_in serverAddress;

&lt;snipped/>
<emphasis>connectSocket = accept(listenSocket,</emphasis>
                       (struct sockaddr *) &amp;clientAddress,
		       &amp;clientAddressLength);

if (connectSocket &lt; 0) {
  fputs("Impossible d'accepter une connexion", stderr);
  close(listenSocket);
  exit(EXIT_FAILURE);
  }</programlisting>

  <para>En cas d'échec de l'ouverture du socket de réception des demandes
  d'établissement de connexion, on abandonne le traitement.</para>
  </sect2>

  <sect2 xml:id='socket-c-4and6.tcp.server.source'>
    <title>Patch code source</title>

  <para>Patch du programme <systemitem>tcp-server.c</systemitem> :</para>

<programlisting width='80'><xi:include href='files/tcp-server.c.patch'
parse='text' xmlns:xi='http://www.w3.org/2001/XInclude'/></programlisting>
  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.capture'>
  <title>Analyse réseau avec Wireshark</title>

  <para>L'analyse réseau présente un grand intérêt dans la validation des
  développements. Elle permet de contrôler le bon fonctionnement des
  communications suivant les jeux de protocoles utilisés. Ici, on peut
  différencier le fonctionnement des deux protocoles de la couche transport en
  analysant les échanges entre les deux programmes <emphasis>client</emphasis>
  et <emphasis>serveur</emphasis>.</para>

  <para>L'utilisation de l'analyseur <application>wireshark</application> est
  présentée dans le support &url.intro.analyse;.</para>

  <para>Les analyses présentées ci-après ont été réalisées dans les conditions
  suivantes :</para>

  <itemizedlist>
    <listitem>
    <para>Le programme <emphasis>serveur</emphasis> est exécuté sur l'hôte
    ayant l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.0.2.1</systemitem>. Ce programme est toujours en
    écoute sur le port <literal>4000</literal>.</para>
    </listitem>
    <listitem>
    <para>Le programme <emphasis>client</emphasis> est exécuté sur l'hôte ayant
    l'adresse <acronym>IP</acronym> <systemitem
    class='ipaddress'>192.0.2.30</systemitem>.</para>
    </listitem>
  </itemizedlist>

  <sect2 xml:id='socket-c-4and6.capture-udp'>
    <title>Analyse avec le protocole UDP</title>

  <para>Avant de passer à l'analyse, voici les copies d'écran de l'exécution
  des programmes.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen width='80'><prompt>$</prompt> ./udp-server.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) :
4000
Attente de requête sur le port 4000
>>  depuis 192.0.2.30:43648
  Message reçu : message de test UDP
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen width='80'><prompt>$</prompt> ./udp-client.o
Entrez le nom du serveur ou son adresse IP :
192.0.2.1
Entrez le numéro de port du serveur :
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
message de test UDP
Message traité : MESSAGE DE TEST UDP
Saisie du message : 
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  énoncés auparavant.</para>

  <itemizedlist>
    <listitem>
    <para>Chaîne de caractères traitée dans la partie données de la couche
    application.</para>
    </listitem>
    <listitem>
    <para>Numéros de ports utilisés dans les en-têtes de la couche transport.</para>
    </listitem>
    <listitem>
    <para>Adresses <acronym>IP</acronym> utilisées dans les en-têtes de la
    couche réseau.</para>
    </listitem>
  </itemizedlist>

  <mediaobject xml:id='wireshark-udp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-udp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole UDP</phrase>
    </textobject>
  </mediaobject>

  <para>Enfin, le fait que la capture se limite à deux échanges illustre la
  principale caractéristique du protocole <acronym>UDP</acronym> : un service
  de datagramme non orienté connexion qui suppose un réseau sous-jacent fiable
  et sans erreur.</para> 
  </sect2>

  <sect2 xml:id='socket-c-4and6.capture-tcp'>
    <title>Analyse avec le protocole TCP</title>

  <para>Comme dans le cas précédent, voici les copies d'écran de l'exécution
  des programmes avant de passer à l'analyse réseau.</para>

  <itemizedlist>
    <listitem>
    <para>Côté serveur :</para>

<screen width='80'><prompt>$</prompt> ./tcp-server.o
Entrez le numéro de port utilisé en écoute (entre 1500 et 65000) : 
4000
Attente de connexion TCP sur le port 4000
>>  connecté à 192.0.2.30:52060
  --  message de test TCP
  --  dernier message avant fermeture de la connexion
Attente de connexion TCP sur le port 4000
^C</screen>
    </listitem>
    <listitem>
    <para>Côté client :</para>

<screen width='80'><prompt>$</prompt> ./tcp-client.o
Entrez le nom du serveur ou son adresse IP :
192.0.2.1
Entrez le numéro de port du serveur :
4000

Entrez quelques caractères au clavier.
Le serveur les modifiera et les renverra.
Pour sortir, entrez une ligne avec le caractère '.' uniquement.
Si une ligne dépasse 100 caractères,
seuls les 100 premiers caractères seront utilisés.

Saisie du message : 
message de test TCP
Message traité : MESSAGE DE TEST TCP
Saisie du message : 
dernier message avant fermeture de la connexion
Message traité : DERNIER MESSAGE AVANT FERMETURE DE LA CONNEXION
Saisie du message :
.</screen>
    </listitem>
  </itemizedlist>

  <para>Dans la copie d'écran ci-dessous, on retrouve l'ensemble des éléments
  déjà connus : chaîne de caractères traitée, numéros de port en couche
  transport et adresses <acronym>IP</acronym> en couche réseau.</para>

  <mediaobject xml:id='wireshark-tcp'>
    <imageobject role='fo'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='12cm' scalefit='1' />
    </imageobject>
    <imageobject role='html'>
    <imagedata format='PNG' fileref='images/wireshark-tcp.png' width='640px' scalefit='1' />
    </imageobject>
    <textobject>
    <phrase>Wireshark et protocole TCP</phrase>
    </textobject>
  </mediaobject>

  <para>Cette copie d'écran se distingue de la précédente, par le nombre de
  trames capturées alors que le traitement effectué est quasiment le même. La
  capture réseau fait apparaître les phases d'établissement, de maintien et de
  libération d'une connexion. On illustre ainsi toutes les fonctions de
  fiabilisation apportées par le protocole <acronym>TCP</acronym>.</para>
  
  <para>À partir de ces quelques trames, on peut reprendre l'analyse de la
  poignée de main à trois voies, de l'évolution des numéros de séquence et de
  l'évolution de la fenêtre d'acquittement.</para>
  </sect2>
</sect1>

<sect1 xml:id='socket-c-4and6.refdocs'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='socket-c-4and6.refdocs.tutorial'>
      <term><citetitle>A Brief Socket Tutorial</citetitle></term>
      <listitem>
	<para>&url.tutorial.archive; : support proposant des exemples de
	programmes de communication réseau basés sur les sockets. Le présent
	document est <emphasis>très fortement inspiré</emphasis> des exemples
	utilisant le protocole de transport<acronym>UDP</acronym>.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.guide'>
      <term><citetitle>Beej's Guide to Network Programming</citetitle></term>
      <listitem>
	<para>&url.guide; : support très complet sur les sockets proposant
	de nombreux exemples de	programmes.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.modelisation'>
      <term><citetitle>Modélisations réseau</citetitle></term>
      <listitem>
	<para>&url.modelisations; : présentation et comparaison des
	modélisations <acronym>OSI</acronym> et Internet.</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.adressage.ipv4'>
      <term><citetitle>Adressage IPv4</citetitle></term>
      <listitem>
	<para>&url.adressage.ipv4; : support complet sur l'adressage du
	protocole de couche réseau de l'Internet
	(<acronym>IP</acronym>).</para>
      </listitem>
    </varlistentry>

    <varlistentry xml:id='socket-c-4and6.refdocs.config.interface.lan'>
      <term><citetitle>Configuration d'une interface réseau</citetitle></term>
      <listitem>
        <para>&url.config.interface.lan; : support sur la configuration des
	interfaces réseau. Il permet notamment de relever les adresses
	<acronym>IP</acronym> des hôtes en communication.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>
</article>
