<?xml version='1.0'?>
<!DOCTYPE article PUBLIC '-//OASIS//DTD DocBook XML V5.0//EN'
        '/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd'[

<!ENTITY phl   	     	   	SYSTEM 'author.xml'>
<!ENTITY legal 	     	   	SYSTEM 'legal.xml'>

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.wireshark
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.wireshark.org/">
   <citetitle>Wireshark</citetitle></link>'>

<!ENTITY url.wireshark.protocols
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://wiki.wireshark.org/ProtocolReference">
   <citetitle>Protocol Reference</citetitle></link>'>

<!ENTITY url.wireshark.media
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://wiki.wireshark.org/CaptureSetup/NetworkMedia">
   <citetitle>Network media specific capturing</citetitle></link>'>

<!ENTITY url.wireshark.dfref
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.wireshark.org/docs/dfref/">
   <citetitle>Display Filter Reference</citetitle></link>'>

<!ENTITY url.wireshark.user_guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.wireshark.org/download/docs/user-guide-a4.pdf">
   <citetitle>Wireshark User&#39;s Guide</citetitle></link>'>

<!ENTITY url.sans.pocket_ref_guide
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.sans.org/resources/tcpip.pdf">
   <citetitle>TCP/IP and tcpdump Pocket Reference Guide</citetitle></link>'>

<!ENTITY url.searchenterpriselinux
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://searchenterpriselinux.techtarget.com/searchEnterpriseLinux/downloads/284_EPS_04.pdf">
   <citetitle>Using Ethereal - Chapter 4 of Ethereal packet sniffing</citetitle></link>'>

<!ENTITY url.otherlabs.ethereal
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://gaia.cs.umass.edu/ethereal-labs/">
   <citetitle>Ethereal Labs</citetitle></link>'>
]>

<!-- $Id: intro.analyse.xml 1619 2011-04-04 22:08:00Z latu $  -->

<article xml:lang='fr' xml:id='intro.analyse'>

<info>
<title>Introduction à l'analyse réseau</title>
&phl;
<abstract>
	<para>L'analyseur de trafic est un outil pédagogique essentiel pour
		comprendre les mécanismes de fonctionnement des protocoles de
		communication sur les réseaux contemporains. Ce document comprend deux
		parties. Dans un premier temps, on trouve une introduction à
		l'utilisation de l'analyseur <citetitle>Wireshark</citetitle>. Dans un
		deuxième temps, les travaux pratiques permettent de découvrir
		l'organisaton des informations fournies par cet analyseur.</para>
</abstract>
<keywordset>
    <keyword>analyse</keyword>
    <keyword>capture</keyword>
    <keyword>encapsulation</keyword>
    <keyword>wireshark</keyword>
    <keyword>filtrage</keyword>
    <keyword>network</keyword>
    <keyword>paquet</keyword>
    <keyword>réseau</keyword>
    <keyword>tshark</keyword>
    <keyword>trame</keyword>
    <keyword>tutoriel</keyword>
</keywordset>
</info>

<sect1 xml:id='legal.meta'>
&legal;
<bridgehead xml:id='legal.meta.dist' renderas='sect2'>Méta-information</bridgehead>

  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>
</sect1>

<sect1 xml:id='wireshark.intro'>
<title>Analyse avec Wireshark</title>
  
	<para>Avec &url.wireshark;, il est possible de capturer des paquets
		directement sur les interfaces du système utilisé ou de lire des
		fichiers de captures sauvegardées. <citetitle>Wireshark</citetitle>
		supporte les formats de fichiers de capture les plus courants.</para>

  <sect2 xml:id='wireshark.intro.supported_protocols'>
    <title>Quels sont les protocoles supportés ?</title>

    <para>La liste des protocoles supportés par
    <citetitle>Wireshark</citetitle> est considérable. Elle évolue avec chaque
    nouvelle version. La page &url.wireshark.protocols; fournit un classement
    par famille de tous les protocoles dont les champs sont interprétés. Il est
    aussi possible d'accéder à ces informations via le menu <menuchoice>
    <guimenu>Help</guimenu>
    <guimenuitem>Supported Protocols</guimenuitem>
    </menuchoice>.</para>
  </sect2>

  <sect2 xml:id='wireshark.intro.supported_medias'>
    <title>Quels sont les médias supportés ?</title>

    <para>Le logiciel <citetitle>Wireshark</citetitle> permet l'analyse de
    transmissions réseau sur presque toutes les technologies. Les limitations
    d'utilisation sont plutôt dues au système d'exploitation sur lequel on
    exécute ce logiciel. Pour obtenir un état des possibilités d'analyse en
    fonction du système utilisé, il faut consulter la page :
    &url.wireshark.media;</para>
  </sect2>

<sect2 xml:id='wireshark.intro.interfaces_access'>
<title>Comment accéder aux interfaces ?</title>

	<para>Lorsque l'on exécute <command>wireshark</command> en tant
		qu'utilisateur normal, on ne peut accéder à la liste des interfaces en
		lançant l'opération <link
		linkend='wireshark.menus'><guimenu>Capture</guimenu></link>. Sur un
		système d'exploitation correctement administré, un utilisateur normal
		ne doit pas avoir accès aux interfaces sans conditions. Il existe
		plusieurs solutions pour donner un accès direct à la liste des
		interfaces physiques. En voici quatre classées par ordre de préférence
		:</para>

	<variablelist>
	<varlistentry>
		<term><emphasis>En mode utilisateur avec les paramètres des paquets de
			la distribution</emphasis></term>
	<listitem>
	<para>Les paquets de la distribution Debian GNU/Linux intègrent la
		délégation des droits de capture de paquets. Pour l'activer, il suffit
		de reconfigurer le paquet
		<application>wireshark-common</application>.</para>

<screen><prompt>#</prompt> dpkg-reconfigure wireshark-common</screen>

	<para>L'utilisateur doit appartenir au groupe système
		<systemitem>wireshark</systemitem> pour bénéficier de la
		fonctionnalité. Par exemple, l'ajout de l'utilisateur
		<systemitem>etu</systemitem> au groupe via la commande
		<command>adduser</command> donne le résultat suivant :</para>

<screen><prompt>#</prompt> adduser etu wireshark
Ajout de l'utilisateur « etu » au groupe « wireshark »...
Ajout de l'utilisateur etu au groupe wireshark
Fait.</screen>

	<para>Lors de la connexion suivante avec ce compte utilisateur il sera
		possible d'utiliser directement les outils
		<application>wireshark</application> ou
		<application>tshark</application>.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
		<term><emphasis>En mode utilisateur via les <wordasword>Linux
			Capabilities</wordasword></emphasis></term>
	<listitem>
	<para>On débute par la création d'un groupe système dédié à la capture de
		trafic réseau.</para>

<screen># addgroup --system pcap
Adding group `pcap' (GID 136) ...
Done.</screen>

	<para>On ajoute un ou plusieurs utilisateur(s) au groupe système.</para>

<screen># adduser phil pcap
Adding user `phil' to group `pcap' ...
Adding user phil to group pcap
Done.</screen>

	<para>Attention ! Cette nouvelle attribution n'est valable qu'après une
		nouvelle authentification. Nous sommes encore dans le cas classique de
		création du contexte de travail utilisateur au moment de
		l'authentification.</para>

	<para>On modifie les propriétés du programme
		<application>dumpcap</application> qui est chargé de la collecte du
		trafic réseau.</para>

	<para>Avant modification du groupe propriétaire, le masque des permissions
		est le suivant :</para>

<screen># ls -lh `which dumpcap`
-rwxr-xr-x 1 root root 62K  4 mars  18:04 /usr/bin/dumpcap</screen>

	<para>On change le groupe propriétaire et on applique un nouveau masque de
		permissions. Une fois cette opération faite, les membres du groupe
		système <systemitem>pcap</systemitem> seront les seuls utilisateurs à
		pouvoir exécuter le programme en mode non privilégié.</para>

<screen># chgrp pcap /usr/bin/dumpcap
# chmod 750 /usr/bin/dumpcap
# ls -lh /usr/bin/dumpcap
-rwxr-x--- 1 root pcap 62K  4 mars  18:04 /usr/bin/dumpcap</screen>

	<para>On indique au gestionnaire de paquets Debian que ces nouvelles
		propriétés doivent être conservées lors des mises à jour à
		venir.</para>

<screen># dpkg-statoverride --add root pcap 750 /usr/bin/dumpcap
# dpkg-statoverride --list /usr/bin/dumpcap
root pcap 750 /usr/bin/dumpcap</screen>

	<para>On modifie le contexte de travail du programme
		<systemitem>dumpcap</systemitem>.</para>

<screen># setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap
# getcap /usr/bin/dumpcap
/usr/bin/dumpcap = cap_net_admin,cap_net_raw+eip</screen>

	<para>Les bits <systemitem>eip</systemitem> correspondent aux attributs
		<wordasword>effective</wordasword>,
		<wordasword>inheritable</wordasword> et
		<wordasword>permitted</wordasword>.</para>

	<para>Avec l'attribut <wordasword>effective</wordasword>, le noyau ne
		vérifie pas si l'<acronym>UID</acronym> vaut 0 (mode privilégié) si le
		programme nécessite une opération en mode privilégié.</para>

	<para>L'attribut <wordasword>inheritable</wordasword> transmet les
		aptitudes du processus actuel aux autres processus enfants.</para>

	<para>L'attribut <wordasword>permitted</wordasword> indique que le
		processus peut utiliser les aptitudes étendues du noyau Linux.</para>

	<para>La documentation sur les <wordasword>Linux Capabilities</wordasword>
		est disponible à partir de la page <link
		xmlns="http://docbook.org/ns/docbook"
		xlink:href="http://sites.google.com/site/fullycapable/">Not needing
		root to administer Linux</link>.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
		<term><emphasis>En mode utilisateur avec
			<application>sudo</application></emphasis></term>
	<listitem>
	<para>L'application <application>sudo</application> permet de déléguer les
		droits du super-utilisateur avec une granularité très fine. L'optique
		de l'analyse réseau étant un cas particulier de l'administration
		système, on se limitera à la présentation du fichier de configuration
		de l'application : <filename>/etc/sudoers</filename>.</para>

<screen># sudoers file.
#
# This file MUST be edited with the 'visudo' command as root.
#
# See the man page for details on how to write a sudoers file.
#

# Host alias specification

# User alias specification

# Cmnd alias specification

# User privilege specification
root    ALL=(ALL) ALL

<emphasis>etu    ALL = NOPASSWD: /usr/bin/wireshark, /usr/bin/tshark</emphasis></screen>

	<para>C'est à la dernière ligne que se situe la partie intéressante.
		L'utilisateur normal <literal>etu</literal> dispose, sur n'importe quel
		hôte géré par ce système (<literal>ALL</literal>), d'un accès
		super-utilisateur aux applications <citetitle>Wireshark</citetitle> et
		<application>tshark</application> sans avoir à saisir son mot de passe.
		Pour lancer l'application, il faut préciser l'appel à l'application
		<application>sudo</application> de la façon suivante :</para>

<screen>$ sudo wireshark &amp;</screen>
	</listitem>
	</varlistentry>
	<varlistentry xml:id='wireshark.su'>
		<term><emphasis>En mode super-utilisateur</emphasis></term>
	<listitem>
	<para>Partant d'une connexion avec un compte utilisateur normal, celui-ci
		est propriétaire exclusif de son écran
		(<wordasword>display</wordasword>). Il doit donc autoriser le super
		utilisateur à accéder à son écran à l'aide de la commande
		<command>xhost</command>, passer en connexion super-utilisateur avec la
		commande <command>su</command> puis exécuter l'application
		<citetitle>Wireshark</citetitle>.</para>

<screen>$ xhost +local:
$ su
Password:
# wireshark &amp;</screen>
	</listitem>
	</varlistentry>
    </variablelist>
</sect2>
</sect1>

<sect1 xml:id='wireshark.gui'>
<title>Interface utilisateur</title>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-complet.png' format='PNG' width='12cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-complet.png' format='PNG' width='640px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Écran complet WireShark</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-complet.png'>Écran complet WireShark</link></para>
	</caption>
	</mediaobject>

	<para>L'interface de l'analyseur se décompose en plusieurs barres ou
		fenêtres :</para>

  <variablelist>
    <varlistentry xml:id='wireshark.menus'>
      <term>Barre de menus</term>
      <listitem>
      <para>On y retrouve la liste classique de menus. Voici une liste des
      fonctions remarquables accessibles à partir de ces menus.</para>
      <itemizedlist>
      <listitem>
      <para>Le menu <guimenuitem>File</guimenuitem> sert à sauvegarder ou
      charger un fichier de capture réseau. Une capture peut très bien avoir
      été réalisée sur une sonde distante ou avec un autre outil et être
      analysée avec <citetitle>Wireshark</citetitle> à postériori.</para>
      </listitem>
      <listitem>
      <para>Le menu <guimenuitem>Capture</guimenuitem> sert à fixer les
      paramètres d'une nouvelle capture réseau. Voir <xref
      linkend='wireshark.capture' />.</para>
      </listitem>
      <listitem>
      <para>Le menu <guimenuitem>Statistics</guimenuitem> sert à effectuer
      différents calculs sur les volumes de données et la répartition des
      protocoles.</para>
      </listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.icons'>
      <term>Barre des icônes</term>
      <listitem>
      <para>Cette barre regroupe tous les raccourcis sur les manipulations
      d'une capture.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.postfilter'>
      <term>Barre de filtrage</term>
      <listitem>
      <para>Cette barre sert à saisir l'expression de filtrage à postériori
      d'une capture pour isoler tout ou partie d'un échange réseau.</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.framelist'>
      <term>Fenêtre contenant la liste des trames capturées</term>
      <listitem>
      <para>Sur chaque ligne on retrouve :</para>
      <itemizedlist>
        <listitem>
	<para>le numéro du paquet,</para>
	</listitem>
	<listitem>
	<para>son temps de capture,</para>
	</listitem>
	<listitem>
	<para>sa source,</para>
	</listitem>
	<listitem>
	<para>sa destination,</para>
	</listitem>
	<listitem>
	<para>le protocole de plus haut niveau décodé,</para>
	</listitem>
	<listitem>
	<para>le résumé des champs caractéristiques de ce protocole.</para>
	</listitem>
      </itemizedlist>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.protocollist'>
      <term>Fenêtre d'affichage de la pile des protocoles décodés pour la trame
      sélectionnée</term>
      <listitem>
      <para>Avant toute opération de développement des champs d'un ou plusieurs
      protocoles, cette fenêtre donne la liste la pile de protocoles décodés
      allant du niveau physique (en haut) jusqu'au niveau le plus haut reconnu
      (en bas). Le protocole de niveau le plus haut reconnu apparaît est celui
      qui apparaît dans la colonne protocole de la <xref
      linkend='wireshark.framelist' />.</para>
      <itemizedlist>
      <listitem>
      <para>La première ligne ou niveau <guimenuitem>Frame</guimenuitem>
      correspond à une pseudo couche physique. Comme il n'est pas possible de
      réaliser la capture directement à partir des composants électroniques qui
      pilotent l'interface réseau sans perturber le fonctionnement du système,
      l'opération a lieu au niveau liaison à l'aide de la bibliothèque
      <citetitle>libpcap</citetitle>.</para>
      <para>A ce niveau, les informations disponibles sont : la quantité
      de bits capturés et la date de capture.</para>
      </listitem>
      <listitem>
      <para>La deuxième ligne correspond au niveau liaison. On y détaille le
      type et les champs de la trame et les adresses physiques.</para>
      </listitem>
      <listitem>
      <para>La troisième ligne correspond au niveau réseau. On y détaille les
      champs du protocole réseau reconnu : adresses logiques et
      indicateurs d'état.</para>
      </listitem>
      <listitem>
      <para>La quatrième ligne correspond au niveau transport. On y détaille
      les champs du protocole de transport reconnu : état de la connexion,
      numéros de ports utilisés et diverses options.</para>
      </listitem>
      <listitem>
      <para>La cinquième ligne correspond au niveau application. On y trouve
      les données utilisateur.</para>
      </listitem>
      </itemizedlist>
      <para>Pour le développement de chacun des champs de la trame, il faut
      cliquer sur le triangle situé à gauche au niveau de chaque couche.</para>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='wireshark.hexa'>
    <term>Fenêtre d'affichage brut de la trame sélectionnée</term>
    <listitem>
      <para>Cette fenêtre affiche tous les octets de la trame en
      hexadécimal.</para>
    </listitem>
    </varlistentry>
  </variablelist>
</sect1>

<sect1 xml:id='wireshark.capture'>
<title>Capture d'une série de trame</title>
    
	<para>Après avoir lancé le logiciel <citetitle>Wireshark</citetitle>, la
		séquence suivante illustre la capture d'une série de 60 trames :</para>
  
	<orderedlist>
	<listitem>
	<para>Sélectionner <guimenu>Capture</guimenu> puis
		<guimenu>Options</guimenu>.</para>
	</listitem>
	<listitem>
	<para>La ligne <guisubmenu>Filtre de capture pour les interfaces
		sélectionnées</guisubmenu> permet de préciser un filtrage
		<emphasis>à priori</emphasis>. La syntaxe de ce filtrage est identique
		à celle de la commande <command>tcpdump</command>. La documentation est
		disponible à partir des pages de manuels de cette commande :
		<userinput>man tcpdump</userinput>. Voici 3 exemples :</para>

	<itemizedlist>
	<listitem>
	<para><userinput>ip</userinput> : en spécifiant le protocole réseau à
		analyser, on évite la capture des trames des autres protocoles des
		niveaux réseau et liaison.</para>
	</listitem>
	<listitem>
	<para><userinput>host 192.168.0.1</userinput> : en spécifiant l'adresse
		<acronym>IP</acronym> d'un hôte, on ne retient que le trafic émis et
		reçu par cette adresse.</para>
	</listitem>
	<listitem>
	<para><userinput>host 192.168.0.1 and host 10.0.0.1</userinput> : en
		spécifiant les adresses <acronym>IP</acronym> de 2 hôtes, on ne retient
		que le trafic entre ces 2 adresses.</para>
	</listitem>
	</itemizedlist>

	<para>D'une façon plus générale, on peut combiner plusieurs critères avec
		les opérateurs logiques <literal>and</literal> et|ou
		<literal>or</literal>.</para>
	<itemizedlist>
	<listitem>
	<para>le type : <literal>host</literal>, <literal>net</literal> et
		<literal>port</literal>.</para>
	</listitem>
	<listitem>
	<para>la direction : <literal>src</literal> et
		<literal>dst</literal>.</para>
	</listitem>
	<listitem>
	<para>le protocole : <literal>ether</literal>, <literal>fddi</literal>,
		<literal>tr</literal>, <literal>ip</literal>, <literal>ip6</literal>,
		<literal>arp</literal>, <literal>rarp</literal>,
		<literal>decnet</literal>, <literal>tcp</literal> et
		<literal>udp</literal>.</para>
	</listitem>
	</itemizedlist>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-capture1.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-capture1.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Capture : choix de l'interface et filtrage avant capture</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-capture1.png'>Capture : choix de l'interface et filtrage avant capture</link></para>
	</caption>
	</mediaobject>

	</listitem>
	<listitem>
	<para>La rubrique <guisubmenu>Options</guisubmenu> permet de fixer
		plusieurs critères d'arrêt en fonction du nombre de trames et|ou du
		volume de données capturées.</para>

	<mediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/wireshark-capture2.png' format='PNG' width='9cm' align='center' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/wireshark-capture2.png' format='PNG' width='480px' align='center' scalefit='1'/>
	</imageobject>
	<textobject>
		<phrase>Capture : choix des options d'arrêt de capture</phrase>
	</textobject>
	<caption>
	<para><link xmlns="http://docbook.org/ns/docbook"
	xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-capture2.png'>Capture : choix des options d'arrêt de capture</link></para>
	</caption>
	</mediaobject>

    </listitem>
    <listitem>
	<para>Clicker sur le bouton <guisubmenu>Démarrer</guisubmenu> pour lancer
		la capture.</para>
	</listitem>
	</orderedlist>
</sect1>

<sect1 xml:id='wireshark.filter'>
  <title>Filtrage de l'affichage après capture</title>

  <para>Le filtrage <emphasis>à postériori</emphasis> est certainement l'étape
  la plus importante dans l'analyse réseau. C'est cette opération qui permet
  d'isoler l'information pertinente. La granularité de la syntaxe de filtrage
  disponible avec <citetitle>Wireshark</citetitle> est très importante. Il est
  possible de retenir un champ unique parmi les 820 protocoles supportés. Voici
  quelques exemples de filtrage allant du plus général au plus détaillé.</para>

  <sect2 xml:id='wireshark.tcpstream'>
    <title>Isoler une connexion TCP</title>

    <para>Après avoir réalisé une capture, il est possible d'isoler une
    connexion <acronym>TCP</acronym> en repérant son établissement (le début)
    et sa libération (la fin). En cliquant sur le bouton droit de la souris
    après avoir sélectionné n'importe quelle trame appartenant à la connexion à
    isoler, il faut valider l'option <guisubmenu>Follow TCP
    Stream</guisubmenu>.</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='images/wireshark-tcpstream.png' format='PNG'
    contentwidth='5cm' width='5.5cm'/>
    </imageobject>
    <textobject>
    <phrase>Isoler une connexion TCP</phrase>
    </textobject>
    <caption>
    <para><link xmlns="http://docbook.org/ns/docbook" xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-tcpstream.png'>
    Isoler une connexion TCP - vue complète</link></para>
    </caption>
  </mediaobject>

    <para>A la suite de cette opération, <citetitle>Wireshark</citetitle>
    ouvre une nouvelle fenêtre contenant les données vues de la couche
    transport.</para>

  <mediaobject>
    <imageobject>
    <imagedata fileref='images/wireshark-tcpdata.png' format='PNG'
    contentwidth='8cm' width='8.5cm'/>
    </imageobject>
    <textobject>
    <phrase>Données vues de la couche transport</phrase>
    </textobject>
    <caption>
    <para><link xmlns="http://docbook.org/ns/docbook" xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-tcpdata.png'>
    Données vues de la couche transport - vue complète</link></para>
    </caption>
  </mediaobject>
  </sect2>
  
  <sect2 xml:id='wireshark.filter.syntax'>
    <title>Syntaxe du filtrage à postériori</title>

    <para>Comme indiqué ci avant, la granularité de la syntaxe de filtrage est
    très importante. Elle peut donc s'avérer très complexe à manipuler.
    <citetitle>Wireshark</citetitle> offre plusieurs solutions pour rendre
    l'apprentissage de cette syntaxe interactif.</para>

    <para>Tout d'abord, l'opération précédente de filtrage simplifié (voir
    <xref linkend='wireshark.tcpstream' />) n'était qu'un cas particulier de
    saisie interactive de filtre de capture. En sélectionnant l'option
    <guimenuitem>Follow TCP Stream</guimenuitem>, on a «saisi» un filtre avec
    la syntaxe suivante :</para>
<screen>(ip.addr<co xml:id='ip.addr'/> eq 192.168.1.9<co xml:id='ip.addr.sample'/> and ip.addr eq 80.247.225.35) \
and<co xml:id='filter.logic'/> (tcp.port<co xml:id='tcp.port'/> eq 32783<co xml:id='tcp.port.sample'/> and tcp.port eq 80)

</screen>
    <para>Cette expression est extraite de la <xref
    linkend='wireshark.postfilter'/>. Elle doit tenir sur une ligne unique
    quel que soit sa longueur.</para>

    <calloutlist>
      <callout arearefs='ip.addr'>
      <para><userinput>ip.addr</userinput> : sélection d'une adresse
      <acronym>IP</acronym>.</para>
      </callout>
      <callout arearefs='ip.addr.sample'>
      <para><userinput>eq 192.168.1.9</userinput> : valeur particulière
      d'adresse <acronym>IP</acronym>. L'opérateur <literal>eq</literal>
      correspond à un test d'égalité. Il est aussi possible d'utiliser la
      syntaxe du langage C pour les tests :</para>
      <itemizedlist>
        <listitem>
	<para><literal>==</literal> : égalité,</para>
	</listitem>
        <listitem>
	<para><literal>!=</literal> : différence,</para>
	</listitem>
        <listitem>
	<para><literal>&gt;=</literal> : supérieur ou égal,</para>
	</listitem>
        <listitem>
	<para><literal>&lt;=</literal> : inférieur ou égal.</para>
	</listitem>
      </itemizedlist>
      </callout>
      <callout arearefs='filter.logic'>
      <para>Les opérateurs logiques tels que <literal>and</literal> et|ou
      <literal>or</literal> associés aux parenthèses servent à composer des
      expressions de sélection précises.</para>
      </callout>
      <callout arearefs='tcp.port'>
      <para><userinput>tcp.port</userinput> : sélection d'un numéro de
      port du protocole <acronym>TCP</acronym> de la couche transport.</para>
      </callout>
      <callout arearefs='tcp.port.sample'>
      <para><userinput>eq 32783</userinput> : valeur particulière de port
      <acronym>TCP</acronym>. La syntaxe de test est identique pour tous les
      champs des différents protocoles reconnus.</para>
      </callout>
    </calloutlist>

    <para>La construction interactive des filtres d'affichage peut se faire à
    l'aide de la souris. Voici 2 exemples «simplistes» :</para>
    
    <variablelist>
      <varlistentry xml:id='wireshark.mss'>
      <term>Option TCP MSS</term>
      <listitem>
      <para>Admettons que l'on veuille repérer toutes les trames capturées dans
      lesquelles l'option <literal>MSS</literal> (<wordasword>Maximum Segment
      Size</wordasword>) apparaît. On développe alors l'en-tête
      <acronym>TCP</acronym> d'un paquet correspondant à une demande de
      connexion pour faire apparaître cette option. En cliquant sur le bouton
      droit de la souris on accède au menu <guimenuitem>Prepare a
      Filter</guimenuitem>.</para>

    <mediaobject>
      <imageobject>
      <imagedata fileref='images/wireshark-preparefilter.png' format='PNG'
      contentwidth='8cm' width='8.5cm'/>
      </imageobject>
      <textobject>
      <phrase>Préparation d'un filtre d'affichage à la souris</phrase>
      </textobject>
      <caption>
      <para><link xmlns="http://docbook.org/ns/docbook" xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-preparefilter.png'>
      Préparation d'un filtre d'affichage à la souris - vue complète</link></para>
      </caption>
    </mediaobject>

      <para>L'expression préparée apparaît dans la champ de la <xref
      linkend='wireshark.postfilter'/> :</para>
<screen>tcp.options.mss_val == 1460
</screen>

      <para>Supposons maintenant que l'on veuille afficher toutes les trames
      ayant cette option indépendamment de sa valeur. Il suffit alors de
      supprimer le test :</para>
<screen>tcp.options.mss_val
</screen>
      </listitem>
      </varlistentry>
      <varlistentry xml:id='wireshark.fragment'>
      <term>Fragmentation IP</term>
      <listitem>
      <para>Admettons que l'on veuille observer la fragmentation
      <acronym>IP</acronym> en repérant les champs correspondants de l'en-tête
      des paquets <acronym>IP</acronym>. Tout d'abord, il faut «provoquer» la
      fragmentation <acronym>IP</acronym> artificiellement. On utilise deux
      hôtes avec chacun une interface Ethernet et un hub. En réduisant la
      taille maximum des données transmises par paquet (<wordasword>Maximum
      Transmit Unit</wordasword>) sur l'interface Ethernet d'un hôte, on
      observe plus facilement les effets de la fragmentation.</para>

<screen>  __________
 |_=_=_=_=_// Hub
   |     |
  /       \_______
  |.....          \
.------,~         |.....
|Hote_A|'       .------,~
|      ||       |Hote_B|'
\------ /       |      ||
 ======/        \------ /
192.168.254.128  ======/
                192.168.254.2

Hote_A # ifconfig eth0 mtu 256
Hote_A # ping -s 128 -c 5 192.168.254.2
PING 192.168.254.2 (192.168.254.2) 128(156) bytes of data.
136 bytes from 192.168.254.2: icmp_seq=1 ttl=64 time=0.591 ms
136 bytes from 192.168.254.2: icmp_seq=2 ttl=64 time=0.528 ms
136 bytes from 192.168.254.2: icmp_seq=3 ttl=64 time=0.554 ms
136 bytes from 192.168.254.2: icmp_seq=4 ttl=64 time=0.545 ms
136 bytes from 192.168.254.2: icmp_seq=5 ttl=64 time=0.546 ms

--- 192.168.254.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 3999ms
rtt min/avg/max/mdev = 0.528/0.552/0.591/0.036 ms
Hote_A # ping -s 8192 -c 5 192.168.254.2
PING 192.168.254.2 (192.168.254.2) 8192(8220) bytes of data.
8200 bytes from 192.168.254.2: icmp_seq=1 ttl=64 time=15.4 ms
8200 bytes from 192.168.254.2: icmp_seq=2 ttl=64 time=15.4 ms
8200 bytes from 192.168.254.2: icmp_seq=3 ttl=64 time=15.4 ms
8200 bytes from 192.168.254.2: icmp_seq=4 ttl=64 time=15.4 ms
8200 bytes from 192.168.254.2: icmp_seq=5 ttl=64 time=15.4 ms

--- 192.168.254.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4004ms
rtt min/avg/max/mdev = 15.444/15.462/15.481/0.079 ms
</screen>

      <para>On observe ensuite le résultat sur l'affichage des trames
      capturées. La syntaxe du filtre est :</para>
<screen>ip.flags.df == 0
</screen>

    <mediaobject>
      <imageobject>
      <imagedata fileref='images/wireshark-fragment.png' format='PNG'
      contentwidth='8cm' width='8.5cm'/>
      </imageobject>
      <textobject>
      <phrase>Préparation d'un filtre d'affichage à la souris</phrase>
      </textobject>
      <caption>
      <para><link xmlns="http://docbook.org/ns/docbook" xlink:href='https://www.inetdoc.net/travaux_pratiques/intro.analyse/images/wireshark-fragment.png'>
      Préparation d'un filtre d'affichage à la souris - vue complète</link></para>
      </caption>
    </mediaobject>

      <para>Connaissant maintenant la syntaxe d'identification de la
      fragmentation <acronym>IP</acronym>, il sera toujours possible
      d'appliquer le même filtre sur une capture beaucoup plus importante en
      volume.</para>

      </listitem>
      </varlistentry>
    </variablelist>
    </sect2>

    <sect2 xml:id='wireshark.dfref'>
      <title>Documentation de référence sur les filtres d'affichage</title>

      <para>La documentation sur l'ensemble des champs des protocoles reconnus
      utilisables dans les expressions de filtres d'affichage est disponible à
      l'adresse : &url.wireshark.dfref;.</para>
    </sect2>
</sect1>

<sect1 xml:id='wireshark.distance'>
  <title>Analyse à distance</title>

  <para>Lorsque l'on exploite une infrastructure de serveurs avec plusieurs
  périmètres réseau cloisonnés, il est fréquent de devoir procéder à des
  captures réseau à distance. De plus, la plupart des serveurs récents sont des
  lames qui n'ont ni clavier ni écran. Voici donc un exemple de scénario
  capture réseau réalisée sur un hôte distant exploitée ensuite sur un poste de
  travail ayant une interface graphique.</para>

  <para>Dans la suite de copies d'écran suivante, on considère les éléments
  suivants :</para>

  <itemizedlist>
    <listitem>
    <para>Le poste de travail sur lequel l'analyse est effectuée en mode
    graphique après collecte du fichier de capture est appelé <systemitem
    class='systemname'>&lt;my_laptop.myothernet&gt;</systemitem>.</para>
    </listitem>
    <listitem>
    <para>Le serveur lame sans écran ni clavier sur lequel la capture réseau
    est réalisée est appelé <systemitem
    class='systemname'>&lt;my_distant_server.mynet&gt;</systemitem>. On y
    accède via une console sécurisée <acronym>SSH</acronym>.</para>
    </listitem>
    <listitem>
    <para>On suppose que les deux hôtes ont un compte utilisateur <systemitem
    class='username'>me</systemitem>. Le compte utilisateur sur le serveur doit
    disposer des droits nécessaire à la capture de trames sur les interfaces
    réseau du serveur. Ces droits sont gérés avec
    <application>sudo</application>.</para>
    </listitem>
    <listitem>
    <para>On utilise l'application <application>tshark</application> qui
    permet d'exécuter l'analyse réseau directement à la console sans recours à
    une interface graphique. Cette application est fournie par le paquet
    <citetitle>Debian</citetitle> du même nom. Voir le résultat de la commande
    <userinput>$ apt-cache show tshark</userinput> pour
    obtenir les informations sur ce paquet.</para>
    </listitem>
    <listitem>
    <para>Les indications données ci-dessous ne peuvent se substituer aux pages
    de manuels de l'application. Il est vivement conseillé de les consulter
    pour adapter l'analyse réseau à ses besoins :
    <userinput>man tshark</userinput>.</para>
    </listitem>
  </itemizedlist>

  <variablelist>
    <varlistentry>
    <term>Connexion au serveur depuis le poste de travail</term>
    <listitem>
    <para>Comme indiqué ci-avant, on accède au serveur via une console
    sécurisée <acronym>SSH</acronym>. À partir le Windoze, l'outil
    <systemitem>putty</systemitem> permet d'effectuer la même opération.</para>
<screen>me@&lt;my_laptop&gt;:~$ ssh me@&lt;my_distant_server.mynet&gt;

Linux &lt;my_distant_server&gt; 2.6.15 #1 SMP Mon Mar 13 14:54:19 CET 2006 i686

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
No mail.
Last login: Tue Mar 21 10:45:38 2006 from &lt;my_laptop.myothernet&gt;

me@&lt;my_distant_server&gt;:~$
</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Lancement de la capture réseau dans un nouveau shell</term>
    <listitem>
    <para>Un utilisateur «normal» n'ayant pas les droits suffisants pour accéder
    directement aux interfaces réseau, on doit lancer l'analyseur de réseau via
    <application>sudo</application> :
    <userinput>$ sudo tshark</userinput>.</para>
    <para>On lance cette commande dans un nouveau shell en ajoutant le symbole
    <option>&amp;</option> à la fin de la ligne. De cette façon, on conserve la
    possibilité de lancer d'autres commandes sur la console obtenue lors de la
    connexion au serveur.</para>
<screen>me@&lt;my_distant_server&gt;:~$ sudo tshark -q -i _eth0 -w distant.cap \
  -a filesize:4096 tcp and ! host &lt;my_laptop.myothernet&gt; &amp;
</screen>
    <itemizedlist>
      <listitem>
      <para>L'option <option>-q</option> rend la capture «silencieuse». Il
      s'agit surtout de supprimer l'affichage du compte des paquets enregistrés
      pendant la capture. Cet affichage est gênant si l'on souhaite conserver
      la console pour effectuer d'autres manipulations en cours de
      capture.</para>
      </listitem>
      <listitem>
      <para>L'option <option>-i _eth0</option> désigne l'interface réseau
      sur laquelle la capture est réalisée.</para>
      </listitem>
      <listitem>
      <para>L'option <option>-w distant.cap</option> désigne le fichier dans
      lequel les paquets capturés sont enregistrés. Sans spécification du
      format de fichier avec l'option <option>-F</option>, les paquets capturés
      sont enregistrés directement (mode <wordasword>raw</wordasword>).</para>
      </listitem>
      <listitem>
      <para>L'option <option>-a filesize:4096</option> donne le critère d'arrêt
      de l'enregistrement. Ici, le critère retenu est la taille du fichier de
      capture. Cette taille est comptabilisée en multiple du kilooctet (1024
      octets) ; soit 4096ko dans cet exemple.</para>
      </listitem>
      <listitem>
      <para>Les options suivantes correspondent au filtrage à priori des
      paquets à enregistrer. On spécifie le protocole de transport
      <option>tcp</option> <emphasis>et</emphasis> on n'enregistre pas les
      paquets de l'hôte qui à ouvert la console sécurisée : <option>! host
      &lt;my_laptop.myothernet&gt;</option>. Sans cette dernière précaution,
      l'enregistrement ne contiendra pratiquement que les échanges
      <acronym>SSH</acronym>. Ces échanges sont sans intérêt puisqu'ils
      correspondent aux communications entre les deux hôtes utilisés pour
      l'analyse distante.</para> 
      </listitem>
    </itemizedlist>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>«Initiation» du trafic réseau à capturer.</term>
    <listitem>
    <para>Cette commande n'est qu'un prétexte pour remplir le fichier de
    capture. Avec le téléchargement d'une image des sources du noyau Linux, on
    est sûr de faire transiter un volume suffisant ;-).</para>
<screen>me@&lt;my_distant_server&gt;:~$ wget \
  http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.16.tar.bz2
--11:14:29--  http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.16.tar.bz2
           => `linux-2.6.16.tar.bz2'
Résolution de kernel.org... 204.152.191.5, 204.152.191.37
Connexion vers kernel.org|204.152.191.5|:80...connecté.
requête HTTP transmise, en attente de la réponse...200 OK
Longueur: 40 845 005 (39M) [application/x-bzip2]

100%[===============//=====================>] 40 845 005   296.19K/s    ETA 00:00

11:16:58 (292.09 KB/s) - « linux-2.6.16.tar.bz2 » sauvegardé [40845005/40845005]
</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Fin de la capture et visualisation du fichier</term>
    <listitem>
    <para>Comme indiqué ci-avant, l'enregistrement s'arrête lorsque le fichier
    atteint la taille de 4096ko.</para>
<screen>[1]+  Done  sudo tshark -q -i _eth0 -w distant.cap \
                 -a filesize:4096 tcp and ! host &lt;my_laptop.myothernet&gt;

me@&lt;my_distant_server&gt;:~$ ls -lAh
-rw-------  1 root latu   4,1M 2006-03-21 11:14 distant.cap
-rw-r--r--  1 latu latu    39M 2006-03-20 07:22 linux-2.6.16.tar.bz2

me@&lt;my_distant_server&gt;:~$ sudo chmod 640 distant.cap

me@&lt;my_distant_server&gt;:~$ exit
logout
Connection to &lt;my_distant_server.mynet&gt; closed.
</screen>
    <para>L'enregistrement sur fichier ayant été réalisé avec l'identité du
    super-utilisateur via la commande <command>sudo</command>, il faut changer
    le masque des permissions de ce fichier ou son propriétaire. Dans cet
    exemple, c'est le masque des permissions d'accès qui a été étendu pour que
    l'utilisateur normal puisse lire le fichier de capture et le transférer sur
    son poste de travail.</para> 
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Récupération du fichier de capture sur le poste de travail</term>
    <listitem>
<screen>me@&lt;my_laptop&gt;:~$ scp me@&lt;my_distant_server.mynet&gt;:~/distant.cap .
distant.cap                                      100% 4097KB 682.8KB/s   00:06

me@&lt;my_laptop&gt;:~$ wireshark -r distant.cap
</screen>
    <para>La commande <command>scp</command> illustre le transfert du fichier
    de capture réseau via <acronym>SSH</acronym>. On peut effectuer la même
    opération à partir de Windoze avec l'outil
    <systemitem>WinSCP</systemitem>.</para>
    <para>Enfin, il est possible de lire le fichier de capture directement au
    lancement de l'analyseur réseau avec l'option <option>-r</option>.</para>
    </listitem>
    </varlistentry>
  </variablelist>
</sect1>

<sect1 xml:id='wireshark.lab.http'>
  <title>Travaux pratiques : navigation Web (HTTP)</title>

  <sect2 xml:id='wireshark.lab.http.protocols'>
    <title>Protocoles étudiés</title>

    <itemizedlist>
      <listitem>
      <para>Adressage matériel (<acronym>MAC</acronym>|Ethernet) et logique
      (<acronym>IP</acronym>).</para>
      </listitem>
      <listitem>
      <para>Requête et réponse du service de noms de domaines
      (<acronym>DNS</acronym>).</para>
      </listitem>
      <listitem>
      <para>Établissement, maintien et libération de connexion
      <acronym>TCP</acronym> : procédure en trois étapes, numéros de
      séquence et d'acquittement.</para>
      </listitem>
      <listitem>
      <para>Requête et réponse <acronym>HTTP</acronym>.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2 xml:id='wireshark.lab.http.procedure'>
    <title>Marche à suivre</title>

    <orderedlist>
      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer un navigateur Web et saisir une adresse de site
      (<acronym>URL</acronym>) de votre choix.</para>
      </listitem>
      <listitem>
      <para>Une fois la page complètement chargée, arrêter la capture.
      Sauvegarder un fichier de capture.</para>
      </listitem>
      <listitem>
      <para>Passer aux questions suivantes.</para>
      </listitem>
    </orderedlist>

    <para>Suivant le contexte de connexion, le volume d'information capturé
    varie énormément : connexion <acronym>DSL</acronym>, réseau local
    commuté ou non, multiplicité des protocoles réseau, etc. Il est cependant
    préférable d'effectuer la première capture sans aucune restriction
    <emphasis>à priori</emphasis> de façon à avoir une image exacte du trafic.
    Si l'information utile est vraiment noyée dans du «bruit», il est toujours
    possible de reprendre la capture avec un filtre ; voir <xref
    linkend='wireshark.capture'/>.</para>
  </sect2>

  <sect2 xml:id='wireshark.lab.http.questions'>
    <title>Analyse des protocoles</title>

    <para>Pour répondre aux questions suivantes, utiliser le résultat de la
    capture issue de l'étape précédente ou charger un fichier de
    capture.</para>

    <sect3 xml:id='wireshark.lab.http.questions.captured_protocols'>
      <title>Protocoles capturés</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les protocoles indiqués dans la colonne
	<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Confirmer que la capture contient bien les protocoles
	<acronym>DNS</acronym>, <acronym>TCP</acronym> et
	<acronym>HTTP</acronym>.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.http.questions.ethernet_frame'>
      <title>Trame Ethernet, paquet IP et datagramme UDP</title>

      <para>Analyser la trame correspondant au premier message
      <acronym>DNS</acronym> émis par le client Web.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les adresses (<acronym>MAC</acronym>|Ethernet) et
	<acronym>IP</acronym> du client ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quel est le contenu du champ type de la trame
	Ethernet ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quelles sont les adresses destination
	(<acronym>MAC</acronym>|Ethernet) et
	<acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>À quelles machines correspondent ces adresses ?</para>
	</question>
	</qandaentry>
      </qandaset>	

      <para>Analyser l'en-tête <acronym>IP</acronym> du premier message
      <acronym>DNS</acronym> émis par le client Web.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelle est la taille de l'en-tête ? Quelle est la longueur
	totale du paquet ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Repérer le champ «type de protocole» dans l'en-tête. Quel est le
	numéro et le type de protocole présent dans les données du
	paquet ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Analyser l'en-tête <acronym>UDP</acronym> du premier message
      <acronym>DNS</acronym> émis par le client Web.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les numéros de ports du client et du serveur ?
	Quelles sont les particularités de ces valeurs ? Quel est le
	protocole de couche application présent dans les données du
	message ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quelle est la valeur indiquée dans le champ longueur de l'en-tête
	<acronym>UDP</acronym> ? Est-ce qu'elle correspond à l'information
	donnée dans l'en-tête du paquet <acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Faire un croquis des piles de protocoles des couches physique à
      application pour le client et le serveur ; identifier les unités de
      données de protocoles (<acronym>PDUs</acronym>) et les communications de
      bout en bout.</para>
    </sect3>

    <sect3 xml:id='wireshark.lab.http.questions.dns_resolver'>
      <title>Service DNS</title>

      <para>Analyser le message de requête <acronym>DNS</acronym> émis par le
      client Web.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quel est le champ qui indique si le message est une requête ou
	une réponse ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quelle est l'information transportée dans le corps de la
	requête ? Identifier le type et la classe de la requête.</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quel est l'identificateur de transaction de la
	requête ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>On considère maintenant la réponse à la requête précédente.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelles devraient être les adresses
	(<acronym>MAC</acronym>|Ethernet) et <acronym>IP</acronym> de ce
	paquet ?</para>
	</question>
	<answer>
	<para>Vérifier que les adresses attendues sont présentes.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quelle est la taille du paquet <acronym>IP</acronym> ; du
	message <acronym>UDP</acronym> ? Cette taille est-elle plus
	importante que celle du paquet de requête ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Quel est l'identificateur de transaction de la réponse ?
	Est-ce qu'il correspond à la requête ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Combien de réponses sont disponibles dans le message de
	réponse ? Comparer les réponses et leurs valeurs
	<acronym>TTL</acronym> (<wordasword>Time-to-live</wordasword>).</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.http.questions.tcp_connect'>
      <title>Connexion TCP</title>

      <para>Identifier la trame qui correspond au premier segment
      <acronym>TCP</acronym> dans la procédure en trois étapes
      (<wordasword>three ways handshake</wordasword>) qui initie la connexion
      entre le client et le serveur <acronym>HTTP</acronym>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelles sont les adresses (<acronym>MAC</acronym>|Ethernet) et
	<acronym>IP</acronym> attendues pour cette trame ? Quels sont les
	valeurs des champs <option>type</option> et <option>protocole</option>
	respectivement attendus pour cette trame et ce paquet ?</para>
	</question>
	<answer>
	<para>Vérifier que ces champs et adresses correspondent.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Expliquer les valeurs des adresses destination
	(<acronym>MAC</acronym>|Ethernet) et <acronym>IP</acronym> ? À
	quels hôtes correspondent ces adresses ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Identifier les numéros de ports utilisés par le client. Pourquoi
	ces valeurs sont-elles utilisées ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la longueur du segment
	<acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence initial (<wordasword>Initial
	Sequence Number</wordasword> ou <acronym>ISN</acronym> émis par le
	client vers le serveur ? Quelle est la taille de fenêtre
	initiale ? Quelle est la taille maximale de segment
	(<wordasword>Maximum Segment Size</wordasword> ou
	<acronym>MSS</acronym>) ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Trouver la valeur hexadécimale de l'octet qui contient
	l'indicateur d'état <acronym>SYN</acronym> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Identifier la trame qui correspond au second segment
      <acronym>TCP</acronym> dans la procédure en trois étapes
      (<wordasword>three ways handshake</wordasword>).</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Combien de temps s'est écoulé entre la capture du premier et du
	second segment <acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Relever les valeurs des champs suivants de cette
	trame :</para>
	<itemizedlist>
	  <listitem>
	  <para>Adresses <acronym>MAC</acronym> source et destination de la
	  trame Ethernet.</para>
	  </listitem>
	  <listitem>
	  <para>Adresses source et destination du paquet
	  <acronym>IP</acronym>.</para>
	  </listitem>
	  <listitem>
	  <para>Numéros de séquence et d'acquittement du segment
	  <acronym>TCP</acronym>.</para>
	  </listitem>
	  <listitem>
	  <para>Valeurs des indicateurs d'état.</para>
	  </listitem>
	</itemizedlist>
	</question>
	<answer>
	<para>Vérifier que tout correspond aux valeurs attendues.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la longueur du segment
	<acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence initial (<wordasword>Initial
	Sequence Number</wordasword> ou <acronym>ISN</acronym> émis par le
	serveur vers le client ? Quelle est la taille de fenêtre
	initiale ? Quelle est la taille maximale de segment
	(<wordasword>Maximum Segment Size</wordasword> ou
	<acronym>MSS</acronym>) ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Identifier la trame qui correspond au dernier segment
      <acronym>TCP</acronym> dans la procédure en trois étapes
      (<wordasword>three ways handshake</wordasword>).</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Combien de temps s'est écoulé entre la capture du second et du
	troisième segment <acronym>TCP</acronym> ? Comparer cette valeur
	avec celle relevée entre le premier et le second segment et expliquer
	la différence.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Relever les valeurs des champs suivants de cette
	trame :</para>
	<itemizedlist>
	  <listitem>
	  <para>Numéros de séquence et d'acquittement du segment
	  <acronym>TCP</acronym>.</para>
	  </listitem>
	  <listitem>
	  <para>Valeurs des indicateurs d'état.</para>
	  </listitem>
	  <listitem>
	  <para>Tailles de fenêtre.</para>
	  </listitem>
	</itemizedlist>
	</question>
	<answer>
	<para>Vérifier que tout correspond aux valeurs attendues.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelle est la longueur du segment
	<acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.http.questions.http_get'>
      <title>Requête HTTP GET</title>

      <para>Identifier la trame qui correspond au message
      <acronym>HTTP</acronym> <literal>GET</literal>.</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Quelles sont les valeurs des numéros de séquence et d'acquittement
	de l'en-tête <acronym>TCP</acronym> ?.</para>
	</question>
	<answer>
	<para>Vérifier que tout correspond aux valeurs attendues.</para>
	</answer>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quels sont les indicateurs d'état actifs de l'en-tête
	<acronym>TCP</acronym> ? Expliquer pourquoi.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quelles sont les longueurs de l'en-tête et de la «charge» du
	message <acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>On considère maintenant le contenu du message
      <acronym>HTTP</acronym> <literal>GET</literal>.</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Comparer le texte décodé dans la <link
	linkend='wireshark.protocollist'>fenêtre d'affichage de la pile de
	protocoles</link> avec le contenu de la <link
	linkend='wireshark.hexa'>fenêtre d'affichage brut</link>.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Compter le nombre d'octets du message et vérifier que ce nombre
	correspond au champ longueur de l'en-tête
	<acronym>TCP</acronym>.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le prochain numéro de séquence attendu dans le message
	suivant émis par le serveur <acronym>HTTP</acronym> ?</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.http.questions.http_answer'>
      <title>Réponse HTTP</title>

      <qandaset>
	<qandaentry>
	<question>
	<para>Combien de temps s'est écoulé entre la capture du message
	<literal>GET</literal> et la capture du message de réponse
	correspondant ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Déterminer si le serveur répond avec un message
	<acronym>HTTP</acronym> ou un segment <acronym>TCP</acronym>
	<literal>ACK</literal> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le numéro de séquence émis par le serveur
	<acronym>HTTP</acronym> ? Est-ce qu'il correspond à la valeur
	attendue ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>On considère maintenant l'en-tête du message réponse
      <acronym>HTTP</acronym>.</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Quelle est la longueur de la «charge» indiquée dans l'en-tête
	<acronym>TCP</acronym> ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quels sont les indicateurs d'état actifs de l'en-tête
	<acronym>TCP</acronym> ? Expliquer pourquoi.</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Quel est le prochain numéro de séquence attendu dans le message
	suivant émis par le client ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>On considère maintenant le corps du message réponse
      <acronym>HTTP</acronym>.</para>

      <qandaset>
	<qandaentry>
	<question>
	<para>Quel est le code dans le message de réponse ?</para>
	</question>
	</qandaentry>

	<qandaentry>
	<question>
	<para>Sélectionner ce code avec la souris dans la <link
	linkend='wireshark.protocollist'>fenêtre d'affichage de la pile de
	protocoles</link> et comparer avec ce qui est affiché sur la page du
	navigateur Web.</para>
	</question>
	<answer>
	<para>Cette opération revient à suivre la démarche présentée dans la
	<xref linkend='wireshark.tcpstream'/>.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id='wireshark.lab.icmp'>
  <title>Travaux pratiques : messages de contrôle internet (ICMP)</title>

  <sect2 xml:id='wireshark.lab.icmp.protocols'>
    <title>Protocoles et outils étudiés</title>

    <itemizedlist>
      <listitem>
      <para><wordasword>Internet Control Message Protocol</wordasword> ou
      <acronym>ICMP</acronym> ; messages de type :
      <literal>Echo</literal>, <literal>Echo Reply</literal> et <literal>Time
      Exceeded</literal>.</para>
      </listitem>
      <listitem>
      <para><wordasword>Internet Protocol</wordasword> ou
      <acronym>IP</acronym> ; champ de l'en-tête
      <acronym>IP</acronym> : <literal>Time to Live</literal>.</para>
      </listitem>
      <listitem>
      <para>Commande <command>ping</command>.</para>
      </listitem>
      <listitem>
      <para>Commandes <command>traceroute</command> et
      <command>tcptraceroute</command>.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.procedure'>
    <title>Marche à suivre</title>

    <orderedlist>
      <title>Commande <command>ping</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>ping -c10 www.phrack.org</userinput>. L'option
      <option>-c10</option> limite le nombre de requêtes
      <acronym>ICMP</acronym> à 10. Bien sûr, le choix de l'adresse à contacter
      est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>

    <orderedlist>
      <title>Commande <command>traceroute</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>traceroute www.phrack.org</userinput>. Bien sûr, le choix de
      l'adresse à contacter est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>

    <para>La plage de ports <acronym>UDP</acronym> utilisée par défaut par la
    commande <command>traceroute</command> est de plus en plus fréquemment
    bloquée par les équipements d'interconnexion. Il est alors utile
    d'envisager l'emploi de la commande <command>tcptraceroute</command> avec
    laquelle on peut fixer les ports source et destination.</para>

    <orderedlist>
      <title>Commande <command>tcptraceroute</command></title>

      <listitem>
      <para>Lancer <citetitle>Wireshark</citetitle>.</para>
      </listitem>
      <listitem>
      <para>Lancer la capture des trames sans restrictions d'adresses, de
      protocoles ou de volume.</para>
      </listitem>
      <listitem>
      <para>Lancer une console et taper une commande du type
      <userinput>tcptraceroute -p 1024 www.phrack.org 80</userinput>.
      Bien sûr, le choix de l'adresse à contacter est totalement libre.</para>
      </listitem>
      <listitem>
      <para>Arrêter la capture lorsque l'invite de commande réapparaît à la
      console.</para>
      </listitem>
      <listitem>
      <para>Sauvegarder le fichier de capture.</para>
      </listitem>
    </orderedlist>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.ping.questions'>
    <title>Analyse avec <command>ping</command></title>

    <para>Pour répondre aux questions suivantes, utiliser le résultat de la
    capture issue de l'étape précédente ou charger un fichier de
    capture.</para>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.captured_protocols'>
      <title>Protocoles capturés</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les protocoles indiqués dans la colonne
	<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Il est probable que les paquets <acronym>ICMP</acronym> soient
	précédés d'un jeu de question/réponse <acronym>DNS</acronym>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Relever l'adresse <acronym>IP</acronym> renvoyée avec la réponse
	<acronym>DNS</acronym>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.echo_request'>
      <title>Message ICMP «Echo Request»</title>

      <para>Étude du paquet <acronym>IP</acronym> qui correspond au premier
      message <acronym>ICMP</acronym> <literal>Echo Request</literal>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelle est l'adresse <acronym>IP</acronym> destination du
	paquet ? Quelle est la valeur du champ <literal>Protocol
	Type</literal> ? Quelle est la valeur du champ <literal>Time to
	Live</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ? Quel
	est l'identificateur de message ? Quel est le numéro de
	séquence ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Sélectionner à la souris les octets de données du message de
	requête. Comparer ces données avec celles affichées dans la <link
	linkend='wireshark.hexa'>fenêtre d'affichage brut</link>.</para> 
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.echo_reply'>
      <title>Message ICMP «Echo Reply»</title>

      <para>Étude du paquet <acronym>IP</acronym> qui correspond au premier
      message <acronym>ICMP</acronym> <literal>Echo Reply</literal>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelle sont les adresses <acronym>IP</acronym> source et
	destination du paquet ? Quelle est la valeur du champ
	<literal>Protocol Type</literal> ? Quelle est la valeur du champ
	<literal>Time to Live</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ?
	Comparer l'identificateur de message et le numéro de séquence du
	message de réponse avec les valeurs du message de requête.</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Sélectionner à la souris les octets de données du message de
	requête. Comparer ces données avec celles affichées dans le message de
	requête.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.ping.questions.icmp_other'>
      <title>Messages ICMP restants</title>

      <para>Reprendre les 2 points précédents pour les messages
      <acronym>ICMP</acronym> <literal>Echo Request</literal> et <literal>Echo
      Reply</literal> restants.</para>

      <qandaset>
        <qandaentry>
	<question>
	<para>Comment les champs d'identification et de numéro de séquence
	évoluent dans le temps ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Est-ce que les séquences de données des requêtes et des réponses
	changent ?</para>
	</question>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Calculer l'écart de temps entre l'émission de chaque message
	<literal>Echo Request</literal> et la réception de chaque message
	<literal>Echo Reply</literal>. Comparer les résultats avec les valeurs
	maximum, moyenne et minium fournies par la commande
	<command>ping</command>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>
  </sect2>

  <sect2 xml:id='wireshark.lab.icmp.traceroute.questions'>
    <title>Analyse avec <command>(tcp)traceroute</command></title>

    <para>Pour répondre aux questions suivantes, utiliser le résultat de la
    capture issue de l'étape précédente ou charger un fichier de
    capture.</para>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.captured_protocols'>
      <title>Protocoles capturés</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quels sont les protocoles indiqués dans la colonne
	<guisubmenu>Protocol</guisubmenu> de la fenêtre de liste des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Il est probable que les paquets <acronym>ICMP</acronym> soient
	précédés d'un jeu de question/réponse <acronym>DNS</acronym>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Relever l'adresse <acronym>IP</acronym> renvoyée avec la réponse
	<acronym>DNS</acronym>.</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.udp_message'>
      <title>Message UDP</title>

      <qandaset xml:id='traceroute.udp'>
        <qandaentry>
	<question>
	<para>Quelle est l'adresse <acronym>IP</acronym> destination du	premier
	paquet contenant le message <acronym>UDP</acronym> ? Quelles sont
	les valeurs des champs <literal>Protocol Type</literal> et
	<literal>Time to Live</literal> ?</para>
	</question>
	<answer>
	<para>Comparer l'adresse <acronym>IP</acronym> destination relevée avec
	celle de la réponse <acronym>DNS</acronym>. Noter les valeurs
	caractéristiques de l'en-tête <acronym>IP</acronym> en vue d'une
	utilisation <link
	linkend='traceroute.ttl-exceeded'>ultérieure</link>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Combien d'octets de données sont présents dans ce message de
	requête ?</para>
	</question>
	<answer>
	<para>Noter la séquence de caractères présente dans la troisième
	fenêtre.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.time_exceeded'>
      <title>Message ICMP «Time Exceeded»</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Quelles sont les adresses <acronym>IP</acronym> source et
	destination du paquet de la première réponse <acronym>ICMP</acronym>
	<literal>Time Exceeded</literal> ?</para>
	</question>
	</qandaentry>
      </qandaset>

      <para>Étude du message <acronym>ICMP</acronym>.</para>

      <qandaset xml:id='traceroute.ttl-exceeded'>
        <qandaentry>
	<question>
	<para>Quel est le type de message <acronym>ICMP</acronym> ?</para>
	</question>
	<answer>
	<para>Les champs <literal>Type</literal>, <literal>Code</literal> et
	<literal>Checksum</literal> sont suivis par plusieurs octets à zéro
	puis par l'en-tête <acronym>IP</acronym> du message
	<acronym>ICMP</acronym> <literal>Echo Request</literal>. Comparer les
	valeurs caractéristiques de cet en-tête avec celles notées <link
	linkend='traceroute.udp'>ci-avant</link>.</para>
	</answer>
	</qandaentry>

        <qandaentry>
	<question>
	<para>Est-ce que le message <acronym>ICMP</acronym> contient de
	nouveaux octets de données ?</para>
	</question>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.ttl'>
      <title>Evolution du champ TTL</title>

      <qandaset>
        <qandaentry>
	<question>
	<para>Combien de messages <acronym>UDP</acronym> sont émis avec la même
	valeur de champ <literal>TTL</literal> dans l'en-tête de paquet
	<acronym>IP</acronym> ?</para>
	</question>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Quelles sont les adresses <acronym>IP</acronym> source des
	paquets <acronym>ICMP</acronym> <literal>Time
	Exceeded</literal> ?</para>
	</question>
	<answer>
	<para>Comparer ces adresses avec celles données lors de l'exécution de
	la commande <command>traceroute</command>.</para>
	</answer>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Quel est le type du message <acronym>ICMP</acronym> reçu lorsque
	l'hôte destinataire est atteint ?</para>
	</question>
	</qandaentry>
	
        <qandaentry>
	<question>
	<para>Comment calculer les temps affichés par la commande
	<command>traceroute</command> à partir des valeurs données dans la
	colonne <literal>Time</literal> de la fenêtre des trames
	capturées ?</para>
	</question>
	<answer>
	<para>Utiliser les pages de manuels de la commande
	<command>traceroute</command> pour obtenir la signification des
	différentes valeurs de temps pour atteindre une destination.</para>
	</answer>
	</qandaentry>
      </qandaset>
    </sect3>

    <sect3 xml:id='wireshark.lab.icmp.traceroute.questions.tcptraceroute'>
      <title>Variantes</title>

      <para>Il est possible de reprendre les questions ci-dessus en utilisant
      différentes options des commandes <command>traceroute</command> et|ou
      <command>tcptraceroute</command>.</para>

      <itemizedlist>
        <listitem>
	<para>Analyse uniquement à base de messages <acronym>ICMP</acronym>
	avec l'option <option>-I</option> : <userinput>traceroute -I
	www.phrack.org</userinput>.</para>
	</listitem>
	<listitem>
	<para>Analyse à base de segments <acronym>TCP</acronym> en précisant le
	numéro de port visé : <userinput>tcptraceroute www.phrack.org
	80</userinput>.</para>
	<para>Cette dernière variante est très utile pour vérifier si un
	service est ouvert ou non.</para>
	</listitem>
      </itemizedlist>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id='wireshark.reference'>
  <title>Documents de référence</title>

  <variablelist>
    <varlistentry xml:id='guide'>
      <term>Guide de l'utilisateur</term>
      <listitem>
      <para>Le &url.wireshark.user_guide; est la référence la plus complète sur
      l'utilisation de notre analyseur de trafic favori !</para>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='protocols'>
      <term>Protocoles</term>
      <listitem>
      <itemizedlist>
        <listitem>
	<para>Le fichier <acronym>PDF</acronym>
	&url.sans.pocket_ref_guide;  est une «antisèche» sur les champs
	des en-têtes des protocoles essentiels ; un document
	<emphasis>indispensable</emphasis> pour la pratique de l'analyse
	réseau.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
    <varlistentry xml:id='otherlabs'>
      <term>Travaux pratiques</term>
      <listitem>
      <itemizedlist>
        <listitem>
	<para>Le support &url.config.interface.lan;  présente les opérations
	de configuration d'une interface réseau et propose une exploitation des
	protocoles <acronym>TCP/IP</acronym> et <acronym>ICMP</acronym> sans
	recours à un analyseur réseau.</para>
	</listitem>
        <listitem>
	<para>Le chapitre &url.searchenterpriselinux;  est un extrait de
	livre consacré à la version antérieure de l'analyseur de trafic
	réseau.</para>
	</listitem>
        <listitem>
	<para>Le site &url.otherlabs.ethereal;  présente d'autres travaux
	pratiques basés sur <citetitle>Ethereal</citetitle>, la version
	antérieure de l'analyseur de trafic réseau.</para>
	</listitem>
      </itemizedlist>
      </listitem>
    </varlistentry>
  </variablelist>
</sect1>
</article>
