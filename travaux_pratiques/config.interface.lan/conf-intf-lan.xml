<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
        "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY phl   	     	   	SYSTEM "author.xml">
<!ENTITY legal 			SYSTEM "legal.xml">

<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.securing-debian-howto
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.debian.org/doc/manuals/securing-debian-howto/ch4.fr.html#s-network-secure">
   <citetitle>«Sécurations des accès réseau» du Manuel de sécurisation de Debian</citetitle></link>'>

<!ENTITY url.ipsysctl.tutorial
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ipsysctl-tutorial.frozentux.net/ipsysctl-tutorial.html">
   <citetitle>Ipsysctl tutorial</citetitle></link>'>
]>

<article xml:lang='fr' xml:id='conf-intf-lan'>
<info>
  <title>Configuration d'une interface réseau Ethernet</title>
  &phl;
  <abstract>
    <para>Ce support de travaux pratiques traite de la configuration d'une
    interface réseau Ethernet sur un système GNU/Linux. Les manipulations
    présentées suivent la modélisation réseau en remontant du niveau physique
    jusqu'à la validation des services de la couche application. Les questions
    cherchent à illustrer les relations entre les différents formats
    d'adressage utilisés à chaque niveau ainsi que les protocoles utilisés pour
    la «correspondance» entre ces formats.</para>
  </abstract>

  <keywordset>
    <keyword>ip</keyword>
    <keyword>iproute2</keyword>
    <keyword>host</keyword>
    <keyword>dig</keyword>
    <keyword>interface</keyword>
    <keyword>ping</keyword>
    <keyword>sysctl</keyword>
  </keywordset>
</info>

<sect1 xml:id='conf-intf-lan.legal.meta'>
  &legal;
  <bridgehead xml:id='conf-intf-lan.meta' renderas='sect2'>Méta-information</bridgehead>
    
  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="https://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="https://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>

  <para>Toutes les commandes utilisées dans ce document ne sont pas spécifiques
  à une version particulière des systèmes UNIX ou GNU/Linux. C'est la
  distribution <citetitle>Debian GNU/Linux</citetitle> qui est utilisée
  pour les tests présentés. Voici une liste des principaux paquets contenant
  les commandes utilisées :</para>

  <itemizedlist>
    <listitem>
    <para><application>ethtool</application> - display or change Ethernet device settings</para>
    </listitem>
    <listitem>
    <para><application>iproute2</application> - networking and traffic control tools</para>
    </listitem>
    <listitem>
    <para><application>ifupdown</application> - High level tools to configure network interfaces</para>
    </listitem>
  </itemizedlist>

  <bridgehead xml:id='conf-intf-lan.convtypo' renderas='sect2'>Conventions
  typographiques</bridgehead>

  <para>Tous les exemples d'exécution des commandes sont précédés d'une invite
  utilisateur ou <wordasword>prompt</wordasword> spécifique au niveau des
  droits utilisateurs nécessaires sur le système.</para>

  <itemizedlist>
    <listitem>
    <para>Toute commande précédée de l'invite <prompt>$</prompt> ne nécessite
    aucun privilège particulier et peut être utilisée au niveau utilisateur
    simple.</para>
    </listitem>
    <listitem>
    <para>Toute commande précédée de l'invite <prompt>#</prompt> nécessite les
    privilèges du super-utilisateur. Ces privilèges peuvent être délégués à
    l'aide de <application>sudo</application>.</para>
    </listitem>
  </itemizedlist>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.physical-layer'>
<title>Identifier les ressources matérielles</title>
<subtitle>Couche physique</subtitle>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
  <para>Avant de pouvoir configurer une interface, il faut que le pilote de
  périphérique correspondant ait été chargé en mémoire. Comme une interface
  réseau est un dispositif matériel, c'est au niveau du noyau Linux que
  l'opération doit s'effectuer. Soit le pilote d'interface a été inclus dans la
  partie monolithique du noyau soit il est chargé en mémoire sous forme de
  module. C'est cette dernière solution qui est le plus souvent retenue. Un
  module peut être chargé ou déchargé à volonté sans avoir à redémarrer la
  machine. De plus, les fonctions de reconnaissance automatique des composants
  périphériques permettent de ne charger que les modules correspondant aux
  composants effectivement présents sur le système.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l1.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l1.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.ident-periph' renderas='sect2'>Comment
  identifier un périphérique Ethernet ?</bridgehead>

  <para>Il existe une grande variété de contrôleurs réseau Ethernet. À chaque
  composant correspond un pilote logiciel spécifique. Qu'il s'agisse d'une
  carte additionnelle ou d'un composant intégré sur carte mère, le
  contrôleur peut être connecté via différents bus. Les bus
  <acronym>PCI</acronym> et <acronym>USB</acronym> sont les plus fréquemment
  utilisés. Voici deux exemples :</para>

  <variablelist>
    <varlistentry xml:id='ident-pci'>
    <term>Contrôleur Ethernet sur bus PCI</term>
    <listitem>
    <para>Sur une architecture <trademark>Intel</trademark>
    <acronym>x86_64</acronym>, un composant Ethernet est nécessairement relié
    au bus <acronym>PCI</acronym>. La commande <command>lspci</command> du
    paquet <application>pciutils</application> donne la liste des
    périphériques ainsi que les modules du noyau Linux associés à ces
    périphériques.</para>

<screen><prompt>$</prompt> lspci -v
&lt;snip/&gt;
07:00.0 <emphasis>Ethernet controller</emphasis>: Intel Corporation 82576 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation Gigabit ET Quad Port Server Adapter
        Flags: bus master, fast devsel, latency 0, IRQ 55
        Memory at ddf40000 (32-bit, non-prefetchable) [size=128K]
        Memory at de000000 (32-bit, non-prefetchable) [size=4M]
        I/O ports at dcc0 [size=32]
        Memory at ddf38000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &lt;access denied>
        <emphasis>Kernel driver in use: igb</emphasis></screen>

    <para>Le module du noyau Linux nommé <option>igb</option> est chargé en
    mémoire automatiquement lors de l'initialisation du système. Il est présent
    dans la liste donnée par la commande <command>lsmod</command>.</para>

<screen><prompt>$</prompt> lsmod | grep igb
<emphasis>igb                   138336  0 </emphasis>
i2c_algo_bit           12751  1 igb
i2c_core               24092  2 igb,i2c_algo_bit
dca                    13168  2 igb,ioatdma
ptp                    17460  1 igb</screen>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='ident-usb'>
    <term>Contrôleur Ethernet sur bus USB</term>
    <listitem>
    <para>Sur une architecture <citetitle>Raspberry Pi</citetitle>, le
    composant Ethernet est relié au bus <acronym>USB</acronym> et c'est la
    commande <command>dmesg</command> qui permet d'obtenir l'identification du
    composant.</para>

<screen><prompt>$</prompt> dmesg | grep -i Ethernet
[    3.114563] smsc95xx 1-1.1:1.0 eth0: register 'smsc95xx' at usb-bcm2708_usb-1.1, \
               <emphasis>smsc95xx USB 2.0 Ethernet</emphasis>, b8:27:eb:ea:29:72</screen>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='ident-sys'>
    <term>Répertoire /sys/</term>
    <listitem>
    <para>Pour compléter les informations sur les interfaces réseau, il est
    possible de parcourir l'arborescence <filename
    class='directory'>/sys/</filename>. Ainsi, dans le cas d'une architecture
    <citetitle>Raspberry Pi</citetitle>, on obtient les éléments suivants
    :</para>

<screen><prompt>$</prompt> ls -go /sys/class/net/eth0/device/driver/<co xml:id='ident-sys.eth0'/>
total 0
lrwxrwxrwx 1    0 janv. 27 09:18 1-1.1:1.0 -> \
             ../../../../devices/platform/bcm2708_usb/usb1/1-1/1-1.1/1-1.1:1.0<co xml:id='ident-sys.bus'/>
--w------- 1 4096 janv. 27 09:18 bind
lrwxrwxrwx 1    0 janv. 27 09:18 module -> \
             ../../../../module/smsc95xx<co xml:id='ident-sys.module'/>
-rw-r--r-- 1 4096 janv. 27 09:18 new_id
-rw-r--r-- 1 4096 janv. 27 09:18 remove_id
--w------- 1 4096 janv. 27 09:18 uevent
--w------- 1 4096 janv. 27 09:18 unbind</screen>

    <calloutlist>
    <callout arearefs='ident-sys.eth0'>
    <para>La dénomination <systemitem>eth0</systemitem> désigne la première
    interface Ethernet présente sur le système.</para>
    </callout>

    <callout arearefs='ident-sys.bus'>
    <para>Dans le répertoire relatif à l'interface, on repère la position du
    contrôleur Ethernet sur le bus <acronym>USB</acronym>.</para>
    </callout>

    <callout arearefs='ident-sys.module'>
    <para>Dans le même répertoire, on identifie aussi le module de pilotage du
    contrôleur.</para>
    </callout>
    </calloutlist>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour résumer, les outils utiles pour l'identification des composants
  réseau et des modules logiciels assciés sont : <command>lspci</command>,
  <command>dmesg</command>, <command>lsmod</command> et le parcours de
  l'arborescence <filename class='directory'>/sys/</filename>.</para> 

  <bridgehead xml:id='conf-intf-lan.ident-link' renderas='sect2'>Comment
  visualiser l'état du lien réseau ?</bridgehead>

  <para>Même avec une configuration correcte de l'interface, il est possible
  que les communications soient bloquées si le lien physique entre l'hôte et
  l'équipement réseau n'est pas actif. Sur les liaisons utilisant des câbles en
  paires torsadées cuivre, on peut visualiser l'état du lien à l'aide de la
  commande <command>ethtool</command> fournie avec le paquet du même
  nom. En reprenant les mêmes exemples que ci-dessus, on retrouve les
  informations suivantes :</para>

  <variablelist>
    <varlistentry xml:id='link-intel'>
    <term>Interface <trademark>Intel</trademark> Gbps</term>
    <listitem>
<screen><prompt>#</prompt>ethtool eth0
Settings for eth0:
        Supported ports: [ TP ]
        Supported link modes:   10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
                                1000baseT/Full <co xml:id='intel-mii.cap'/>
        Supported pause frame use: Symmetric
        Supports auto-negotiation: Yes
        Advertised link modes:  10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
                                1000baseT/Full 
        Advertised pause frame use: Symmetric
        Advertised auto-negotiation: Yes
        Speed: 1000Mb/s <co xml:id='intel-mii.link'/>
        Duplex: Full
        Port: Twisted Pair <co xml:id='intel-mii.tp'/>
        PHYAD: 1
        Transceiver: internal
        Auto-negotiation: on <co xml:id='intel-mii.neg'/>
        MDI-X: off (auto)
        Supports Wake-on: pumbg
        Wake-on: g
        Current message level: 0x00000007 (7)
                               drv probe link
        Link detected: yes</screen>

    <calloutlist>
    <callout arearefs='intel-mii.cap'>
    <para>Cette liste correspond aux débits possibles sur cette interface :
    1000Mbps en mode Full-Duplex, 100Mbps en mode Full-Duplex, 100Mbps en mode
    Half-Duplex, 10Mbps en mode Full-Duplex et 10Mbps en mode
    Half-Duplex.</para>
    </callout>
    <callout arearefs='intel-mii.link'>
    <para>Le lien entre l'interface <systemitem>eth0</systemitem> et
    l'équipement réseau est actif et le débit négocié est de 1000Mbps en mode
    Full-Duplex.</para>
    </callout>
    <callout arearefs='intel-mii.tp'>
    <para>Le câble connecté à cette interface est en paire cuivre torsadée ou
    <wordasword>twisted pair</wordasword>.</para>
    </callout>
    <callout arearefs='intel-mii.neg'>
    <para>Les résultats précédents ont été obtenus par auto négociation entre
    le contrôleur réseau et le commutateur auquel l'interface Ethernet est
    connectée.</para> 
    </callout>
    </calloutlist>
    </listitem>
    </varlistentry>

    <varlistentry xml:id='rpi-link'>
    <term>Interface <citetitle>Raspberry Pi</citetitle> 100Mbps</term>
    <listitem>
<screen><prompt>$</prompt> sudo ethtool eth0
Settings for eth0:
        Supported ports: [ TP MII ]
        Supported link modes:   10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full
        Supported pause frame use: No
        Supports auto-negotiation: Yes
        Advertised link modes:  10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
        Advertised pause frame use: Symmetric Receive-only
        Advertised auto-negotiation: Yes
        Link partner advertised link modes:  10baseT/Half 10baseT/Full 
                                             100baseT/Half 100baseT/Full 
        Link partner advertised pause frame use: Symmetric
        Link partner advertised auto-negotiation: Yes
        Speed: 100Mb/s
        Duplex: Full
        Port: MII
        PHYAD: 1
        Transceiver: internal
        Auto-negotiation: on
        Supports Wake-on: pumbag
        Wake-on: d
        Current message level: 0x00000007 (7)
                               drv probe link
        Link detected: yes</screen>

    <para>Relativement à la copie d'écran ci-dessus, le débit passe à 100Mb/s.
    C'est le principal changement observé.</para>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour aller plus loin dans l'étude des caractéristiques techniques des
  réseaux locaux, il est conseillé de lire l'article &url.ethernet;.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.link-layer'>
<title>Lire et configurer l'état d'une interface</title>
<subtitle>Couche liaison de données</subtitle>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Au niveau liaison de données de la modélisation, l'unité de donnée
    manipulée est la trame. Dans le cas de la technologie Ethernet, la trame
    contient les adresses <acronym>MAC</acronym> (<wordasword>media access
    control address</wordasword>) des hôtes source et destination du réseau de
    diffusion (<acronym>LAN</acronym>). À ce niveau, il est possible de
    configurer plusieurs fonctions. Vis-à-vis de la couche physique, on peut
    activer ou désactiver une interface. Vis-à-vis de la couche réseau, on peut
    définir la quantité de données à encapsuler dans une trame. C'est aussi à
    ce niveau que l'on définit les champs du standard <citetitle>IEEE
    802.1q</citetitle>. Cette dernière fonction sort du cadre de ce document
    (voir l'article &url.inter-vlan-routing;). Les fonctions relatives à la
    gestion de mise en file d'attente des paquets issus de la couche réseau
    sortent aussi du cadre de ce document (voir &url.lartc.fr;).</para>

    <para>Dans cette section, le principal outil utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l2.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l2.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.link-layer.status' renderas='sect2'>Comment
  visualiser l'état d'une interface réseau ?</bridgehead>

  <para>Le simple fait de consulter l'état d'une interface fournit une grande
  quantité d'informations.</para>

<screen><prompt>$</prompt> ip link ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP><co xml:id='eth0.status'/> mtu 1500<co xml:id='eth0.mtu'/> qdisc pfifo_fast state UP \
                                              mode DEFAULT qlen 1000
    link/ether b8:27:eb:ea:29:72<co xml:id='eth0.mac'/> brd ff:ff:ff:ff:ff:ff</screen>

  <calloutlist>
    <callout arearefs='eth0.status'>
    <para>Les indicateurs d'état désignent les fonctions actives au niveau de
    l'interface.</para>
    </callout>

    <callout arearefs='eth0.mtu'>
    <para>L'acronyme <acronym>MTU</acronym> signifie <wordasword>Maximum
    Transmission Unit</wordasword>. La valeur <option>1500</option> correspond
    à la quantité maximum d'octets transmis de la couche réseau à la couche
    liaison de données sans fragmentation.</para>
    </callout>

    <callout arearefs='eth0.mac'>
    <para>L'adresse <acronym>MAC</acronym> de l'interface joue un rôle
    essentiel. C'est cette adresse qui identifie l'hôte dans le réseau local
    (<acronym>LAN</acronym>). Cette adresse unique respecte un format bien
    particulier : <acronym>EUI-48</acronym>. Voir
    &url.inter-vlan-routing-mac-types;.</para>
    </callout>
  </calloutlist>

<table xml:id='conf-intf-lan.link-layer.status.table' pgwide="1" frame="all">
  <title>Indicateurs d'état d'une interface Ethernet</title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="4*"/>
  <thead>
    <row>
      <entry>Indicateur</entry>
      <entry>Description</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry><literal>BROADCAST</literal></entry>
      <entry>L'interface peut émettre du trafic à destination de tous les hôtes
      du réseau local.</entry>
    </row>
    <row>
      <entry><literal>MULTICAST</literal></entry>
      <entry>L'interface peut émettre et recevoir du trafic de type
      multidiffusion.</entry>
    </row>
    <row>
      <entry><literal>UP</literal></entry>
      <entry>L'interface est active.</entry>
    </row>
    <row>
      <entry><literal>LOWER_UP</literal></entry>
      <entry>Un «câble» est correctement connecté à l'interface.</entry>
    </row>
    <row>
      <entry><literal>PROMISC</literal></entry>
      <entry>L'interface traite tout le trafic reçu et le transmet aux couches
      supérieures du sous-système réseau. Ce traitement inclut les trames dont
      l'adresse <acronym>MAC</acronym> destination est différente de celle de
      l'interface.</entry>
    </row>
    <row>
      <entry><literal>ALLMULTI</literal></entry>
      <entry>L'interface traite tout le trafic de multidiffusion reçu et le
      transmet aux couches supérieures. Ce mode est utile sur un système qui
      route le trafic de multidiffusion.</entry>
    </row>
  </tbody>
  </tgroup>
</table>

  <bridgehead xml:id='conf-intf-lan.link-layer.statistics' renderas='sect2'>Comment
  visualiser les statistiques d'une interface réseau ?</bridgehead>

  <para>En cas de problème de transmission, il est essentiel de connaître le
  nombre d'erreurs comptabilisé par le composant Ethernet ainsi que le nombre
  total de paquets émis ou reçus. Voici un exemple :</para>

<screen><prompt>$</prompt> ip -s link ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP \
                                              mode DEFAULT group default qlen 1000
    link/ether 00:1e:c9:f6:a2:cd brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    3535504061 4585598  0       0       0       43709  
    TX: bytes  packets  errors  dropped carrier collsns 
    3066244859 4103684  0       0       0       0</screen>

  <para>Dans le cas d'une interface Ethernet filaire, les compteurs d'erreurs,
  de trames abandonnées et de collisions doivent impérativement rester à 0. En
  effet, une connexion Ethernet filaire en cuivre ou en fibre optique
  fonctionne normalement en <wordasword>full duplex</wordasword> ; c'est à dire
  que l'on dispose d'un premier média de transmission réservé pour
  l'émission et d'un second média réservé pour la réception.</para>

  <bridgehead xml:id='conf-intf-lan.link-layer.set' renderas='sect2'>Comment
  activer/désactiver une interface réseau ?</bridgehead>

  <para>Ces opérations peuvent s'effectuer à deux niveaux bien distincts :
  interface et/ou système.</para>

  <para>Au niveau système, les scripts <command>ifup</command> et
  <command>ifdown</command> du paquet <application>ifupdown</application>
  utilisent les paramètres de configuration des interfaces donnés dans le
  fichier <filename>/etc/network/interfaces</filename> lors de l'activation ou
  la désactivation. Si une interface est paramétrée pour utiliser le client
  <acronym>DHCP</acronym> par exemple, les scripts se chargent du lancement et
  de l'arrêt du programme <application>dhclient</application>.</para>

  <para>À l'inverse, les manipulations au niveau interface ne tiennent aucun
  compte du mode de configuration antérieur. L'exécution des outils de
  configuration dans l'espace utilisateur peut se poursuivre alors que
  l'interface associée est inactive. Une telle situation peut conduire à des
  problèmes de fonctionnement du système ! Il est donc important de recenser
  les fonctions associées à une interface avant de se lancer dans les
  manipulations directes d'interfaces.</para>

  <variablelist>
    <varlistentry>
    <term>Désactivation au niveau interface</term>
    <listitem>
<screen><prompt>#</prompt> ip link set dev eth0 down

<prompt>#</prompt> ip addr ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop <emphasis>state DOWN</emphasis> \
                                  group default qlen 1000
    link/ether ba:ad:00:ca:fe:b9 brd ff:ff:ff:ff:ff:ff</screen>

    <warning>
    <para>La désactivation d'une interface entraîne la perte des routes vers
    les réseaux <acronym>IP</acronym> qui dépendent de ce lien.</para>
    </warning>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Désactivation au niveau système</term>
    <listitem>
<screen><prompt>#</prompt> ifdown eth0</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Activation au niveau interface</term>
    <listitem>
<screen><prompt>#</prompt> ip link set dev eth0 up

<prompt>#</prompt> ip addr ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast <emphasis>state UP</emphasis> \
                                              group default qlen 1000
    link/ether ba:ad:00:ca:fe:b9 brd ff:ff:ff:ff:ff:ff</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Activation au niveau système</term>
    <listitem>
<screen><prompt>#</prompt> ifup eth0</screen>
    </listitem>
    </varlistentry>
  </variablelist>

  <bridgehead xml:id='conf-intf-lan.link-layer.mac' renderas='sect2'>Comment
  changer l'adresse MAC d'une interface réseau ?</bridgehead>

  <para>Parmi les nombreuses manipulations possibles avec la commande
  <command>ip link</command>, il est possible de changer l'adresse
  <acronym>MAC</acronym> d'une interface. Voici un exemple.</para>

<screen><prompt>#</prompt> ip link set dev eth0 down

<prompt>#</prompt> ip link set address de:ad:be:ef:00:01 dev eth0

<prompt>#</prompt> ip link ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT \
                                  group default qlen 1000
    link/ether de:ad:be:ef:00:01 brd ff:ff:ff:ff:ff:ff

<prompt>#</prompt> ip link set dev eth0 up</screen>

	<para>Pour aller plus loin dans les manipulations au niveau liaison de
		données, la consultation des pages de manuels est un excellent point de
		départ : <userinput><prompt>$</prompt> man ip-link</userinput>.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.arp'>
<title>Reconnaître le voisinage réseau</title>
<subtitle>Couches liaison de données et réseau</subtitle>

<para>
<informaltable frame='none' pgwide='1'>
	<tgroup cols='2' align='left' colsep='0' rowsep='0'>
	<colspec colwidth='5*'/>
	<colspec colwidth='320px'/>
	<tbody>
	<row>
	<entry valign='top'>
	<para>Dans un réseau <acronym>IPv4</acronym>, le protocole
		<acronym>ARP</acronym> ou <wordasword>Address Resolution
		Protocol</wordasword> a pour but de faire la correspondance entre
		une adresse <acronym>MAC</acronym> inconnue (celle de l'hôte
		destinataire) et une adresse <acronym>IPv4</acronym> connue (encore
		celle de l'hôte destinataire). Ce protocole fait le «lien» entre les
		mécanismes d'adressage de la couche réseau (<acronym>IP</acronym>) et
		de la couche liaison de données (<acronym>MAC</acronym>).</para>

	<para>Si le routage assuré au niveau réseau permet d'acheminer le trafic
		utilisateur d'un réseau à l'autre, il ne permet pas de joindre
		directement un hôte dans un réseau local de diffusion comme Ethernet.
		Au niveau liaison de données les adresses <acronym>MAC</acronym>
		servent à repérer un hôte unique dans le réseau local de diffusion. Il
		faut donc établir une correspondance entre des adresses dont la portée
		ne dépasse pas le réseau local et d'autres adresses dont la portée
		recouvre de multiples réseaux.</para>

	<para>Dans cette section, le principal outil utilisé est la commande
		<command>ip</command> du paquet
		<application>iproute2</application>.</para>
	</entry>
	<entry align='right'>
	<inlinemediaobject>
	<imageobject role='fo'>
		<imagedata fileref='images/model-neigh.png' format='PNG' width='300px' scalefit='1'/>
	</imageobject>
	<imageobject role='html'>
		<imagedata fileref='images/model-neigh.png' format='PNG' width='300px' scalefit='1'/>
	</imageobject>
	</inlinemediaobject>
	</entry>
	</row>
	</tbody>
	</tgroup>
	</informaltable>
	</para>

	<para>Dans un réseau <acronym>IPv6</acronym>, le protocole
		<acronym>NDP</acronym> ou <wordasword>Network Discovery
		Protocol</wordasword> se substitue au protocole
		<acronym>ARP</acronym> pour faire la correspondance entre les adresses
		<acronym>MAC</acronym> et les adresses <acronym>IPv6</acronym> de lien
		local appartenant au réseau <systemitem
		class='ipaddress'>fe80/10</systemitem>.</para>

	<bridgehead xml:id='conf-intf-lan.arp.cache' renderas='sect2'>Comment
		visualiser la table des voisins ?</bridgehead>

	<para>Le sous-système réseau du noyau Linux maintient une table «table des
		hôtes voisins» contenant les correspondances avec les adresses
		<acronym>IPv4</acronym> et <acronym>IPv6</acronym>.</para>

<screen><prompt>$</prompt> ip nei ls dev eth0
2001:db8:fe00:814f:226:18ff:fe27:754 dev eth0 lladdr 00:26:18:27:07:54 REACHABLE
fe80::ba27:ebff:feea:2972 dev eth0 lladdr b8:27:eb:ea:29:72 router STALE
fe80::226:18ff:fe27:754 dev eth0 lladdr 00:26:18:27:07:54 REACHABLE
2001:db8:fe00:814f::1 dev eth0 lladdr b8:27:eb:ea:29:72 router STALE
192.168.1.2 dev eth0 lladdr d4:8c:b5:9c:8e:60 REACHABLE
192.168.1.1 dev eth0 lladdr b8:27:eb:ea:29:72 STALE
192.168.1.4 dev eth0 lladdr 00:02:72:88:c5:9c REACHABLE</screen>

	<para>Attention ! La commande <userinput>ip nei ls</userinput> fait
		apparaître toutes les adresses de voisins connus dans un affichage
		commun. Ces résultats sont obtenus via deux protocoles distincts :
		<acronym>ARP</acronym> et <acronym>NDP</acronym>.</para>

<table xml:id='conf-intf-lan.arp.cache.table' pgwide="1" frame="all">
  <title>Indicateurs d'état de la table des hôtes voisins</title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="4*"/>
  <thead>
    <row>
      <entry>Indicateur</entry>
      <entry>Description</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry><literal>INCOMPLETE</literal></entry>
      <entry>La résolution d'adresse de l'hôte voisin est en cours</entry>
    </row>
    <row>
      <entry><literal>REACHABLE</literal></entry>
      <entry>La correspondance entre les adresses <acronym>IP</acronym> et
      <acronym>MAC</acronym> a bien été établie et l'hôte voisin est
      apparemment joignable</entry>
    </row>
    <row>
      <entry><literal>STALE</literal></entry>
      <entry>La correspondance entre les adresses <acronym>IP</acronym> et
      <acronym>MAC</acronym> a bien été établie mais l'hôte voisin n'est
      probablement plus joignable et une vérification sera lancée dès la
      première émission.</entry>
    </row>
    <row>
      <entry><literal>DELAY</literal></entry>
      <entry>Un paquet a été émis à destination d'un voisin dans l'état
      <literal>STALE</literal> et une confirmation de correspondance d'adresses
      est en attente</entry>
    </row>
    <row>
      <entry><literal>PROBE</literal></entry>
      <entry>La temporisation de l'état <literal>DELAY</literal> est expirée et
      la correspondance d'adresses n'a pas été confirmée ; une nouvelle
      résolution d'adresse a été initiée</entry>
    </row>
    <row>
      <entry><literal>FAILED</literal></entry>
      <entry>La résolution d'adresse a échoué</entry>
    </row>
    <row>
      <entry><literal>NOARP</literal></entry>
      <entry>Le voisin est validé ; aucune vérification ne doit être faite.</entry>
    </row>
    <row>
      <entry><literal>PERMANENT</literal></entry>
      <entry>Identique à <literal>NOARP</literal> ; seul le super utilisateur a
      la possibilité de supprimer l'entrée de la table</entry>
    </row>
  </tbody>
  </tgroup>
</table>

  <para>Les voisins <acronym>IPv6</acronym> peuvent apparaître avec un
  indicateur <literal>router</literal> supplémentaire ; ce qui signifie que ce
  voisin se présente comme un routeur <acronym>IPv6</acronym>.</para>

  <bridgehead xml:id='conf-intf-lan.arp.del' renderas='sect2'>Comment
  effacer tout ou partie de la table des voisins ?</bridgehead>

  <para>Pour tester le fonctionnement du mécanisme de résolution d'adresses, il
  peut être utile d'effacer une ou plusieurs entrées dans le but de provoquer
  une nouvelle résolution lors des prochains échanges réseau.</para>

  <variablelist>
    <varlistentry>
    <term>Suppression d'une entrée particulière</term>
    <listitem>

<screen><prompt>#</prompt> ip nei del 192.168.1.2 dev eth0</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Suppression de toutes les entrées relatives à l'interface eth0</term>
    <listitem>

<screen><prompt>#</prompt> ip neighbor flush dev eth0</screen>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour découvrir les autres manipulations possibles, il est conseillé de
  consulter les pages de manuels : <userinput><prompt>$</prompt> man
  ip-neighbour</userinput>.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.network-layer'>
<title>Lire et configurer les adresses d'une interface</title>
<subtitle>Couche réseau</subtitle>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Au niveau réseau de la modélisation, l'unité de donnée manipulée est
    le paquet. Comme <acronym>IPv4</acronym> et <acronym>IPv6</acronym> sont
    des réseaux à commutation de paquets, chaque en-tête de paquet comprend les
    adresses source et destination. C'est sur la base de l'adresse
    <acronym>IP</acronym> destination et du masque réseau qu'un routeur prend
    ses décisions d'acheminement du trafic utilisateur.</para>

    <para>Par définition, une adresse <acronym>IP</acronym> désigne à la fois
    un hôte et le réseau auquel il appartient. La distinction entre la partie
    réseau et la partie hôte d'une adresse se fait grâce au masque réseau. Il
    est donc logique que l'adresse et le masque soient les deux paramètres les
    plus importants dans la configuration <acronym>IP</acronym> d'une
    interface (Voir le document &url.adressage.ipv4;).</para>

    <para>Dans cette section, le principal outil utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.network-layer.list'
  renderas='sect2'>Comment visualiser la liste des adresses IP d'une interface
  ?</bridgehead>

  <para>Dans l'exemple ci-dessous, l'adresse <acronym>IPv4</acronym> de
  l'interface Ethernet correspond à l'hôte numéro <option>1</option> du réseau
  <systemitem class='ipaddress'>192.168.1.0/24</systemitem> dont le masque
  réseau développé est <systemitem
  class='ipaddress'>255.255.255.0</systemitem>.</para>

<screen><prompt>$</prompt> ip addr ls
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether b8:27:eb:ea:29:72 brd ff:ff:ff:ff:ff:ff
    <emphasis>inet 192.168.1.1/24 brd 192.168.1.255 scope global eth0</emphasis>
       valid_lft forever preferred_lft forever
    inet6 2001:db8:fe00:814f::1/64 scope global 
       valid_lft forever preferred_lft forever
    inet6 fe80::ba27:ebff:feea:2972/64 scope link 
       valid_lft forever preferred_lft forever</screen>

  <para>Cet exemple caractérise bien le fait qu'une même interface peut être
  configurée avec de multiples adresses. Chacune de ces adresses a une portée
  propre. Une adresse <acronym>MAC</acronym> est visible uniquement dans le
  réseau local (<acronym>LAN</acronym>) tandis qu'une adresse
  <acronym>IP</acronym> est visible à l'échelle d'une interconnexion de
  plusieurs réseaux.</para> 

  <bridgehead xml:id='conf-intf-lan.network-layer.add'
  renderas='sect2'>Comment ajouter ou supprimer une adresse à une interface
  ?</bridgehead>

  <para>La syntaxe de suppression puis d'ajout d'une adresse à une interface
  Ethernet est donnée ci-dessous.</para>

<screen><prompt>#</prompt> ip addr del 192.168.1.1/24 dev eth0

<prompt>#</prompt> ip addr add 192.168.1.1/24 brd + dev eth0</screen>

  <warning>
    <para>La suppression de l'adresse <acronym>IP</acronym> d'une interface
    entraîne la perte des routes vers les réseaux qui dépendent de ce
    lien.</para>
  </warning>

  <bridgehead xml:id='conf-intf-lan.network-layer.debian'
  renderas='sect2'>Comment rendre la configuration permanente ?</bridgehead>

  <para>Avec la distribution <citetitle>Debian GNU/Linux</citetitle>, ainsi que
  pour les distributions dérivées, les paramètres de configuration des
  interfaces réseau sont stockés dans le répertoire <filename
  class='directory'>/etc/network</filename>. Le fichier
  <filename>interfaces</filename> de ce répertoire rassemble la configuration
  des interfaces réseau.</para>

  <para>Voici l'exemple d'une interface Ethernet configurée à l'aide du
  protocole <acronym>DHCP</acronym> :</para>

<screen># /etc/network/interfaces -- configuration file for ifup(8), ifdown(8)

# The loopback interface
auto lo
iface lo inet loopback

# The first network card - this entry was created during the Debian installation
# (network, broadcast and gateway are optional)
auto eth0
iface eth0 inet dhcp</screen>

  <para>Pour une configuration statique de l'interface, il faut utiliser les
  pages de manuels : <userinput><prompt>$</prompt> man interfaces</userinput>.
  Voici un exemple :</para>

<screen>&lt;snip/&gt;
auto eth0
iface eth0 inet static
        address 192.168.1.1/24</screen>

  <para>La syntaxe de l'ensemble des options de configuration d'une interface
  réseau est décrite dans les pages de manuels : <userinput><prompt>$</prompt>
  man interfaces</userinput>.</para>
  </sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.routing'>
<title>Lire une table de routage simple et changer la passerelle par défaut</title>
<subtitle>Couche réseau</subtitle>
    
  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Le routage est une fonction essentielle de la couche réseau. Les
    données du trafic utilisateur sont encapsulées en allant de la couche
    application jusqu'à la couche réseau dans des paquets
    <acronym>IP</acronym>. Ces paquets sont <emphasis>routés</emphasis> jusqu'à
    l'hôte correspondant à l'adresse <acronym>IP</acronym> destination. En
    fonctionnement normal, un routeur prend ses décisions d'acheminement en
    analysant l'adresse <acronym>IP</acronym> destination de chaque
    paquet. Ces prises de décisions sont basées sur une <emphasis>table de
    routage</emphasis>.</para>

    <para>Cela peut paraître surprenant, mais tout hôte disposant d'un
    sous-système réseau dans son noyau ou dans un composant équivalent, utilise
    une table de routage. Bien sûr, pour un système avec une interface Ethernet
    unique, le nombre d'entrées dans la table de routage est limité.</para>

    <para>Dans cette section, le principal outil utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.routing.list' renderas='sect2'>Comment
  visualiser la table de routage ?</bridgehead>

  <para>Dans l'exemple ci-dessous, on visualise la table de routage d'un hôte
  dont l'interface Ethernet est nommée <literal>eth0</literal>.</para>

<screen><prompt>$</prompt> <emphasis>ip route ls</emphasis>
default via 192.168.3.250 dev eth0  proto static 
192.168.3.0/24 dev eth0  proto kernel  scope link  src 192.168.3.221 
169.254.0.0/16 dev eth0  scope link  metric 1000</screen>

  <para>L'analyse de chacune des trois ligne donne les informations
  suivantes.</para>

  <variablelist>
    <varlistentry>
    <term>1ère ligne : route par défaut</term>
    <listitem>
    <para>Le mot clé '<option>default</option>' désigne toutes les destinations
    non répertoriées dans les autres entrées de la table de routage ; autrement
    dit, tous les réseaux inconnus du système. Le mot clé
    '<option>via</option>' pointe vers l'adresse <acronym>IP</acronym> du
    routeur qui doit acheminer le trafic vers l'Internet. Ici, l'adresse
    <systemitem class='ipaddress'>192.168.3.250</systemitem> correspond à un
    routeur que l'on appelle communément la <emphasis>passerelle par
    défaut</emphasis>. Ainsi, tout le trafic émis par le système à destination
    de l'Internet doit être routé par cette passerelle. De plus, elle doit
    impérativement appartenir au réseau local sur lequel le système est
    raccordé.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>2ème ligne : réseau local</term>
    <listitem>
    <para>Cette entrée désigne le réseau local sur lequel le système est
    directement raccordé. Ce réseau a pour adresse <systemitem
    class='ipaddress'>192.168.3.0/24</systemitem> et c'est le noyau du système
    qui a inséré cette entrée dans la table de routage. La notation
    '<option>scope link</option>' indique que cette entrée n'est valide qu'à
    l'échelle de ce système. L'adresse <acronym>IP</acronym> source de
    l'interface Ethernet est <systemitem
    class='ipaddress'>192.168.3.221</systemitem>. Dans l'exemple étudié, les
    adresses <acronym>IP</acronym> de la passerelle par défaut et de
    l'interface Ethernet de l'hôte appartiennent bien toutes les deux au réseau
    <systemitem class='ipaddress'>192.168.3.0/24</systemitem>.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>3ème ligne : réseau de lien local</term>
    <listitem>
    <para>L'adresse réseau <systemitem
    class='ipaddress'>169.254.0.0/16</systemitem> est définie dans le standard
    &url.rfc3927;. En cas d'échec de configuration, il est possible d'attribuer
    automatiquement une adresse <acronym>IP</acronym> de ce préfixe à une
    interface. Le mot clé '<option>metric</option>' suivi de la valeur
    <option>1000</option> indique que cette entrée est une route de «dernier
    recours». Plus la métrique d'une route est élevée, moins elle est
    prioritaire.</para>
    </listitem>
    </varlistentry>
  </variablelist>

  <bridgehead xml:id='conf-intf-lan.routing.default' renderas='sect2'>Comment
  changer de passerelle par défaut ?</bridgehead>

  <para>En reprenant la table de routage affichée ci-dessus, imaginons que la
  passerelle par défaut ne soit plus à l'adresse <systemitem
  class='ipaddress'>192.168.3.250</systemitem> mais à l'adresse <systemitem
  class='ipaddress'>192.168.3.1</systemitem>. Voici la syntaxe à utiliser pour
  réaliser ce changement.</para>

<screen><prompt>#</prompt> ip route del default

<prompt>#</prompt> ip route add default via 192.168.3.1</screen>

  <bridgehead xml:id='conf-intf-lan.routing.static' renderas='sect2'>Comment
  ajouter ou supprimer une route statique ?</bridgehead>

  <para>Imaginons que l'on veuille ajouter une entrée dans la table de routage
  présentée ci-dessus vers un nouveau réseau dont on connaît l'adresse. Voici
  la syntaxe à utiliser pour ajouter puis supprimer ce réseau.</para>

<screen><prompt>#</prompt> ip route add 10.1.2.0/26 via 192.168.3.1

<prompt>#</prompt> ip route del 10.1.2.0/26</screen>

  <para>Pour aller plus loin dans les manipulations sur les routes au niveau
  réseau, la consultation des pages de manuels est un excellent point de départ
  : <userinput><prompt>$</prompt> man ip-route</userinput>.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.icmp'>
<title>Joindre un hôte de l'Internet avec ICMP</title>
<subtitle>Couches réseau &amp; application</subtitle>
    
  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Le protocole <citetitle>Internet Control Message Protocol</citetitle>
    ou <acronym>ICMP</acronym> est décrit dans le document &url.rfc792;. C'est
    un protocole de la couche réseau. Comme le protocole <acronym>IP</acronym>
    ne fournit aucun service de contrôle lors de la transmission des paquets
    sur le réseau, le rôle du protocole <acronym>ICMP</acronym> est d'informer
    l'émetteur sur les conditions de cette transmission.</para>
  
    <para>La commande <command>ping</command> utilise principalement deux types
    de messages du protocole <acronym>ICMP</acronym> et fournit les
    informations suivantes :</para>
    <itemizedlist>
      <listitem>
      <para>Le nombre de routeurs traversés pour joindre la destination</para>
      </listitem>
      <listitem>
      <para>Le temps de propagation aller retour (<wordasword>round-trip
      delay</wordasword>) lors de la communication avec l'hôte distant</para>
      </listitem>
      <listitem>
      <para>Le taux de pertes de paquets pendant la communication</para>
      </listitem>
    </itemizedlist>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <para>Il existe 18 types de messages ICMP. Les deux types de messages
  employés par la commande <command>ping</command> sont :</para>
  <itemizedlist>
    <listitem>
    <para>Le type 8 (<literal>echo request</literal>) est émis vers l'hôte
    distant.</para>
    </listitem>
    <listitem>
    <para>Le type 0 (<literal>echo reply</literal>) est émis par l'hôte distant
    en réponse.</para>
    </listitem>
  </itemizedlist>

  <para>Quelques autres types sont abordés dans la <xref
  linkend='conf-intf-lan.procfs'/>.</para>

  <para>Pour valider le bon fonctionnement des communications entre les
  adresses <acronym>IP</acronym> source et destination, on suit une séquence
  classique de tests :</para>
  
  <orderedlist numeration='arabic'>
  <listitem>
    <para>adresse <acronym>IP</acronym> de l'interface de boucle locale :
    <literal>lo</literal></para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> de l'interface du poste de
    travail : <literal>eth0</literal></para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> du destinataire de la passerelle par
    défaut</para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> extérieure au réseau local</para>
  </listitem>
  </orderedlist>

	<bridgehead xml:id='conf-intf-lan.icmp.test' renderas='sect2'>Comment
		savoir si un hôte distant est joignable ?</bridgehead>

  <variablelist>
    <varlistentry>
    <term>État de la pile TCP/IP</term>
    <listitem>
    <para>Le test suivant permet de valider les communications réseau pour les
    processus appartenant au même système.</para>

<screen><prompt>$</prompt> ping -c 2 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_req=1 ttl=64 time=0.320 ms
64 bytes from 127.0.0.1: icmp_req=2 ttl=64 time=0.320 ms

--- 127.0.0.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.320/0.320/0.320/0.000 ms</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Test de l'interface Ethernet</term>
    <listitem>
    <para>On reprend le même test avec l'adresse <acronym>IP</acronym> de
    l'interface.</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_req=1 ttl=64 time=0.626 ms
64 bytes from 192.168.1.1: icmp_req=2 ttl=64 time=0.269 ms

--- 192.168.1.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.269/0.447/0.626/0.179 ms</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Tests vers des hôtes du réseau local</term>
    <listitem>
    <para>Exemple d'échec :</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.14
PING 192.168.1.14 (192.168.1.14) 56(84) bytes of data.
From 192.168.1.1 icmp_seq=1 Destination Host Unreachable
From 192.168.1.1 icmp_seq=2 Destination Host Unreachable

--- 192.168.1.14 ping statistics ---
2 packets transmitted, 0 received, +2 errors, 100% packet loss, time 1007ms</screen>

    <para>Exemple de succès :</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2:<co xml:id='icmpfrom'/> icmp_req=1<co xml:id='icmpseq'/> ttl=255<co xml:id='icmpttl'/> time=1.61 ms
64 bytes from 192.168.1.2: icmp_req=2 ttl=255 time=1.16 ms

--- 192.168.1.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 1.161/1.388/1.616/0.230 ms</screen>

  <calloutlist>
  <callout arearefs='icmpfrom'>
    <para>Adresse de réponse du message ICMP : destinataire du
    test</para>
  </callout>
  <callout arearefs='icmpseq'>
    <para>Numéro de séquence du message</para>
  </callout>
  <callout arearefs='icmpttl'>
    <para>La valeur du champ <acronym>TTL</acronym> d'un paquet
    <acronym>IP</acronym> correspond au nombre de routeurs traversés pour
    arriver à destination</para>
  </callout>
  </calloutlist>
    </listitem>
    </varlistentry>
  </variablelist>

	<bridgehead xml:id='conf-intf-lan.icmp.dns' renderas='sect2'>Comment savoir
		si un hôte distant est joignable en utilisant la résolution des noms de
		domaines ?</bridgehead>

	<para>La commande <command>ping</command> est aussi utile pour savoir si la
		résolution des noms d'hôtes fonctionne correctement. Dans ce cas, on
		fait appel à un service Internet appelé <wordasword>Domain Name
		Service</wordasword> (<acronym>DNS</acronym>). Cet appel au service
		<acronym>DNS</acronym> suppose que la fonction
		<wordasword>resolver</wordasword> soit correctement configurée.</para>

<screen><prompt>$</prompt> ping -c 2 www.nic.fr<co xml:id='icmp6name'/>
PING www.nic.fr(lb01-1.nic.fr (2001:67c:2218:30::24))<co xml:id='icmp6res'/> 56 data bytes
64 bytes from lb01-1.nic.fr (2001:67c:2218:30::24): icmp_seq=1 ttl=59 time=12.7 ms
64 bytes from lb01-1.nic.fr (2001:67c:2218:30::24): icmp_seq=2 ttl=59 time=12.6 ms

--- www.nic.fr ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 12.632/12.675/12.719/0.120 ms</screen>

<screen><prompt>$</prompt> ping -4 -c 2 www.nic.fr<co xml:id='icmp4name'/>
PING lb01-1.nic.fr (192.134.5.24)<co xml:id='icmp4res'/> 56(84) bytes of data.
64 bytes from lb01-1.nic.fr (192.134.5.24): icmp_seq=1 ttl=58 time=32.8 ms
64 bytes from lb01-1.nic.fr (192.134.5.24): icmp_seq=2 ttl=58 time=31.1 ms

--- lb01-1.nic.fr ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 31.188/32.036/32.884/0.848 ms</screen>

	<calloutlist>
	<callout arearefs="icmp6name icmp4name">
	<para>Utilisation de la commande <command>ping</command> avec un nom d'hôte
		au lieu d'une adresse <acronym>IPv4</acronym> ou
		<acronym>IPv6</acronym>. Par défaut, dès qu'une solution
		<acronym>IPv6</acronym> est disponible, c'est ce protocole qui est
		utilisé.</para>
	</callout>
	<callout arearefs="icmp6res icmp4res">
	<para>Affichage de la correspondance entre le nom de l'hôte et l'adresse
		<acronym>IPv6</acronym> ou <acronym>IPv4</acronym> suivant le contexte.
		L'utilisation de l'option <option>-4</option> avec la commande
		<command>ping</command> force la correspondance avec l'adresse
		<acronym>IPv4</acronym>.</para>
	</callout>
	</calloutlist>

	<para>En cas d'échec sur la résolution des noms, il faut contrôler la
		configuration de la partie cliente du service des noms de domaines.
		Cette partie est abordée dans la section suivante.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.dns'>
<title>Lire et analyser une requête DNS</title>
<subtitle>Couche application</subtitle>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Pour simplifier, on peut dire que le service Internet
    <wordasword>Domain Name System</wordasword> ou <acronym>DNS</acronym>
    fonctionne sur le même mode qu'un annuaire téléphonique dans lequel le
    numéro de téléphone est remplacé par l'adresse <acronym>IP</acronym> et le
    nom d'abonné est remplacé par le nom d'hôte.</para>

    <para><acronym>DNS</acronym> est un service de type client/serveur dont la
    fonction clé est la <emphasis>résolution</emphasis> entre des
    enregistrements et des adresses <acronym>IP</acronym>. Les enregistrements
    sont distribués entre les serveurs qui ont chacun autorité sur une partie
    de l'arborescence des noms de domaines.</para>

    <para>Dans le contexte de ce document, on ne s'intéresse qu'à la partie
    cliente du service appelée <wordasword>resolver</wordasword>.</para>

    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l5.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l5.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.dns.resolv.conf' renderas='sect2'>Comment
  visualiser la configuration du resolver ?</bridgehead>

  <para>Généralement, la configuration du <wordasword>resolver</wordasword>
  d'un poste client est mise en place automatiquement grâce à des services tels
  que <acronym>DHCP</acronym> (<wordasword>Dynamic Host Configuration
  Protocol</wordasword>) ou <acronym>RDNSS</acronym> (<wordasword>Recursive DNS
  Server</wordasword>) et <acronym>DNSSL</acronym> (<wordasword>DNS Search
  List</wordasword>). Il existe même un paquet appelé
  <application>resolvconf</application> qui améliore la gestion de la
  configuration du <wordasword>resolver</wordasword> en choisissant les
  paramètres en fonction des services d'autoconfiguration disponibles.</para>

  <para>Voici une description succincte des fichiers de configuration système
  qui jouent un rôle dans la résolution des noms de domaines. La liste des
  sources d'information puis l'ordre dans lequel on consulte ces sources sont
  les facteurs les plus importants.</para> 

  <variablelist>
    <varlistentry>
    <term><filename>/etc/resolv.conf</filename></term>
    <listitem>
    <para>Le rôle de ce fichier est de désigner le serveur
    <acronym>DNS</acronym> qui doit prendre en charge les requêtes du système.
    Tout programme qui fait référence à un nom d'hôte sollicite cette
    ressource.</para>

<screen><prompt>$</prompt> cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 192.0.2.1</screen>

    <para>Ici l'adresse <acronym>IP</acronym> du serveur <acronym>DNS</acronym>
    est 192.0.2.1. Dans un contexte domestique, on retrouve les mêmes
    informations via l'interface Web d'une «box ADSL».</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term><filename>/etc/nsswitch.conf</filename></term>
    <listitem>
	<para>Le rôle du <wordasword>Name Service Switch</wordasword> dépasse le
		cadre de la simple résolution des noms d'hôtes. Tous les programmes
		font appel à la bibliothèque standard <wordasword>glibc</wordasword>.
		Lors des appels à cette bibliothèque, ce fichier est consulté pour
		connaître la liste des sources à utiliser.</para>

<screen><prompt>$</prompt> grep ^hosts /etc/nsswitch.conf 
hosts:          files mdns_minimal [NOTFOUND=return] dns mdns</screen>

    <para>Dans l'exemple ci-dessus, la scrutation des sources débute avec les
    fichiers locaux, la version minimale du service <wordasword>multicast
    DNS</wordasword>, le service <acronym>DNS</acronym> tel que configuré dans
    le fichier ci-dessus et enfin le service <wordasword>multicast
    DNS</wordasword>.</para>

    <para>La syntaxe '<literal>[NOTFOUND=return]</literal>', implique que si
    l'un des deux services qui suivent dans la liste déclare que l'hôte est
    introuvable, la recherche s'arrête là.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term><filename>/etc/host.conf</filename></term>
    <listitem>
    <para>Ce dernier fichier est présent pour des raisons de compatibilité avec
    les anciennes versions de la bibliothèque standard.</para>

<screen><prompt>$</prompt> cat /etc/host.conf 
multi on</screen>
    </listitem>
    </varlistentry>
  </variablelist>

	<bridgehead xml:id='conf-intf-lan.dns.dig' renderas='sect2'>Comment
		analyser les résultats d'une requête DNS ?</bridgehead>

	<para>Sur un système GNU/Linux, les deux commandes de référence sont
		<command>dig</command> et <command>host</command>. Elles servent à
		qualifier le bon fonctionnement du <wordasword>resolver</wordasword>
		sur le système en isolant le service <acronym>DNS</acronym> des autres
		traitements. Voici quelques exemples de requêtes.</para>

	<variablelist>
	<varlistentry>
		<term>Résolution complète d'un nom d'hôte</term>
	<listitem>
	<para>La question posée est : quelle sont les enregistrements
		<acronym>DNS</acronym> relatifs au nom de serveur Web
		<citetitle>www.nic.fr</citetitle> ?</para>

<screen><prompt>$</prompt> host www.nic.fr
www.nic.fr is an alias for lb01-1.nic.fr.
lb01-1.nic.fr has address 192.134.5.24
lb01-1.nic.fr has IPv6 address 2001:67c:2218:30::24</screen>

	<para>Cet exemple illustre le fait que plusieurs questions ont été posées
		via la commande <command>host</command> puisque les adresses
		<acronym>IPv4</acronym> et <acronym>IPv6</acronym> ont été obtenues en
		retour.</para>
	</listitem>
	</varlistentry>
	<varlistentry>
		<term>Résolution simple d'un nom d'hôte</term>
	<listitem>
	<para>La question posée est : quelle est l'adresse <acronym>IPv4</acronym>
		correspondant au nom de serveur Web <citetitle>www.nic.fr</citetitle>
		?</para>

<screen><prompt>$</prompt> dig +short www.nic.fr
lb01-1.nic.fr.
<emphasis>192.134.5.24</emphasis></screen>
	</listitem>
	</varlistentry>

	<varlistentry>
		<term>Résolution inverse d'une adresse IP</term>
	<listitem>
	<para>La question posée est : quel est le nom d'hôte correspondant à
		l'adresse <acronym>IPv4</acronym> <systemitem
		class='ipaddress'>192.134.5.24</systemitem> ?</para>

<screen><prompt>$</prompt> dig +short -x 192.134.5.24
<emphasis>lb01-1.nic.fr.</emphasis></screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Requête DNS complète sur un nom d'hôte</term>
    <listitem>

<screen><prompt>$</prompt> dig www.iana.org

; &lt;&lt;>> DiG 9.8.4-rpz2+rl005.12-P1 &lt;&lt;>> www.iana.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 60063
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 4

;; QUESTION SECTION:<co xml:id='dig_a.question'/>
;www.iana.org.                  IN      A

;; ANSWER SECTION:<co xml:id='dig_a.answer'/>
www.iana.org.           600     IN      CNAME   ianawww.vip.icann.org.
ianawww.vip.icann.org.  30      IN      A       192.0.32.8

;; AUTHORITY SECTION:<co xml:id='dig_a.authority'/>
vip.icann.org.          3600    IN      NS      gtm1.dc.icann.org.
vip.icann.org.          3600    IN      NS      gtm1.lax.icann.org.

;; ADDITIONAL SECTION:<co xml:id='dig_a.additional'/>
gtm1.dc.icann.org.      21600   IN      A       192.0.47.252
gtm1.dc.icann.org.      21600   IN      AAAA    2620:0:2830:296::252
gtm1.lax.icann.org.     21600   IN      A       192.0.32.252
gtm1.lax.icann.org.     21600   IN      AAAA    2620:0:2d0:296::252

;; Query time: 562 msec<co xml:id='dig_a.time'/>
;; SERVER: 192.0.2.1#53(192.0.2.1)<co xml:id='dig_a.server'/>
;; WHEN: Thu Jan 30 10:37:46 2014
;; MSG SIZE  rcvd: 211</screen>

    <calloutlist>
      <callout arearefs='dig_a.question'>
	<para>Le champ <acronym>QUESTION</acronym> reprend les termes de la
	requête <acronym>DNS</acronym> soumise au serveur.</para>
      </callout>
      <callout arearefs='dig_a.answer'>
        <para>Le champ <acronym>ANSWER</acronym> liste les éléments de réponse à la
	requête. Ici, le nom d'hôte <systemitem>www.iana.org</systemitem> est
	en fait un alias de <systemitem>ianawww.vip.icann.org</systemitem>. Cet
	alias a pour adresse <acronym>IP</acronym> : <systemitem
	class='ipaddress'>192.0.32.8</systemitem>.</para>
      </callout>
      <callout arearefs='dig_a.authority'>
	<para>Le champ <acronym>AUTHORITY</acronym> donne la liste des serveurs
	de noms qui ont autorité sur les enregistrements
	<acronym>DNS</acronym>. Ce sont les seuls serveurs aptes à fournir une
	réponse aux requêtes sur le domaine concerné.</para>
      </callout>
      <callout arearefs='dig_a.additional'>
	<para>Le champ <acronym>ADDITIONAL</acronym> donne les adresses
	<acronym>IP</acronym> des serveurs <acronym>DNS</acronym> de référence
	du domaine.</para>
      </callout>
      <callout arearefs='dig_a.time'>
	<para>Le champ <acronym>Query time</acronym> donne le temps de
	traitement de la requête. La valeur obtenue permet de déduire si le
	serveur interrogé a déjà la réponse en mémoire cache ou non.</para>
      </callout>
      <callout arearefs='dig_a.server'>
	<para>Le champ <acronym>SERVER</acronym> identifie le serveur qui a
	pris la requête <acronym>DNS</acronym> en charge.</para>
      </callout>
    </calloutlist>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour aller plus loin dans l'étude du fonctionnement du service de noms
  de domaines, il est conseillé de lire le support &url.sysadm-net.dns;.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.traceroute'>
<title>Tracer le chemin suivi par le trafic réseau avec traceroute</title>
<subtitle>Couches réseau &amp; application</subtitle>

	<para>Si la commande <command>ping</command> du protocole
		<acronym>ICMP</acronym> permet d'obtenir des informations l'état de
		l'hôte destination, elle ne permet pas de tracer le chemin suivi par
		les paquets <acronym>IP</acronym>. C'est justement l'objectif du
		service <application>traceroute</application> dont le principe est le
		suivant :</para>

  <itemizedlist>
    <listitem>
    <para>La source émet un premier message avec la valeur 1 dans le champ
    <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>.</para>
    </listitem>
    <listitem>
    <para>Le routeur qui reçoit ce message décrémente la valeur du champ
    <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym> et obtient 0. Il
    jette donc le message et émet un message <acronym>ICMP</acronym> à
    destination de l'émetteur indiquant qu'il est impossible d'atteindre la
    destination.</para> 
    </listitem>
    <listitem>
    <para>La source émet un deuxième message avec la valeur 2 dans le champ
    <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>.</para>
    </listitem>
    <listitem>
    <para>Cette fois-ci, c'est le deuxième routeur qui décrémente la valeur du
    champ <acronym>TTL</acronym> et obtient 0. C'est donc à lui d'émettre un
    message <acronym>ICMP</acronym> indiquant qu'il est impossible d'atteindre
    la destination.</para>
    </listitem>
    <listitem>
    <para>Ainsi de suite avec les valeurs du champ <acronym>TTL</acronym> de
    l'en-tête <acronym>IP</acronym> 3, 4, 5, etc.</para>
    </listitem>
  </itemizedlist>

  <warning>
    <para>Pour des raisons de sécurité, il peut être nécessaire de cacher le
    chemin suivi par le trafic utilisateur. C'est la raison pour laquelle les
    résultats obtenus varient énormément suivant les contextes d'interconnexion
    réseau. Il devient de plus en plus difficile d'obtenir une information
    correcte.</para>
  </warning>

  <para>Pour illustrer le fonctionnement du service, on peut utiliser la
  commande <command>mtr</command> fournie par la paquet
  <application>mtr-tiny</application>. Cette commande possède de nombreuses
  options et fournit une présentation dynamique des résultats. Voici deux
  exemples qui illustrent la «dispersion» des résultats :</para>

  <variablelist>
    <varlistentry>
    <term>Exemple de rapport basé sur <acronym>ICMP echo</acronym></term>
    <listitem>
<screen><prompt>$</prompt> mtr -4 -c 10 --report www.nic.fr
Start: 2018-01-08T14:55:31+0100
HOST: inetdoc-ttn                 Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- h7.tetaneutral.net         0.0%    10    0.3   0.3   0.3   0.3   0.0
  2.|-- te0-0-2-3.rcr11.tls01.atl  0.0%    10    1.1   1.4   1.0   3.6   0.8
  3.|-- te0-2-1-2.rcr21.bod01.atl  0.0%    10    4.1   4.2   4.1   4.4   0.1
  4.|-- be2840.rcr21.eas02.atlas.  0.0%    10    7.8   7.8   7.7   7.9   0.1
  5.|-- be2839.ccr52.bio02.atlas.  0.0%    10    8.8   8.8   8.7   8.8   0.1
  6.|-- be3358.ccr32.mad05.atlas.  0.0%    10   13.6  13.5  13.3  13.7   0.2
  7.|-- ae-20.r01.mdrdsp03.es.bb.  0.0%    10   13.6  13.6  13.4  14.3   0.2
  8.|-- ae-7.r24.londen12.uk.bb.g  0.0%    10   30.4  30.5  30.3  31.3   0.4
  9.|-- ae-1.r25.londen12.uk.bb.g  0.0%    10   30.4  30.4  30.3  30.9   0.2
 10.|-- ae-2.r04.parsfr01.fr.bb.g  0.0%    10   30.6  30.6  30.5  30.8   0.1
 11.|-- ae-5.r03.parsfr02.fr.bb.g  0.0%    10   30.7  30.7  30.6  30.9   0.1
 12.|-- ae-8.r02.parsfr02.fr.bb.g  0.0%    10   30.6  30.8  30.6  31.0   0.2
 13.|-- 82.112.96.178              0.0%    10   31.1  31.0  30.9  31.1   0.1
 14.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0
 15.|-- isg-th3.interco.nic.fr     0.0%    10   30.3  30.3  30.3  30.4   0.1
 16.|-- lb01-1.nic.fr              0.0%    10   30.5  30.4  30.4  30.6   0.1</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Exemple de rapport basé sur <acronym>UDP</acronym></term>
    <listitem>
<screen><prompt>$</prompt> mtr -4 -u -c 10 --report www.nic.fr
Start: 2018-01-08T14:57:32+0100
HOST: inetdoc-ttn                 Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- h7.tetaneutral.net         0.0%    10    0.3   0.3   0.3   0.3   0.0
  2.|-- te0-0-2-3.rcr11.tls01.atl  0.0%    10    1.1   1.1   1.0   1.2   0.1
  3.|-- te0-2-1-2.rcr21.bod01.atl  0.0%    10    4.2   4.3   4.2   4.4   0.1
  4.|-- be2840.rcr21.eas02.atlas.  0.0%    10    7.8   7.8   7.7   8.0   0.1
  5.|-- be2838.ccr51.bio02.atlas.  0.0%    10    8.8   8.8   8.6   9.2   0.2
  6.|-- be3357.ccr31.mad05.atlas.  0.0%    10   13.6  13.5  13.2  13.7   0.1
  7.|-- ae-4.r01.mdrdsp03.es.bb.g  0.0%    10   14.3  13.6  13.4  14.3   0.3
  8.|-- ae-7.r24.londen12.uk.bb.g  0.0%    10   30.3  28.2  27.3  30.3   1.1
  9.|-- ae-1.r25.londen12.uk.bb.g  0.0%    10   27.3  28.8  27.3  31.5   1.4
 10.|-- ae-2.r04.parsfr01.fr.bb.g  0.0%    10   27.7  28.6  27.7  29.9   0.8
 11.|-- ae-5.r03.parsfr02.fr.bb.g  0.0%    10   28.5  28.5  27.1  31.2   1.5
 12.|-- ae-8.r02.parsfr02.fr.bb.g  0.0%    10   27.8  28.4  27.0  30.7   1.0
 13.|-- 82.112.96.178              0.0%    10   31.1  29.1  27.6  31.1   1.1
 14.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0</screen>
    </listitem>
    </varlistentry>
  </variablelist>

	<para>La comparaison entre les deux rapports montre que le protocole
		<acronym>ICMP</acronym> subit un filtrage important relativement aux
		requêtes <acronym>UDP</acronym>. Les très nombreuses attaques de type
		«déni de service distribué» basées sur <acronym>ICMP</acronym> ont
		nécessité la mise en place de protections qui entraînent quelques
		désagréments dans les tests de fonctionnement des réseaux.</para>

	<para>Pour aller plus loin dans les manipulations sur le tracé de route, il
		existe d'autres outils intéressants tels que
		<command>tracepath</command> fourni par le paquet
		<application>iputils-tracepath</application>.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.procfs'>
<title>Lire et configurer les fonctions réseau du noyau Linux</title>

	<para>Sur tous les systèmes, un certain nombre de paramètres sont actifs
		par défaut sur les interfaces réseau. Avec le noyau Linux, ces
		paramètres sont placés dans le système de fichiers virtuel <filename
		class='directory'>/proc</filename>.</para>

	<bridgehead xml:id='conf-intf-lan.dns.procfs.search'
		renderas='sect2'>Comment visualiser les paramètres du noyau Linux pour
		une interface Ethernet ?</bridgehead>
  
  <para>Sur les systèmes GNU/Linux, la granularité du paramétrage du
  sous-système réseau du noyau est très très fine. Il suffit de visualiser le
  résultat des commandes comme <userinput><prompt>$</prompt> ls
  /proc/sys/net/ipv4/</userinput> ou <userinput><prompt>#</prompt> sysctl -A
  | grep net</userinput> pour le constater.</para>

  <para>Sachant que le nom de l'interface Ethernet est '<option>eth0</option>',
  on peut commencer par faire une recherche des répertoires relatifs à ce nom
  d'interface.</para>

<screen><prompt>$</prompt> find /proc/sys -type d -name '*eth0*'
/proc/sys/net/ipv4/conf/eth0
/proc/sys/net/ipv4/neigh/eth0
/proc/sys/net/ipv6/conf/eth0
/proc/sys/net/ipv6/neigh/eth0</screen>

  <para>Ensuite, on peut consulter le contenu d'un répertoire identifié dans la
  liste ci-dessus.</para>

<screen><prompt>$</prompt> for param in `find /proc/sys/net/ipv4/conf/eth0 -type f`; do \
echo $param = `cat $param`; \
done
/proc/sys/net/ipv4/conf/eth0/accept_local = 0
<emphasis>/proc/sys/net/ipv4/conf/eth0/accept_redirects = 1</emphasis>
/proc/sys/net/ipv4/conf/eth0/accept_source_route = 1
/proc/sys/net/ipv4/conf/eth0/arp_accept = 0
/proc/sys/net/ipv4/conf/eth0/arp_announce = 0
/proc/sys/net/ipv4/conf/eth0/arp_filter = 0
/proc/sys/net/ipv4/conf/eth0/arp_ignore = 0
/proc/sys/net/ipv4/conf/eth0/arp_notify = 0
/proc/sys/net/ipv4/conf/eth0/bootp_relay = 0
/proc/sys/net/ipv4/conf/eth0/disable_policy = 0
/proc/sys/net/ipv4/conf/eth0/disable_xfrm = 0
/proc/sys/net/ipv4/conf/eth0/force_igmp_version = 0
/proc/sys/net/ipv4/conf/eth0/forwarding = 0
/proc/sys/net/ipv4/conf/eth0/igmpv2_unsolicited_report_interval = 10000
/proc/sys/net/ipv4/conf/eth0/igmpv3_unsolicited_report_interval = 1000
/proc/sys/net/ipv4/conf/eth0/log_martians = 0
/proc/sys/net/ipv4/conf/eth0/mc_forwarding = 0
/proc/sys/net/ipv4/conf/eth0/medium_id = 0
/proc/sys/net/ipv4/conf/eth0/promote_secondaries = 0
/proc/sys/net/ipv4/conf/eth0/proxy_arp = 0
/proc/sys/net/ipv4/conf/eth0/proxy_arp_pvlan = 0
/proc/sys/net/ipv4/conf/eth0/route_localnet = 0
/proc/sys/net/ipv4/conf/eth0/rp_filter = 0
/proc/sys/net/ipv4/conf/eth0/secure_redirects = 1
/proc/sys/net/ipv4/conf/eth0/send_redirects = 1
/proc/sys/net/ipv4/conf/eth0/shared_media = 1
/proc/sys/net/ipv4/conf/eth0/src_valid_mark = 0
/proc/sys/net/ipv4/conf/eth0/tag = 0</screen>

  <para>La description de tous les paramètres relatifs à l'interface Ethernet
  sort du cadre de ce document. Le but ici est de montrer que ces paramètres
  existent, qu'ils sont accessibles et que l'on sait où les trouver dans
  l'arborescence système.</para>

  <bridgehead xml:id='conf-intf-lan.dns.procfs.change' renderas='sect2'>Comment
  changer la valeur d'un paramètre ?</bridgehead>

  <para>Pour changer les valeurs attribuées par défaut lors de l'initialisation
  du système, il existe plusieurs solutions. Pour faire simple, on se limite à
  l'utilisation de la commande <command>sysctl</command> fournie par le paquet
  <application>procps</application>. Le fichier de configuration de l'outil est
  : <filename>/etc/sysctl.conf</filename>. Si on édite ce fichier en modifiant
  ou en ajoutant un paramètre et que l'on applique ensuite la commande
  <userinput><prompt>#</prompt> sysctl -p</userinput>, tous les changement
  seront effectifs immédiatement. Comme le fichier
  <filename>/etc/sysctl.conf</filename> est conservé, les paramètres seront à
  nouveau appliqués lors de l'initialisation du système. Voici un exemple très
  simple dans lequel on modifie les deux paramètres relatifs aux messages de
  redirection <acronym>ICMP</acronym> que l'on ne souhaite pas accepter pour
  des raisons de sécurité.</para>

  <para>On décommente les deux lignes du fichier avec le mot clé
  '<option>accept_redirects</option>'. La partie modifiée du fichier est la
  suivante :</para>

<screen># Do not accept ICMP redirects (prevent MITM attacks)
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0</screen>

  <para>Le résultat de l'appel à <command>sysctl</command> est :</para>

<screen><prompt>#</prompt> sysctl -p
net.ipv4.conf.all.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0</screen>

  <para>Les quelques paramètres des fonctions réseau du noyau Linux présentés
  ici ne constituent qu'une infime partie. Le document &url.ipsysctl.tutorial;
  présente l'ensemble des paramètres utilisables pour ajuster le fonctionnement
  de la pile de protocoles <acronym>TCP/IP</acronym>.</para>
</sect1>

<?custom-pagebreak?>
<sect1 xml:id='conf-intf-lan.tp'>
<title>Travaux pratiques</title>

	<para>Pour traiter les questions de cette section, on suppose que le poste
		client dispose d'une interface Ethernet déjà configurée avec un accès à
		un réseau local puis à l'Internet via une passerelle par défaut. La
		topologie type est la suivante :</para>

  <mediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/conf-intf-lan-topology.png' format='PNG' width='9cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/conf-intf-lan-topology.png' format='PNG' width='480px' scalefit='1'/>
    </imageobject>
  </mediaobject>
 
  <bridgehead xml:id='conf-intf-lan.tp.intf' renderas='sect2'>Questions sur la
  configuration de l'interface Ethernet</bridgehead>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Quelles sont les informations disponibles sur le composant
      contrôleur Ethernet et son pilote logiciel sur le système ?</para>
      </question>
      <answer>
      <para>Utiliser les commandes présentées dans la <xref
      linkend='conf-intf-lan.physical-layer'/> pour extraire la référence du
      composant.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quelles sont les informations sur la connexion au réseau local
      Ethernet ?</para>
      </question>
      <answer>
      <para>Utiliser les commandes présentées dans la <xref
      linkend='conf-intf-lan.physical-layer'/> pour obtenir les informations
      sur le débit utile entre l'hôte et le commutateur, le mode de
      transmission <wordasword>full duplex</wordasword> ou <wordasword>half
      duplex</wordasword> et le type de média utilisé.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quelles sont les différentes adresses de l'interface Ethernet aux
      niveaux liaison de données et réseau ? Quel est le protocole qui assure
      la correspondance entre ces adresses ?</para> 
      </question>
      <answer>
      <para>Utiliser les commandes de visualisation présentée dans la <xref
      linkend='conf-intf-lan.link-layer'/> et la <xref
      linkend='conf-intf-lan.network-layer'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quelles sont les informations données par la configuration sur
      l'état de l'interface ?</para>
      </question>
      <answer>
      <para>Reprendre les éléments du tableau des indicateurs d'états donné
      dans la <xref linkend='conf-intf-lan.link-layer'/> et faire la
      correspondance avec la configuration visualisée.</para>
      </answer>
    </qandaentry>
  </qandaset>
 
  <bridgehead xml:id='conf-intf-lan.tp.addressing' renderas='sect2'>Questions
  sur les mécanismes d'adressage</bridgehead>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Quelle est l'adresse du réseau <acronym>IP</acronym> auquel
      l'interface Ethernet est raccordée ? Quelle est la plage des adresses
      <acronym>IP</acronym> utilisables ? Quelle est l'adresse de diffusion de
      ce réseau ?</para>
      </question>
      <answer>
      <para>Utiliser la commande proposée à la <xref
      linkend='conf-intf-lan.network-layer'/> et le document
      &url.adressage.ipv4; pour déterminer les bornes du réseau
      <acronym>IP</acronym>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Est-il possible de déduire l'adresse <acronym>IP</acronym> de la
      passerelle par défaut à partir des informations fournies par la
      configuration de l'interface ?</para>
      </question>
      <answer>
      <para>Attention, même si des conventions font que l'on retrouve
      fréquemment les adresses <acronym>IP</acronym> des passerelles en
      première ou dernière position de l'espace d'adressage utile, il n'existe
      aucune règle définie.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quels sont les espaces de validité respectifs des adresses
      <acronym>MAC</acronym> et <acronym>IP</acronym> ?</para>
      </question>
      <answer>
      <para>Retrouver les informations dans la <xref
      linkend='conf-intf-lan.link-layer'/> et la <xref
      linkend='conf-intf-lan.network-layer'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Comment visualiser la table de correspondance entre les adresses
      <acronym>MAC</acronym> et <acronym>IP</acronym> connues de l'interface
      Ethernet ?</para>
      </question>
      <answer>
      <para>Utiliser la commande proposée dans la <xref
      linkend='conf-intf-lan.arp'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Comment forcer l'ajout d'une nouvelle entrée dans la table des
      voisins ? À quel réseau <acronym>IP</acronym> doivent appartenir les
      adresses à tester ?</para>
      </question>
      <answer>
      <para>Utiliser la commande proposée dans la <xref
      linkend='conf-intf-lan.icmp'/> pour tester l'accessibilité d'une adresse
      <acronym>IP</acronym>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Pourquoi des entrées apparaissent dans la table des voisins sans
      action particulière ?</para>
      </question>
      <answer>
      <para>Essayer de repérer les stations du réseau local qui ont contacté
      l'interface Ethernet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Est-il possible de déduire l'adresse <acronym>IP</acronym> de la
      passerelle par défaut à partir des informations fournies par la
      table des voisins ?</para>
      </question>
      <answer>
      <para>Retrouver l'entrée de la table des voisins sollicitée par le trafic
      sortant vers l'Internet.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Pourquoi l'entrée avec l'adresse <acronym>MAC</acronym> de la
      passerelle par défaut est-elle «rafraîchie» après un test de la commande
      <command>ping</command> utilisant un nom d'hôte ?</para>
      </question>
      <answer>
      <para>Revoir les tests présentés à la <xref
      linkend='conf-intf-lan.icmp'/> et les éléments de configuration donnés à
      la <xref linkend='conf-intf-lan.dns'/>.</para>
      </answer>
    </qandaentry>
  </qandaset>
 
  <bridgehead xml:id='conf-intf-lan.tp.dns' renderas='sect2'>Questions
  sur le service DNS</bridgehead>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Quelle est l'adresse <acronym>IP</acronym> du serveur
      <acronym>DNS</acronym> indiquée dans le fichier de configuration du
      client <acronym>DNS</acronym> ?</para>
      </question>
      <answer>
      <para>Utiliser les informations données à la <xref
      linkend='conf-intf-lan.dns'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quelle est la commande à utiliser pour poser une requête
      <acronym>DNS</acronym> individuelle ? Donner un exemple ?</para>
      </question>
      <answer>
      <para>Utiliser les informations données à la <xref
      linkend='conf-intf-lan.dns'/>.</para>
      </answer>
    </qandaentry>
  </qandaset>
 
  <bridgehead xml:id='conf-intf-lan.tp.routing' renderas='sect2'>Questions
  sur la table de routage</bridgehead>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Combien y-a-t-il d'entrées dans la table de routage ? Quel est le
      rôle de chacune de ces entrées ?</para>
      </question>
      <answer>
      <para>Reprendre l'exemple donné à la <xref
      linkend='conf-intf-lan.routing'/> et faire la correspondance avec les
      informations relevées.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Comment identifier la passerelle par défaut dans
      la table de routage ?</para>
      </question>
      <answer>
      <para>Relever l'identifiant et/ou la valeur numérique du réseau de
      destination pour cette entrée de la table de routage.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>La passerelle par défaut peut-elle appartenir à un autre réseau
      que celui de la station ?</para>
      </question>
      <answer>
      <para>La fonction d'une passerelle par défaut est de fournir une voie de
      communication vers tous les autres réseaux. Compléter le raisonnement à
      partir du cas où cette voie de communication n'appartient pas au réseau
      local.</para>
      </answer>
    </qandaentry>
  </qandaset>
 
  <bridgehead xml:id='conf-intf-lan.tp.mtr' renderas='sect2'>Questions
  sur traceroute</bridgehead>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Quel est le rôle du service <application>traceroute</application>
      relativement au protocole <acronym>ICMP</acronym> ?</para>
      </question>
      <answer>
      <para>Relire la <xref linkend='conf-intf-lan.traceroute'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>À partir d'un exemple, donner pour chaque routeur traversé les
      valeurs du champ <acronym>TTL</acronym> de l'en-tête
      <acronym>IP</acronym>.</para>
      </question>
      <answer>
      <para>Reprendre l'exemple donné dans la <xref
      linkend='conf-intf-lan.traceroute'/> et faire la correspondance avec les
      informations relevées.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Dans quelles conditions les informations renvoyées par les routeurs
      sont «incomplètes» ?</para>
      </question>
      <answer>
      <para>Relire l'avertissement donné dans la <xref
      linkend='conf-intf-lan.traceroute'/>.</para>
      </answer>
    </qandaentry>
  </qandaset>
</sect1>
</article>
