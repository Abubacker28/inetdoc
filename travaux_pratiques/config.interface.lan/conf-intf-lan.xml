<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
        "/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd"[

<!ENTITY phl   	     	   	SYSTEM "author.xml">
<!ENTITY legal 			SYSTEM "legal.xml">

<!ENTITY topologie.observation	SYSTEM "files/topologie.observation.txt">
<!ENTITY topologie.multi	SYSTEM "files/topologie.multi.txt">
<!ENTITY topologie.multi.addr	SYSTEM "files/topologie.multi.addr.txt">

<!ENTITY % rfc_urls SYSTEM 'rfc.urls.xml'>
%rfc_urls;

<!ENTITY % inetdoc_urls SYSTEM 'inetdoc.urls.xml'>
%inetdoc_urls;

<!ENTITY url.securing-debian-howto
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://www.debian.org/doc/manuals/securing-debian-howto/ch4.fr.html#s-network-secure">
   <citetitle>«Sécurations des accès réseau» du Manuel de sécurisation de Debian</citetitle></link>'>

<!ENTITY url.ipsysctl.tutorial
   '<link xmlns="http://docbook.org/ns/docbook" xlink:href="http://ipsysctl-tutorial.frozentux.net/ipsysctl-tutorial.html">
   <citetitle>Ipsysctl tutorial</citetitle></link>'>
]>

<article xml:lang='fr' xml:id='conf-intf-lan'>
<info>
  <title>Configuration d'une interface réseau Ethernet</title>
  &phl;
  <abstract>
    <para>Ce support de travaux pratiques traite de la configuration d'une
    interface réseau Ethernet sur un système GNU/Linux. Les manipulations
    présentées suivent la modélisation réseau en remontant du niveau physique
    jusqu'à la validation des services de la couche application. Les questions
    cherchent à illustrer les relations entre les différents formats
    d'adressage utilisés à chaque niveau.</para>
  </abstract>

  <keywordset>
    <keyword>arp</keyword>
    <keyword>ip</keyword>
    <keyword>host</keyword>
    <keyword>dig</keyword>
    <keyword>interface</keyword>
    <keyword>ping</keyword>
    <keyword>route</keyword>
    <keyword>traceroute</keyword>
    <keyword>sysctl</keyword>
    <keyword>hping2</keyword>
  </keywordset>
</info>

<sect1 xml:id='conf-intf-lan.legal.meta'>
  &legal;
  <bridgehead xml:id='conf-intf-lan.meta' renderas='sect2'>Méta-information</bridgehead>
    
  <para>Cet article est écrit avec <link
  xlink:href="http://www.docbook.org"><citetitle>DocBook</citetitle></link> XML
  sur un système <link xlink:href="http://www.debian.org"><citetitle>Debian
  GNU/Linux</citetitle></link>. Il est disponible en version imprimable au
  format PDF : <link
  xlink:href="http://www.inetdoc.net/pdf/__printbasename__"><literal>__printbasename__</literal></link>.</para>

  <para>Toutes les commandes utilisées dans ce document ne sont pas spécifiques
  à une version particulière des systèmes UNIX ou GNU/Linux. C'est la
  distribution <citetitle>Debian GNU/Linux</citetitle> qui est utilisée
  pour les tests présentés. Voici une liste des paquets contenant les
  commandes utilisées :</para>

  <itemizedlist>
    <listitem>
    <para><application>procps</application> - The /proc file system utilities</para>
    </listitem>
    <listitem>
    <para><application>pciutils</application> - Linux PCI Utilities</para>
    </listitem>
    <listitem>
    <para><application>ethtool</application> - display or change Ethernet device settings</para>
    </listitem>
    <listitem>
    <para><application>iproute</application> - networking and traffic control tools</para>
    </listitem>
    <listitem>
    <para><application>ifupdown</application> - High level tools to configure network interfaces</para>
    </listitem>
    <listitem>
    <para><application>iputils-ping</application> - Tools to test the reachability of network hosts</para>
    </listitem>
    <listitem>
    <para><application>bind9-host</application> - Version of 'host' bundled with BIND 9.X</para>
    </listitem>
    <listitem>
    <para><application>dnsutils</application> - Clients provided with BIND</para>
    </listitem>
    <listitem>
    <para><application>traceroute</application> - Traces the route taken by packets over a TCP/IP network</para>
    </listitem>
    <listitem>
    <para><application>hping2</application> - Active Network Smashing Tool</para>
    </listitem>
  </itemizedlist>

  <bridgehead xml:id='conf-intf-lan.convtypo' renderas='sect2'>Conventions
  typographiques</bridgehead>

  <para>Tous les exemples d'exécution des commandes sont précédés d'une invite
  utilisateur ou <wordasword>prompt</wordasword> spécifique au niveau des
  droits utilisateurs nécessaires sur le système.</para>

  <itemizedlist>
    <listitem>
    <para>Toute commande précédée de l'invite <prompt>$</prompt> ne nécessite
    aucun privilège particulier et peut être utilisée au niveau utilisateur
    simple.</para>
    </listitem>
    <listitem>
    <para>Toute commande précédée de l'invite <prompt>#</prompt> nécessite les
    privilèges du super-utilisateur.</para>
    </listitem>
  </itemizedlist>
</sect1>

<sect1 xml:id='conf-intf-lan.physical-layer'>
  <title>Identification d'une interface - couche physique</title>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
  <para>Avant de pouvoir configurer une interface, il faut que le pilote de
  périphérique correspondant ait été chargé en mémoire. Comme une interface
  réseau est un dispositif matériel, c'est au niveau du noyau Linux que
  l'opération doit s'effectuer. Soit le pilote d'interface a été inclus dans la
  partie monolithique du noyau soit il est chargé en mémoire sous forme de
  module. C'est cette dernière solution qui est le plus souvent retenue. Un
  module peut être chargé ou déchargé à volonté sans avoir à redémarrer la
  machine. De plus, les fonctions de reconnaissance automatique des composants
  périphériques permettent de ne charger que les modules correspondant aux
  composants effectivement présents sur le système.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l1.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l1.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.ident-periph' renderas='sect2'>Comment
  identifier un périphérique Ethernet ?</bridgehead>

  <para>Il existe une grande variété de contrôleurs réseau Ethernet. À chaque
  composant correspond un pilote logiciel spécifique. Qu'il s'agisse d'une
  carte additionnelle ou d'un composant intégré sur carte mère, le
  contrôleur peut être connecté via différents bus. Les bus
  <acronym>PCI</acronym> et <acronym>USB</acronym> sont les plus fréquemment
  utilisés. Voici deux exemples :</para>

  <variablelist>
    <varlistentry xml:id='ident-pci'>
    <term>Contrôleur Ethernet sur bus PCI</term>
    <listitem>
    <para>Sur une architecture <trademark>Intel</trademark>
    <acronym>x86_64</acronym>, un composant Ethernet est nécessairement relié
    au bus <acronym>PCI</acronym>. La commande <command>lspci</command> du
    paquet <application>pciutils</application> donne la liste des
    périphériques ainsi que les modules du noyau Linux associés à ces
    périphériques.</para>

<screen><prompt>$</prompt> lspci -v
&lt;snip/&gt;
07:00.0 <emphasis>Ethernet controller</emphasis>: Intel Corporation 82576 Gigabit Network Connection (rev 01)
        Subsystem: Intel Corporation Gigabit ET Quad Port Server Adapter
        Flags: bus master, fast devsel, latency 0, IRQ 55
        Memory at ddf40000 (32-bit, non-prefetchable) [size=128K]
        Memory at de000000 (32-bit, non-prefetchable) [size=4M]
        I/O ports at dcc0 [size=32]
        Memory at ddf38000 (32-bit, non-prefetchable) [size=16K]
        Capabilities: &lt;access denied>
        <emphasis>Kernel driver in use: igb</emphasis></screen>

    <para>Le module du noyau Linux nommé <option>igb</option> est chargé en
    mémoire automatiquement lors de l'initialisation du système. Il est présent
    dans la liste donnée par la commande <command>lsmod</command>.</para>

<screen><prompt>$</prompt> lsmod | grep igb
<emphasis>igb                   138336  0 </emphasis>
i2c_algo_bit           12751  1 igb
i2c_core               24092  2 igb,i2c_algo_bit
dca                    13168  2 igb,ioatdma
ptp                    17460  1 igb</screen>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='ident-usb'>
    <term>Contrôleur Ethernet sur bus USB</term>
    <listitem>
    <para>Sur une architecture <citetitle>Raspberry Pi</citetitle>, le
    composant Ethernet est relié au bus <acronym>USB</acronym> et c'est la
    commande <command>dmesg</command> qui permet d'obtenir l'identification du
    composant.</para>

<screen><prompt>$</prompt> dmesg | grep -i Ethernet
[    3.114563] smsc95xx 1-1.1:1.0 eth0: register 'smsc95xx' at usb-bcm2708_usb-1.1, \
               <emphasis>smsc95xx USB 2.0 Ethernet</emphasis>, b8:27:eb:ea:29:72</screen>
    </listitem>
    </varlistentry>
    <varlistentry xml:id='ident-sys'>
    <term>Répertoire /sys/</term>
    <listitem>
    <para>Pour compléter les informations sur les interfaces réseau, il est
    possible de parcourir l'arborescence <filename
    class='directory'>/sys/</filename>. Ainsi, dans le cas d'une architecture
    <citetitle>Raspberry Pi</citetitle>, on obtient les éléments suivants
    :</para>

<screen><prompt>$</prompt> ls -go /sys/class/net/eth0/device/driver/<co xml:id='ident-sys.eth0'/>
total 0
lrwxrwxrwx 1    0 janv. 27 09:18 1-1.1:1.0 -> \
             ../../../../devices/platform/bcm2708_usb/usb1/1-1/1-1.1/1-1.1:1.0<co xml:id='ident-sys.bus'/>
--w------- 1 4096 janv. 27 09:18 bind
lrwxrwxrwx 1    0 janv. 27 09:18 module -> \
             ../../../../module/smsc95xx<co xml:id='ident-sys.module'/>
-rw-r--r-- 1 4096 janv. 27 09:18 new_id
-rw-r--r-- 1 4096 janv. 27 09:18 remove_id
--w------- 1 4096 janv. 27 09:18 uevent
--w------- 1 4096 janv. 27 09:18 unbind</screen>

    <calloutlist>
    <callout arearefs='ident-sys.eth0'>
    <para>La dénomination <systemitem>eth0</systemitem> désigne la première
    interface Ethernet présente sur le système.</para>
    </callout>

    <callout arearefs='ident-sys.bus'>
    <para>Dans le répertoire relatif à l'interface, on repère la position du
    contrôleur Ethernet sur le bus <acronym>USB</acronym>.</para>
    </callout>

    <callout arearefs='ident-sys.module'>
    <para>Dans le même répertoire, on identifie aussi le module de pilotage du
    contrôleur.</para>
    </callout>
    </calloutlist>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour résumer, les outils utiles pour l'identification des composants
  réseau et des modules logiciels assciés sont : <command>lspci</command>,
  <command>dmesg</command>, <command>lsmod</command> et le parcours de
  l'arborescence <filename class='directory'>/sys/</filename>.</para> 

  <bridgehead xml:id='conf-intf-lan.ident-link' renderas='sect2'>Comment
  visualiser l'état du lien réseau ?</bridgehead>

  <para>Même avec une configuration correcte de l'interface, il est possible
  que les communications soient bloquées si le lien physique entre l'hôte et
  l'équipement réseau n'est pas actif. Sur les liaisons utilisant des câbles en
  paires torsadées cuivre, on peut visualiser l'état du lien à l'aide de la
  commande <command>ethtool</command> fournie avec le paquet du même
  nom. En reprenant les mêmes exemples que ci-dessus, on retrouve les
  informations suivantes :</para>

  <variablelist>
    <varlistentry xml:id='link-intel'>
    <term>Interface <trademark>Intel</trademark> Gbps</term>
    <listitem>
<screen><prompt>#</prompt>ethtool eth0
Settings for eth0:
        Supported ports: [ TP ]
        Supported link modes:   10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
                                1000baseT/Full <co xml:id='intel-mii.cap'/>
        Supported pause frame use: Symmetric
        Supports auto-negotiation: Yes
        Advertised link modes:  10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
                                1000baseT/Full 
        Advertised pause frame use: Symmetric
        Advertised auto-negotiation: Yes
        Speed: 1000Mb/s <co xml:id='intel-mii.link'/>
        Duplex: Full
        Port: Twisted Pair <co xml:id='intel-mii.tp'/>
        PHYAD: 1
        Transceiver: internal
        Auto-negotiation: on <co xml:id='intel-mii.neg'/>
        MDI-X: off (auto)
        Supports Wake-on: pumbg
        Wake-on: g
        Current message level: 0x00000007 (7)
                               drv probe link
        Link detected: yes</screen>

    <calloutlist>
    <callout arearefs='intel-mii.cap'>
    <para>Cette liste correspond aux débits possibles sur cette interface :
    1000Mbps en mode Full-Duplex, 100Mbps en mode Full-Duplex, 100Mbps en mode
    Half-Duplex, 10Mbps en mode Full-Duplex et 10Mbps en mode
    Half-Duplex.</para>
    </callout>
    <callout arearefs='intel-mii.link'>
    <para>Le lien entre l'interface <systemitem>eth0</systemitem> et
    l'équipement réseau est actif et le débit négocié est de 1000Mbps en mode
    Full-Duplex.</para>
    </callout>
    <callout arearefs='intel-mii.tp'>
    <para>Le câble connecté à cette interface est en paire cuivre torsadée ou
    <wordasword>twisted pair</wordasword>.</para>
    </callout>
    <callout arearefs='intel-mii.neg'>
    <para>Les résultats précédents ont été obtenus par auto négociation entre
    le contrôleur réseau et le commutateur auquel l'interface Ethernet est
    connectée.</para> 
    </callout>
    </calloutlist>
    </listitem>
    </varlistentry>

    <varlistentry xml:id='rpi-link'>
    <term>Interface <citetitle>Raspberry Pi</citetitle> 100Mbps</term>
    <listitem>
<screen><prompt>$</prompt> sudo ethtool eth0
Settings for eth0:
        Supported ports: [ TP MII ]
        Supported link modes:   10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full
        Supported pause frame use: No
        Supports auto-negotiation: Yes
        Advertised link modes:  10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
        Advertised pause frame use: Symmetric Receive-only
        Advertised auto-negotiation: Yes
        Link partner advertised link modes:  10baseT/Half 10baseT/Full 
                                             100baseT/Half 100baseT/Full 
        Link partner advertised pause frame use: Symmetric
        Link partner advertised auto-negotiation: Yes
        Speed: 100Mb/s
        Duplex: Full
        Port: MII
        PHYAD: 1
        Transceiver: internal
        Auto-negotiation: on
        Supports Wake-on: pumbag
        Wake-on: d
        Current message level: 0x00000007 (7)
                               drv probe link
        Link detected: yes</screen>

    <para>Relativement à la copie d'écran ci-dessus, le débit passe à 100Mb/s.
    C'est le principal changement observé.</para>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour aller plus loin dans l'étude des caractéristiques techniques des
  réseaux locaux, il est conseillé de lire l'article &url.ethernet;.</para>
</sect1>

<sect1 xml:id='conf-intf-lan.link-layer'>
  <title>Configuration d'une interface - couche liaison</title>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Au niveau liaison de données de la modélisation, l'unité de donnée
    manipulée est la trame. Dans le cas de la technologie Ethernet, la trame
    contient les adresses <acronym>MAC</acronym> (<wordasword>media access
    control address</wordasword>) des hôtes source et destination du réseau de
    diffusion (<acronym>LAN</acronym>). À ce niveau, il est possible de
    configurer plusieurs fonctions. Vis-à-vis de la couche physique, on peut
    activer ou désactiver une interface. Vis-à-vis de la couche réseau, on peut
    définir la quantité de données à encapsuler dans une trame. C'est aussi à
    ce niveau que l'on définit les champs du standard <citetitle>IEEE
    802.1q</citetitle>. Cette dernière fonction sort du cadre de ce document
    (voir l'article &url.inter-vlan-routing;). Les fonctions relatives à la
    gestion de mise en file d'attente des paquets issus de la couche réseau
    sortent aussi du cadre de ce document (voir &url.lartc.fr;).</para>

    <para>Dans cette section, le seul principal utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l2.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l2.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.link-layer.status' renderas='sect2'>Comment
  visualiser l'état d'une interface réseau ?</bridgehead>

  <para>Le simple fait de consulter l'état d'une interface fournit une grande
  quantité d'informations.</para>

<screen><prompt>$</prompt> ip link ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP><co xml:id='eth0.status'/> mtu 1500<co xml:id='eth0.mtu'/> qdisc pfifo_fast state UP \
                                              mode DEFAULT qlen 1000
    link/ether b8:27:eb:ea:29:72<co xml:id='eth0.mac'/> brd ff:ff:ff:ff:ff:ff</screen>

  <calloutlist>
    <callout arearefs='eth0.status'>
    <para>Les indicateurs d'état désignent les fonctions actives au niveau de
    l'interface.</para>

<table xml:id='conf-intf-lan.link-layer.status.table' pgwide="1" frame="all">
  <title>Indicateurs d'état d'une interface Ethernet</title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="1*"/>
  <thead>
    <row>
      <entry>Indicateur</entry>
      <entry>Description</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry><literal>BROADCAST</literal></entry>
      <entry>L'interface peut émettre du trafic à destination de tous les hôtes
      du réseau local</entry>
    </row>
    <row>
      <entry><literal>MULTICAST</literal></entry>
      <entry>L'interface peut émettre et recevoir du trafic de type
      multidiffusion</entry>
    </row>
    <row>
      <entry><literal>UP</literal></entry>
      <entry>L'interface est active</entry>
    </row>
    <row>
      <entry><literal>LOWER_UP</literal></entry>
      <entry>Un «câble» est correctement connecté à l'interface</entry>
    </row>
    <row>
      <entry><literal>PROMISC</literal></entry>
      <entry>L'interface transmet aux couches supérieures la totalité du trafic
      reçu</entry>
    </row>
    <row>
      <entry><literal>ALLMULTI</literal></entry>
      <entry>L'interface transmet au couches supérieures la totalité du trafic reçu</entry>
    </row>
  </tbody>
  </tgroup>
</table>
    </callout>

    <callout arearefs='eth0.mtu'>
    <para>L'acronyme <acronym>MTU</acronym> signifie <wordasword>Maximum
    Transmission Unit</wordasword>. La valeur <option>1500</option> correspond
    à la quantité maximum d'octets transmis de la couche réseau à la couche
    liaison de données sans fragmentation.</para>
    </callout>

    <callout arearefs='eth0.mac'>
    <para>L'adresse <acronym>MAC</acronym> de l'interface joue un rôle
    essentiel. C'est cette adresse qui identifie l'hôte dans le réseau local
    (<acronym>LAN</acronym>). Cette adresse unique respecte un format bien
    particulier : <acronym>EUI-48</acronym>. Voir
    &url.inter-vlan-routing-mac-types;.</para>
    </callout>
  </calloutlist>

  <bridgehead xml:id='conf-intf-lan.link-layer.set' renderas='sect2'>Comment
  activer/désactiver une interface réseau ?</bridgehead>

  <para>Ces opérations peuvent s'effectuer à deux niveaux bien distincts :
  interface et/ou système.</para>

  <para>Au niveau système, les scripts <command>ifup</command> et
  <command>ifdown</command> du paquet <application>ifupdown</application>
  utilisent les paramètres de configuration des interfaces donnés dans le
  fichier <filename>/etc/network/interfaces</filename> lors de l'activation ou
  la désactivation. Si une interface est paramétrée pour utiliser le client
  <acronym>DHCP</acronym> par exemple, les scripts se chargent du lancement et
  de l'arrêt du programme <application>dhclient</application>.</para>

  <para>À l'inverse, les manipulations au niveau interface ne tiennent aucun
  compte du mode de configuration antérieur. L'exécution des outils de
  configuration dans l'espace utilisateur peut se poursuivre alors que
  l'interface associée est inactive. Une telle situation peut conduire à des
  problèmes de fonctionnement du système ! Il est donc important de recenser
  les fonctions associées à une interface avant de se lancer dans les
  manipulations directes d'interfaces.</para>

  <variablelist>
    <varlistentry>
    <term>Désactivation au niveau interface</term>
    <listitem>
<screen><prompt>#</prompt> ip link set dev eth0 down

<prompt>#</prompt> ip addr ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop <emphasis>state DOWN</emphasis> \
                                  group default qlen 1000
    link/ether ba:ad:00:ca:fe:b9 brd ff:ff:ff:ff:ff:ff</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Désactivation au niveau système</term>
    <listitem>
<screen><prompt>#</prompt> ifdown eth0</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Activation au niveau interface</term>
    <listitem>
<screen><prompt>#</prompt> ip link set dev eth0 up

<prompt>#</prompt> ip addr ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast <emphasis>state UP</emphasis> \
                                              group default qlen 1000
    link/ether ba:ad:00:ca:fe:b9 brd ff:ff:ff:ff:ff:ff</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Activation au niveau système</term>
    <listitem>
<screen><prompt>#</prompt> ifup eth0</screen>
    </listitem>
    </varlistentry>
  </variablelist>

  <bridgehead xml:id='conf-intf-lan.link-layer.mac' renderas='sect2'>Comment
  changer l'adresse MAC d'une interface réseau ?</bridgehead>

  <para>Parmi les nombreuses manipulations possibles avec la commande
  <command>ip link</command>, il est possible de changer l'adresse
  <acronym>MAC</acronym> d'une interface. Voici un exemple.</para>

<screen><prompt>#</prompt> ip link set dev eth0 down

<prompt>#</prompt> ip link set address de:ad:be:ef:00:01 dev eth0

<prompt>#</prompt> ip link ls dev eth0
2: eth0: &lt;BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT \
                                  group default qlen 1000
    link/ether de:ad:be:ef:00:01 brd ff:ff:ff:ff:ff:ff

<prompt>#</prompt> ip link set dev eth0 up</screen>

  <para>Pour aller plus loin dans les manipulations au niveau liaison de
  données, la consultation des pages de manuels est un excellent point de
  départ : <userinput><prompt>$</prompt> man ip-link</userinput>.</para>
</sect1>

<sect1 xml:id='conf-intf-lan.arp'>
  <title>Protocole ARP</title>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='320px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Le protocole <acronym>ARP</acronym> ou <wordasword>Address Resolution
    Protocol</wordasword> a pour but de chercher à faire correspondre une
    adresse <acronym>MAC</acronym> inconnue (celle de l'hôte destinataire) avec
    une adresse <acronym>IP</acronym> connue (encore celle de l'hôte
    destinataire). Ce protocole assure la «liaison» entre les mécanismes
    d'adressage de la couche réseau (<acronym>IP</acronym>) et de la couche
    liaison de données (<acronym>MAC</acronym>).</para>

    <para>Si le routage assuré au niveau réseau permet d'acheminer le trafic
    utilisateur d'un réseau à l'autre, il ne permet pas de joindre directement
    un hôte dans un réseau local de diffusion comme Ethernet. Au niveau liaison
    de données les adresses <acronym>MAC</acronym> servent à repérer un hôte
    unique dans le réseau local de diffusion. Il faut donc établir une
    correspondance entre des adresses dont la portée ne dépasse pas le réseau
    local et d'autres adresses dont la portée recouvre de multiples
    réseaux.</para>

    <para>Dans cette section, le principal outil utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-arp.png' format='PNG' width='300px' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-arp.png' format='PNG' width='300px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.arp.cache' renderas='sect2'>Comment
  visualiser la table des voisins ARP ?</bridgehead>

  <para>Le sous-système réseau maintient une table de correspondance entre les
  adresses <acronym>IP</acronym> et les adresses <acronym>MAC</acronym> appelée
  cache <acronym>ARP</acronym> avec le protocole <acronym>IPv4</acronym>. Dans
  le contexte d'utilisation d'une double pile <acronym>IPv4</acronym> et
  <acronym>IPv6</acronym>, on parle de la «table des hôtes voisins». Voici un
  exemple de consultation de cette table.</para>

<screen><prompt>$</prompt> ip nei ls dev eth0
2001:db8:fe00:814f:226:18ff:fe27:754 dev eth0 lladdr 00:26:18:27:07:54 REACHABLE
fe80::ba27:ebff:feea:2972 dev eth0 lladdr b8:27:eb:ea:29:72 router STALE
fe80::226:18ff:fe27:754 dev eth0 lladdr 00:26:18:27:07:54 REACHABLE
2001:db8:fe00:814f::1 dev eth0 lladdr b8:27:eb:ea:29:72 router STALE
192.168.1.2 dev eth0 lladdr d4:8c:b5:9c:8e:60 REACHABLE
192.168.1.1 dev eth0 lladdr b8:27:eb:ea:29:72 STALE
192.168.1.4 dev eth0 lladdr 00:02:72:88:c5:9c REACHABLE</screen>

<note>
  <title>ARP vs NDP</title>
  <para>Attention ! Le protocole <acronym>ARP</acronym> ne fonctionne qu'avec
  <acronym>IPv4</acronym>. Un nouveau protocole de correspondance plus
  sophistiqué a été introduit avec <acronym>IPv6</acronym> :
  <wordasword>Network Discovery Protocol</wordasword>. Si la commande
  <userinput>ip nei ls</userinput> fait apparaître les résultats dans un
  affichage commun, ces résultats sont obtenus via deux protocoles
  distincts. La présentation du protocole <acronym>NDP</acronym> sort du cadre
  de ce document.</para>
</note>

<table xml:id='conf-intf-lan.arp.cache.table' pgwide="1" frame="all">
  <title>Indicateurs d'état de la table des hôtes voisins</title>
  <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colnum="1" colwidth="1*"/>
    <colspec colnum="2" colwidth="1*"/>
  <thead>
    <row>
      <entry>Indicateur</entry>
      <entry>Description</entry>
    </row>
  </thead>
  <tbody>
    <row>
      <entry><literal>INCOMPLETE</literal></entry>
      <entry>La résolution d'adresse de l'hôte voisin est en cours</entry>
    </row>
    <row>
      <entry><literal>REACHABLE</literal></entry>
      <entry>La correspondance entre les adresses <acronym>IP</acronym> et
      <acronym>MAC</acronym> a bien été établie et l'hôte voisin est
      apparemment joignable</entry>
    </row>
    <row>
      <entry><literal>STALE</literal></entry>
      <entry>La correspondance entre les adresses <acronym>IP</acronym> et
      <acronym>MAC</acronym> a bien été établie mais l'hôte voisin n'est
      probablement plus joignable et une vérification sera lancée dès la
      première émission.</entry>
    </row>
    <row>
      <entry><literal>DELAY</literal></entry>
      <entry>Un paquet a été émis à destination d'un voisin dans l'état
      <literal>STALE</literal> et une confirmation de correspondance d'adresses
      est en attente</entry>
    </row>
    <row>
      <entry><literal>PROBE</literal></entry>
      <entry>La temporisation de l'état <literal>DELAY</literal> est expirée et
      la correspondance d'adresses n'a pas été confirmée ; une nouvelle
      résolution d'adresse a été initiée</entry>
    </row>
    <row>
      <entry><literal>FAILED</literal></entry>
      <entry>La résolution d'adresse a échoué</entry>
    </row>
    <row>
      <entry><literal>NOARP</literal></entry>
      <entry>Le voisin est validé ; aucune vérification ne doit être faite.</entry>
    </row>
    <row>
      <entry><literal>PERMANENT</literal></entry>
      <entry>Identique à <literal>NOARP</literal> ; seul le super utilisateur a
      la possibilité de supprimer l'entrée de la table</entry>
    </row>
  </tbody>
  </tgroup>
</table>

  <para>Les voisins <acronym>IPv6</acronym> peuvent apparaître avec un
  indicateur <literal>router</literal> supplémentaire ; ce qui signifie que ce
  voisin se présente comme un routeur <acronym>IPv6</acronym>.</para>

  <bridgehead xml:id='conf-intf-lan.arp.del' renderas='sect2'>Comment
  effacer tout ou partie de la table des voisins ARP ?</bridgehead>

  <para>Pour tester le fonctionnement du mécanisme de résolution d'adresses, il
  peut être utile d'effacer une ou plusieurs entrées dans le but de provoquer
  une nouvelle résolution lors des prochains échanges réseau.</para>

  <variablelist>
    <varlistentry>
    <term>Suppression d'une entrée particulière</term>
    <listitem>

<screen><prompt>#</prompt> ip nei del 192.168.1.2 dev eth0</screen>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>Suppression de toutes les entrées relatives à l'interface eth0</term>
    <listitem>

<screen><prompt>#</prompt> ip neighbor flush dev eth0</screen>
    </listitem>
    </varlistentry>
  </variablelist>

  <para>Pour découvrir les autres manipulations possibles, il est conseillé de
  consulter les pages de manuels : <userinput><prompt>$</prompt> man
  ip-neighbour</userinput>.</para>
</sect1>

<sect1 xml:id='conf-intf-lan.network-layer'>
  <title>Configuration d'une interface - couche réseau</title>

  <para>
  <informaltable frame='none' pgwide='1'>
  <tgroup cols='2' align='left' colsep='0' rowsep='0'>
  <colspec colwidth='5*'/>
  <colspec colwidth='180px'/>
  <tbody>
    <row>
    <entry valign='top'>
    <para>Au niveau réseau de la modélisation, l'unité de donnée manipulée est
    le paquet. Comme <acronym>IPv4</acronym> et <acronym>IPv6</acronym> sont
    des réseaux à commutation de paquets, chaque en-tête de paquet comprend les
    adresses source et destination. C'est sur la base de l'adresse
    <acronym>IP</acronym> destination et du masque réseau qu'un routeur prend
    ses décisions d'acheminement du trafic utilisateur.</para>

    <para>Par définition, une adresse <acronym>IP</acronym> désigne à la fois
    un hôte et le réseau auquel il appartient. La distinction entre la partie
    réseau et la partie hôte d'une adresse se fait grâce au masque réseau. Il
    est donc logique que l'adresse et le masque soient les deux paramètres les
    plus importants dans la configuration <acronym>IP</acronym> d'une
    interface (Voir le document &url.adressage.ipv4;).</para>

    <para>Dans cette section, le seul principal utilisé est la commande
    <command>ip</command> du paquet <application>iproute2</application>.</para>
    </entry>
    <entry align='right'>
    <inlinemediaobject>
    <imageobject role='fo'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='3cm' scalefit='1'/>
    </imageobject>
    <imageobject role='html'>
      <imagedata fileref='images/model-l3.png' format='PNG' width='160px' scalefit='1'/>
    </imageobject>
    </inlinemediaobject>
    </entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>
  </para>

  <bridgehead xml:id='conf-intf-lan.network-layer.list'
  renderas='sect2'>Comment visualiser la liste des adresses IP d'une interface
  ?</bridgehead>

  <para>Dans l'exemple ci-dessous, l'adresse <acronym>IPv4</acronym> de
  l'interface Ethernet correspond à l'hôte numéro <option>1</option> du réseau
  <systemitem class='ipaddress'>192.168.1.0/24</systemitem> dont le masque
  réseau développé est <systemitem
  class='ipaddress'>255.255.255.0</systemitem>.</para>

<screen><prompt>$</prompt> ip addr ls
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether b8:27:eb:ea:29:72 brd ff:ff:ff:ff:ff:ff
    <emphasis>inet 192.168.1.1/24 brd 192.168.1.255 scope global eth0</emphasis>
       valid_lft forever preferred_lft forever
    inet6 2001:db8:fe00:814f::1/64 scope global 
       valid_lft forever preferred_lft forever
    inet6 fe80::ba27:ebff:feea:2972/64 scope link 
       valid_lft forever preferred_lft forever</screen>

  <para>Cet exemple caractérise bien le fait qu'une même interface peut être
  configurée avec de multiples adresses. Chacune de ces adresses a une portée
  propre. Une adresse <acronym>MAC</acronym> est visible uniquement dans le
  réseau local (<acronym>LAN</acronym>) tandis qu'une adresse
  <acronym>IP</acronym> est visible à l'échelle d'une interconnexion de
  plusieurs réseaux.</para> 

  <bridgehead xml:id='conf-intf-lan.network-layer.add'
  renderas='sect2'>Comment ajouter ou supprimer une adresse à une interface
  ?</bridgehead>

  <para>La syntaxe de suppression puis d'ajout d'une adresse à une interface
  Ethernet est donnée ci-dessous.</para>

<screen><prompt>#</prompt> ip addr del 192.168.1.1/24 dev eth0

<prompt>#</prompt> ip addr add 192.168.1.1/24 brd + dev eth0</screen>

  <bridgehead xml:id='conf-intf-lan.network-layer.debian'
  renderas='sect2'>Comment rendre la configuration permanente ?</bridgehead>

  <para>Avec la distribution <citetitle>Debian GNU/Linux</citetitle> les
  paramètres de configuration des interfaces réseau sont stockés dans le
  répertoire <filename class='directory'>/etc/network</filename>. Le fichier
  <filename>interfaces</filename> de ce répertoire rassemble la configuration
  des interfaces réseau.</para>

  <para>Voici l'exemple d'une interface Ethernet configurée à l'aide du
  protocole <acronym>DHCP</acronym> :</para>

<screen># /etc/network/interfaces -- configuration file for ifup(8), ifdown(8)

# The loopback interface
auto lo
iface lo inet loopback

# The first network card - this entry was created during the Debian installation
# (network, broadcast and gateway are optional)
auto eth0
iface eth0 inet dhcp</screen>

  <para>Pour une configuration statique de l'interface, il faut utiliser les
  pages de manuels : <userinput><prompt>$</prompt> man interfaces</userinput>.
  Voici un exemple :</para>

<screen>&lt;snip/&gt;
auto eth0
iface eth0 inet static
        address 192.168.1.1
        netmask 255.255.255.0
        network 192.168.1.0
        broadcast 192.168.1.255</screen>
  </sect1>

  <sect1 xml:id='conf-intf-lan.icmp'>
    <title>Protocole ICMP</title>
    
  <para>Le protocole <citetitle>Internet Control Message Protocol</citetitle>
  ou <acronym>ICMP</acronym> est décrit dans le document &url.rfc792;. Comme le
  protocole <acronym>IP</acronym> de la couche réseau fonctionne en mode non
  connecté, il ne fournit aucun service de contrôle lors de la transmission des
  paquets sur le réseau. Le rôle du protocole <acronym>ICMP</acronym> est
  d'informer l'émetteur lorsqu'il y a eu un problème.</para>
  
  <para>La commande <command>ping</command> utilise principalement deux types
  de messages du protocole ICMP pour informer l'utilisateur sur les conditions
  de transmissions :</para>
  <itemizedlist>
    <listitem>
    <para>L'hôte distant est-il actif ou inactif.</para>
    </listitem>
    <listitem>
    <para>Le temps de propagation en boucle (<wordasword>round-trip
    delay</wordasword>) lors de la communication avec l'hôte distant.</para>
    </listitem>
    <listitem>
    <para>Les pertes de paquets pendant la communication.</para>
    </listitem>
  </itemizedlist>

  <para>Il existe 18 types de messages ICMP. Les deux types de messages
  employés par la commande <command>ping</command> sont :</para>
  <itemizedlist>
    <listitem>
    <para>Le type 8 (<literal>echo request</literal>) est émis vers l'hôte
    distant.</para>
    </listitem>
    <listitem>
    <para>Le type 0 (<literal>echo reply</literal>) est émis par l'hôte distant
    en réponse.</para>
    </listitem>
  </itemizedlist>

  <para>Quelques autres types sont abordés dans la partie <xref
  linkend='conf-intf-lan.procfs'/>.</para>

  <para>Pour valider le bon fonctionnement d'une communication sur un réseau
  <acronym>IP</acronym>, on suit une séquence précise de tests :</para>
  
  <orderedlist numeration='arabic'>
  <listitem>
    <para>adresse <acronym>IP</acronym> de l'interface de boucle locale :
    <literal>lo</literal></para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> de l'interface du poste de
    travail : <literal>eth0</literal></para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> du destinataire de la passerelle par
    défaut</para>
  </listitem>
  <listitem>
    <para>adresse <acronym>IP</acronym> extérieure au réseau local</para>
  </listitem>
  </orderedlist>


  <bridgehead xml:id='conf-intf-lan.icmp.test' renderas='sect2'>Comment valider
  une interconnexion réseau ?</bridgehead>

  <variablelist>
    <varlistentry>
    <term>État de la pile TCP/IP</term>
    <listitem>
    <para>Le test suivant permet de valider les communications réseau pour les
    processus appartenant au même système.</para>

<screen><prompt>$</prompt> ping -c 2 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_req=1 ttl=64 time=0.320 ms
64 bytes from 127.0.0.1: icmp_req=2 ttl=64 time=0.320 ms

--- 127.0.0.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.320/0.320/0.320/0.000 ms</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Test de l'interface Ethernet</term>
    <listitem>
    <para>On reprend le même test avec l'adresse <acronym>IP</acronym> de
    l'interface.</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_req=1 ttl=64 time=0.626 ms
64 bytes from 192.168.1.1: icmp_req=2 ttl=64 time=0.269 ms

--- 192.168.1.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.269/0.447/0.626/0.179 ms</screen>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>Tests vers des hôtes du réseau local</term>
    <listitem>
    <para>Exemple d'échec :</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.14
PING 192.168.1.14 (192.168.1.14) 56(84) bytes of data.
From 192.168.1.1 icmp_seq=1 Destination Host Unreachable
From 192.168.1.1 icmp_seq=2 Destination Host Unreachable

--- 192.168.1.14 ping statistics ---
2 packets transmitted, 0 received, +2 errors, 100% packet loss, time 1007ms</screen>

    <para>Exemple de succès :</para>

<screen><prompt>$</prompt> ping -c 2 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2:<co xml:id='icmpfrom'/> icmp_req=1<co xml:id='icmpseq'/> ttl=255<co xml:id='icmpttl'/> time=1.61 ms
64 bytes from 192.168.1.2: icmp_req=2 ttl=255 time=1.16 ms

--- 192.168.1.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 1.161/1.388/1.616/0.230 ms</screen>

  <calloutlist>
  <callout arearefs='icmpfrom'>
    <para>Adresse de réponse du message ICMP : destinataire du
    test.</para>
  </callout>
  <callout arearefs='icmpseq'>
    <para>Numéro de séquence du message.</para>
  </callout>
  <callout arearefs='icmpttl'>
    <para>La valeur du champ <acronym>TTL</acronym> d'un paquet
    <acronym>IP</acronym> correspond au nombre d'interfaces de routage
    traversées pour arriver à l'interface.</para>
  </callout>
  </calloutlist>
    </listitem>
    </varlistentry>
  </variablelist>


  <bridgehead xml:id='conf-intf-lan.icmp.dns' renderas='sect2'>Comment valider
  la résolution des noms de domaines en plus de l'interconnexion réseau ?</bridgehead>

  <para>La commande <command>ping</command> est aussi utile pour savoir si la
  résolution des noms d'hôtes fonctionne correctement. Dans ce cas, on fait
  appel à un service Internet appelé <wordasword>Domain Name
  Service</wordasword> (<acronym>DNS</acronym>). Cet appel au service
  <acronym>DNS</acronym> suppose que la fonction
  <wordasword>resolver</wordasword> soit correctement configurée.</para>
	
<screen><prompt>$</prompt> ping -c 2 www.nic.fr<co xml:id='icmpname'/>
PING web.nic.fr (192.134.4.20)<co xml:id='icmpres'/> 56(84) bytes of data.
64 bytes from web.nic.fr (192.134.4.20): icmp_req=1 ttl=54 time=39.1 ms
64 bytes from web.nic.fr (192.134.4.20): icmp_req=2 ttl=54 time=34.7 ms

--- web.nic.fr ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 34.754/36.960/39.167/2.214 ms</screen>

  <calloutlist>
  <callout arearefs="icmpname">
    <para>Utilisation de la commande <command>ping</command> avec un nom d'hôte
    au lieu d'une adresse <acronym>IP</acronym>.</para>
  </callout>
  <callout arearefs="icmpres">
    <para>Affichage de la correspondance entre le nom de l'hôte et son adresse
    <acronym>IP</acronym>.</para>
  </callout>
  </calloutlist>

  <para>En cas d'échec sur la résolution des noms, il faut contrôler la
  validité des informations dans les deux fichiers suivants :</para>

  <variablelist>
    <varlistentry>
    <term><filename>/etc/resolv.conf</filename></term>
    <listitem>
<screen>search &lt;domaine-fai>.fr
nameserver &lt;addr dns-fai></screen>

    <para>La première ligne désigne le nom du domaine auquel l'interface de
    l'hôte appartient. La deuxième ligne l'adresse <acronym>IP</acronym> du
    serveur de noms récursif du forunisseur d'accès Internet.</para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term><filename>/etc/host.conf</filename></term>
    <listitem>
<screen>order hosts, bind
multi on</screen>

    <para>L'ordre de recherche des noms d'hôtes est important. Dans le cas
    présenté, la recherche est d'abord effectuée localement puis à l'aide du
    service <acronym>DNS</acronym>.</para>
    </listitem>
    </varlistentry>
  </variablelist>
  </sect1>

  <sect1 xml:id='conf-intf-lan.dns'>
    <title>Protocole DNS</title>

    <para>L'opération de <emphasis>résolution</emphasis> consiste à faire la
    correspondance entre un nom de domaine et son adresse
    <acronym>IP</acronym>. Pour effectuer ces opérations de résolution on
    utilise un service Internet particulier appelé <wordasword>Domain Name
    System</wordasword> ou <acronym>DNS</acronym>. Ce service fonctionne sur le
    même mode qu'un annuaire téléphonique dans lequel les chiffres du numéro de
    téléphone sont remplacés par les chiffres de l'adresse
    <acronym>IP</acronym> et le nom d'abonné est remplacé par le nom de
    domaine.</para>
    
    <para>La commande historique <command>host</command> effectue l'opération
    de recherche de l'adresse <acronym>IP</acronym> correspondant à un nom
    d'hôte réseau enregistré sur le service <acronym>DNS</acronym> et vice
    versa :</para>

    <itemizedlist>
      <listitem>
        <para>Résolution d'un nom d'hôte.</para>
<screen>$ host www.nic.fr
www.nic.fr is an alias for rigolo.nic.fr.
rigolo.nic.fr has address 192.134.4.20</screen>
      </listitem>
      <listitem>
        <para>Résolution d'une adresse <acronym>IP</acronym>.</para>
<screen>$ host 192.134.4.20
20.4.134.192.in-addr.arpa domain name pointer rigolo.nic.fr.</screen>
      </listitem>
    </itemizedlist>

    <para>Il existe une autre commande historique qui donne davantage
    d'informations sur les jeux de questions/réponses
    <acronym>DNS</acronym> : <command>nslookup</command>. Cette commande
    est disponible sur les systèmes Micro$oft ; elle est accessible à
    partir d'un <wordasword>Shell</wordasword>. Dans l'univers Unix/Linux,
    cette commande est abandonnée au profit de la commande
    <command>dig</command> qui offre davantage d'options et des messages
    d'erreurs plus rigoureux. Voici un exemple d'exécution à partir du même
    exemple que ci-dessus.</para>

    <para>Exemple de requête <acronym>DNS</acronym> de type
    <acronym>A</acronym> qui renvoie l'adresse <acronym>IP</acronym>
    correspondant à un nom d'hôte.</para>

<screen>$ dig www.nic.fr

; &lt;&lt;>> DiG 9.4.2 &lt;&lt;>> www.nic.fr
;; global options:  printcmd
;; Got answer:
;; ->>HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 355
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 7, ADDITIONAL: 9

;; QUESTION SECTION:<co xml:id='dig_a.question'/>
;www.nic.fr.                    IN      A

;; ANSWER SECTION:<co xml:id='dig_a.answer'/>
www.nic.fr.             163437  IN      CNAME   rigolo.nic.fr.
rigolo.nic.fr.          163437  IN      A       192.134.4.20

;; AUTHORITY SECTION:<co xml:id='dig_a.authority'/>
nic.fr.                 70358   IN      NS      ns2.nic.fr.
nic.fr.                 70358   IN      NS      ns1.nic.fr.
nic.fr.                 70358   IN      NS      ns1.oleane.net.
nic.fr.                 70358   IN      NS      dns.inria.fr.
nic.fr.                 70358   IN      NS      ns-sec.ripe.net.
nic.fr.                 70358   IN      NS      ns0.oleane.net.
nic.fr.                 70358   IN      NS      ns3.nic.fr.

;; ADDITIONAL SECTION:<co xml:id='dig_a.additional'/>
dns.inria.fr.           23315   IN      A       193.51.208.13
ns0.oleane.net.         133065  IN      A       194.2.0.30
ns1.nic.fr.             153582  IN      A       192.93.0.1
ns1.nic.fr.             153582  IN      AAAA    2001:660:3005:1::1:1
ns2.nic.fr.             153582  IN      A       192.93.0.4
ns2.nic.fr.             153582  IN      AAAA    2001:660:3005:1::1:2
ns3.nic.fr.             70358   IN      A       192.134.0.49
ns3.nic.fr.             70358   IN      AAAA    2001:660:3006:1::1:1
ns-sec.ripe.net.        169587  IN      A       193.0.0.196

;; Query time: 22 msec<co xml:id='dig_a.time'/>
;; SERVER: 127.0.0.1#53(127.0.0.1)<co xml:id='dig_a.server'/>
;; WHEN: Mon Mar  3 17:27:29 2008
;; MSG SIZE  rcvd: 395</screen>

    <para>Exemple de requête <acronym>DNS</acronym> de type
    <acronym>PTR</acronym> qui renvoie le nom d'hôte correspondant à une
    adresse <acronym>IP</acronym>.</para>

<screen>$ dig -x 192.134.4.20

; &lt;&lt;>> DiG 9.4.2 &lt;&lt;>> -x 192.134.4.20
;; global options:  printcmd
;; Got answer:
;; ->>HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22357
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 3, ADDITIONAL: 6

;; QUESTION SECTION:<co xml:id='dig_ptr.question'/>
;20.4.134.192.in-addr.arpa.     IN      PTR

;; ANSWER SECTION:<co xml:id='dig_ptr.answer'/>
20.4.134.192.in-addr.arpa. 163116 IN    PTR     rigolo.nic.fr.

;; AUTHORITY SECTION:<co xml:id='dig_ptr.authority'/>
4.134.192.in-addr.arpa. 163116  IN      NS      ns2.nic.fr.
4.134.192.in-addr.arpa. 163116  IN      NS      ns3.nic.fr.
4.134.192.in-addr.arpa. 163116  IN      NS      ns1.nic.fr.

;; ADDITIONAL SECTION:<co xml:id='dig_ptr.additional'/>
ns3.nic.fr.             70037   IN      A       192.134.0.49
ns3.nic.fr.             70037   IN      AAAA    2001:660:3006:1::1:1
ns1.nic.fr.             153261  IN      A       192.93.0.1
ns1.nic.fr.             153261  IN      AAAA    2001:660:3005:1::1:1
ns2.nic.fr.             153261  IN      A       192.93.0.4
ns2.nic.fr.             153261  IN      AAAA    2001:660:3005:1::1:2

;; Query time: 2 msec<co xml:id='dig_ptr.time'/>
;; SERVER: 127.0.0.1#53(127.0.0.1)<co xml:id='dig_ptr.server'/>
;; WHEN: Mon Mar  3 17:32:50 2008
;; MSG SIZE  rcvd: 256</screen>

    <para>Ces exemples montrent que la commande <command>dig</command> donne
    des informations très complètes sur l'état des requêtes.</para>
    
    <calloutlist>
      <callout arearefs='dig_a.question dig_ptr.question'>
        <para>Le champ <acronym>QUESTION</acronym> reprend le terme de la requête
        émise.</para>
      </callout>
      <callout arearefs='dig_a.answer dig_ptr.answer'>
        <para>Le champ <acronym>ANSWER</acronym> donne la réponse à la
        requête.</para>
      </callout>
      <callout arearefs='dig_a.authority dig_ptr.authority'>
	<para>Le champ <acronym>AUTHORITY</acronym> donne la liste des serveurs
	de noms qui ont autorité sur les enregistrements
	<acronym>DNS</acronym>. Ce sont les seuls serveurs aptes à fournir une
	réponse aux requêtes sur le domaine concerné.</para>
      </callout>
      <callout arearefs='dig_a.additional dig_ptr.additional'>
	<para>Le champ <acronym>ADDITIONAL</acronym> donne les adresses
	<acronym>IP</acronym> des serveurs <acronym>DNS</acronym> de référence
	du domaine.</para>
      </callout>
      <callout arearefs='dig_a.time dig_ptr.time'>
	<para>Le champ <acronym>Query time</acronym> donne le temps de
	traitement de la requête. La valeur obtenue permet de déduire si le
	serveur interrogé a déjà la réponse en mémoire cache ou non.</para>
      </callout>
      <callout arearefs='dig_a.server dig_ptr.server'>
	<para>Le champ <acronym>SERVER</acronym> identifie le serveur qui a
	pris la requête <acronym>DNS</acronym> en charge.</para>
      </callout>
    </calloutlist>

    <para>Pour obtenir la syntaxe de toutes les options disponibles, il faut
    accéder aux pages de manuels Unix :</para>
    <itemizedlist>
      <listitem>
      <para>via la console avec les commandes <userinput>man host</userinput>
      et <userinput>man dig</userinput>.</para>
      </listitem>
      <listitem>
      <para>via l'interface graphique avec le centre d'aide KDE :
      <menuchoice>
      <guimenu>Pages de manuels Unix</guimenu>
      <guimenuitem>Section 1 Commandes utilisateur</guimenuitem>
      <guimenuitem>dig</guimenuitem>
      </menuchoice>.</para>
      </listitem>
    </itemizedlist>

    <para>Pour aller plus loin dans l'étude du fonctionnement du service de
    noms de domaines, il est conseillé de lire le support &url.sysadm-net.dns;.</para>
  </sect1>

  <sect1 xml:id='conf-intf-lan.tp'>
    <title>Travaux pratiques</title>

  <sect2 xml:id='tp.observation'>
    <title>Relevé des paramètres existants</title>

  <para>On suppose que chaque client dispose d'une interface déjà configurée
  avec un accès à un réseau local Ethernet et à d'autres réseaux ; l'Internet
  par exemple.</para>
  
  <!-- topologie du réseau TP : observation -->
  <screen>&topologie.observation;</screen>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Quelle est la commande qui permet de visualiser la configuration
      d'une ou plusieurs interfaces réseau ?</para>
      </question>
      <answer>
      <para>Voir <xref linkend='conf-intf-lan.network-layer'/>.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Quelles sont les adresses de niveau liaison
      (<acronym>MAC</acronym>) et de niveau réseau (<acronym>IP</acronym>) de
      l'interface Ethernet ?</para>
      </question>
      <answer>
      <para>Voir <xref linkend='conf-intf-lan.network-layer'/>.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Quelles sont les indications données par la configuration qui
      montrent que cette interface est active ?</para>
      </question>
      <answer>
      <para>Voir <xref linkend='conf-intf-lan.network-layer'/>.</para>
      </answer>
    </qandaentry>

    <qandaentry>
      <question>
      <para>Quel est le rôle des adresses <acronym>MAC</acronym> par rapport
      aux adresses <acronym>IP</acronym> ?</para>
      </question>
      <answer>
      <para>Retrouver les fonctions de localisation des niveaux liaison et
      réseau.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Quelles indications sont fournies par le masque de réseau et
      l'adresse de diffusion ?</para>
      </question>
      <answer>
      <para>Retrouver les «limites» de l'adressage logique et de l'adressage
      matériel.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Comment déduire l'adresse <acronym>IP</acronym> de l'interface de
      la passerelle par défaut à partir des éléments précédents ?</para>
      </question>
      <answer>
      <para>Généralement, il s'agit de la première adresse utile du réseau ou
      sous-réseau auquel l'hôte est connecté.</para>
      <para>Cette question sera à nouveau traitée dans la partie <link
      linkend='conf-intf-lan.routage'>routage</link>.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Comment visualiser la table de correspondance entre les adresses
      <acronym>MAC</acronym> et <acronym>IP</acronym> connues de votre
      station ?</para>
      </question>
      <answer>
      <para>Retrouver la commande à utiliser et observer l'évolution des
      entrées de la table.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Comment forcer l'ajout d'une entrée dans la table
      <acronym>ARP</acronym> de votre station ?</para>
      </question>
      <answer>
      <para>Retrouver la commande à utiliser et visualiser le(s)
      résultat(s).</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Pourquoi des entrées apparaissent dans la table
      <acronym>ARP</acronym> sans action particulière ?</para>
      </question>
      <answer>
      <para>Essayer de repérer les stations du réseau local qui ont contacté
      votre station.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Pourquoi l'adresse <acronym>MAC</acronym> de la passerelle par
      défaut est-elle «presque» toujours présente dans la table d'un poste
      client ?</para>
      </question>
      <answer>
      <para>Retrouver la fréquence à laquelle les entrées de la table
      <acronym>ARP</acronym> sont rafraîchies. Cette fréquence est-elle
      fixe ?</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Pourquoi l'adresse <acronym>MAC</acronym> de la passerelle par
      défaut est-elle «rafraîchie» après un test de la commande
      <command>ping</command> utilisant un nom d'hôte ?</para>
      </question>
      <answer>
      <para>Revoir la configuration de la résolution des noms d'hôtes et
      localiser le serveur de noms vers lequel toutes les requêtes
      <acronym>DNS</acronym> sont dirigées.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Comment vérifier que le serveur <acronym>DNS</acronym> indiqué dans
      les fichiers de configuration prend bien en charge les requêtes émises
      par votre station ?</para>
      </question>
      <answer>
      <para>Retrouver la commande à utiliser, consulter les pages de manuels
      correspondantes et repérer l'option qui permet de visualiser le détail
      des échanges entre client et serveur <acronym>DNS</acronym>.</para>
      </answer>
    </qandaentry>
  </qandaset>
  </sect2>

  <sect2 xml:id='tp.multi'>
    <title>Reconfiguration de l'interface</title>

  <para>Avec la configuration ci-dessous, il est possible de changer
  l'adressage réseau des postes clients par groupes en utilisant le routage
  inter VLAN.</para>
  
  <!-- topologie du réseau TP : multi-réseaux -->
  <screen>&topologie.multi;</screen>

  <para>Voici un exemple de plan d'adressage pour 4 groupes de
  postes :</para>
  
  <!-- plan d'adressage multi-réseaux -->
  <screen>&topologie.multi.addr;</screen>
  
  <para>Les adresses <acronym>IP</acronym> des sous-interfaces du routeur
  <literal>fa0/0.2</literal> à <literal>fa0/0.5</literal> sont données à titre
  indicatif. Elles peuvent être modifiées à volonté. Une fois les questions
  précédentes traitées, il faut rebrasser la connexion du poste sur un des
  groupes de prises du commutateur <citetitle>Switch2</citetitle>.</para>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
	<para>A partir de l'adresse de l'interface du routeur utilisée, quels
	sont les paramètres de l'interface Ethernet du poste ?</para>
      </question>
      <answer>
	<para>Partant du rôle de l'interface du routeur pour le client,
	déterminer les adresses : réseau, masque de réseau, passerelle par
	défaut et diffusion. Il ne reste qu'à choisir une adresse pour le
	poste.</para>
	<para>Utiliser la commande <command>ifconfig</command> pour appliquer
	ces paramètres.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
	<para>Comment valider la connectivité vers l'Internet ?</para>
      </question>
      <answer>
        <para>Reprendre la séquence des tests ICMP.</para>
      </answer>
    </qandaentry>
  </qandaset>

  <para>Arrivé à cette étape, les communications entre postes du même réseau
  local sont possibles mais il manque un élément important pour gagner la
  connectivité vers les autres réseaux : la passerelle par défaut qui doit
  renseigner toutes les routes vers les autres réseaux
  <acronym>IP</acronym>.</para>

  <para>Cette passerelle par défaut apparaît dans la <emphasis>table de
  routage</emphasis>. Même sur un poste client, une table de routage est
  nécessaire ! C'est l'objet du point suivant.</para>
  </sect2>
</sect1>

<sect1 xml:id='conf-intf-lan.routage'>
  <title>Table de routage locale</title>
  
  <para>Le routage est un sujet à part entière auquel il faut consacrer
  beaucoup de temps pour avoir une bonne compréhension des échanges entre
  plusieurs réseaux. L'objectif de cette section est limité à l'observation des
  routes connues de l'interface de l'hôte et à la détection de pannes.</para>

  <sect2 xml:id='conf-intf-lan.route.command'>
    <title>Commande <command>route</command></title>

    <para>La commande <command>route</command>, tout comme
    <command>ifconfig</command> sert à la fois à connaître l'état de la table
    de routage de l'hôte et à configurer de nouvelles routes au besoin.</para>

    <para>Cette commande n'a rien à voir avec le routage dynamique qui
    fonctionne sur un routeur. Elle ne sert qu'à poser des routes statiques
    entre interfaces.</para>
    
<screen># route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags<co xml:id='routeflag'/> Metric Ref    Use Iface<co xml:id='routeif'/>
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</screen>
    <calloutlist>
      <callout arearefs='routeflag'>
      <para>Indicateurs d'état :</para>
      <itemizedlist>
        <listitem>
        <para><abbrev>U</abbrev> : Up ; l'interface est active.</para>
        </listitem>
        <listitem>
        <para><abbrev>H</abbrev> : Host ; désigne un hôte.</para>
        </listitem>
        <listitem>
        <para><abbrev>G</abbrev> : Gateway ; C'est l'interface à partir de
        laquelle on atteint les autres hôtes/réseaux.</para>
        </listitem>
      </itemizedlist>
      </callout>
      <callout arearefs='routeif'>
	<para>Interface Ethernet baptisée <systemitem>eth0</systemitem> sur les
	systèmes GNU/Linux.</para>
      </callout>
    </calloutlist>

    <para>Pour obtenir la syntaxe de toutes les options disponibles, il faut
    accéder aux pages de manuels Unix :</para>
    <itemizedlist>
      <listitem>
      <para>via la console avec la commande <userinput>man
      route</userinput>.</para>
      </listitem>
      <listitem>
      <para>via l'interface graphique avec le centre d'aide
      KDE :<menuchoice>
      <guimenu>Pages de manuels Unix</guimenu>
      <guimenuitem>Section 8 Administration système</guimenuitem>
      <guimenuitem>route</guimenuitem>
      </menuchoice>.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2 xml:id='conf-intf-lan.traceroute'>
    <title>Commande <command>traceroute</command></title>

    <para><command>traceroute</command> renvoie les informations sur la route
    suivie pour atteindre un hôte. Le résultat obtenu donne la liste des routeurs
    traversés.</para>
  
<screen># traceroute www.nic.fr
traceroute to rigolo.nic.fr (192.134.4.20), 30 hops max, 38 byte packets
 1  toulouse-50-254-gw.dial.proxad.net (212.27.50.254)  24.806 ms  21.489 ms  21.530 ms
 2  paris11-2-p1.routers.proxad.net (212.27.32.225)  43.597 ms  33.325 ms  33.270 ms
 3  paris11-1-p1.routers.proxad.net (212.27.32.226)  149.188 ms  129.723 ms  147.430 ms
 4  sfinx.routers.proxad.net (212.27.32.167)  126.530 ms  138.881 ms  126.858 ms
 5  ri-renater.gix-paris.ft.net (194.68.129.34)  107.966 ms  132.974 ms  135.544 ms
 6  nio-i.cssi.renater.fr (193.51.206.57)  144.283 ms  122.517 ms  127.308 ms
 7  193.51.206.146 (193.51.206.146)  132.595 ms  145.998 ms  148.399 ms
 8  stlambert1.rerif.ft.net (193.48.53.102)  124.040 ms  260.685 ms  108.853 ms
 9  inria-rocquencourt-atm.rerif.ft.net (193.48.53.226)  38.604 ms  167.956 ms  143.657 ms
10  rocq-gw.inria.fr (192.93.122.2)  151.084 ms  96.052 ms  100.700 ms
11  nic-gw.inria.fr (192.93.1.112)  126.699 ms  153.840 ms *
12  rigolo.nic.fr (192.134.4.20)  155.644 ms  150.290 ms  191.674 ms</screen>

    <para>Dans l'exemple ci-dessus, l'hôte recherché a été trouvé. En cas de
    défaut, cette commande est très utile pour repérer le routeur sur lequel se
    situe le problème d'interconnexion.</para>

    <para>Les tests <acronym>ICMP</acronym> effectués avec la commande
    <command>ping</command> ne permettent pas de localiser le point de rupture
    de la communication entre deux hôtes distants. La commande
    <command>traceroute</command> identifie tous les équipements
    d'interconnexion réseau traversés.</para>

    <para>Le principe de ce tracé de route est le suivant :</para>
    <itemizedlist>
      <listitem>
      <para>Émettre un premier message avec la valeur 1 dans le champ
      <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>.</para>
      </listitem>
      <listitem>
      <para>L'équipement d'interconnexion qui reçoit ce message décrémente la
      valeur du champ <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>
      et obtient 0. Il jette donc le message et émet un message
      <acronym>ICMP</acronym> à destination de l'émetteur indiquant qu'il est
      impossible d'atteindre la destination.</para> 
      </listitem>
      <listitem>
      <para>Émettre un second message avec la valeur 2 dans le champ
      <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>.</para>
      </listitem>
      <listitem>
      <para>Cette fois-ci, c'est le second équipement d'interconnexion qui
      décrémentera la valeur pour obtenir 0. Ce sera donc à ce second
      équipement d'émettre un message <acronym>ICMP</acronym> à destination de
      l'émetteur.</para>
      </listitem>
      <listitem>
      <para>Ainsi de suite avec les valeurs 3, 4, etc. Pour le champ
      <acronym>TTL</acronym> de l'en-tête <acronym>IP</acronym>.</para>
      </listitem>
    </itemizedlist>

    <para>L'utilisation de la commande <command>traceroute</command> est de
    plus en plus limitée par les divers systèmes de filtrage réseau et pour
    contrer le travail des outils automatisés dont l'objectif est de relever la
    topologie d'un réseau à distance.</para>
  
    <para>La méthode la plus immédiate pour bloquer la commande
    <command>traceroute</command> consiste à bloquer en entrée d'un périmètre
    les ports UDP de la plage 33434 à 33600.</para>

    <para>Pour autant, la fonction <command>traceroute</command> est très utile
    pour qualifier la validité d'une communication. Pour essayer de contourner
    les systèmes de filtrage, la commande <command>traceroute</command> offre
    de nombreuses options telles que la possibilité de fixer les numéros des
    ports source et destination ou la possibilité de choisir le protocole de
    couche transport.</para>

    <para>Voici un exemple élémentaire permettant de caractériser la différence
    de fonctionnement entre les deux protocoles de couche transport.</para>

    <itemizedlist>
      <listitem>
      <para>Utilisation classique du protocole <acronym>UDP</acronym> :</para>

<screen># traceroute www.neuf.fr
traceroute to www.neuf.fr (212.30.118.74), 30 hops max, 60 byte packets
&lt;snipped&gt;

 3  ge-2-1-0-0.nctou102.Toulouse.francetelecom.net (193.249.214.14)  58.498 ms  59.478 ms  60.458 ms
 4  xe-3-1-3-0.nrpoi202.Poitiers.francetelecom.net (81.253.131.178)  68.446 ms  70.425 ms  73.405 ms
 5  xe-0-1-0-0.ntaub102.Aubervilliers.francetelecom.net (193.251.126.202)  84.394 ms  87.372 ms  89.350 ms
 6  81.253.181.158 (81.253.181.158)  91.335 ms  55.605 ms  55.921 ms
 7  41-197-118-80.kaptech.net (80.118.197.41)  56.919 ms  55.929 ms  57.934 ms
 8  242-193-118-80.kaptech.net (80.118.193.242)  198.938 ms  191.932 ms  190.931 ms
 9  212.94.163.13 (212.94.163.13)  55.931 ms  55.923 ms  58.930 ms
10  10.5.39-62.rev.gaoland.net (62.39.5.10)  57.936 ms  57.922 ms  55.933 ms
11  Vlan4053.9velizy1-0-ro-t-3.9tel.net (213.203.124.181)  56.930 ms  56.934 ms  57.938 ms
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *</screen>
      </listitem>
      <listitem>
      <para>Utilisation du protocole <acronym>TCP</acronym> :</para>

<screen># # traceroute -T www.neuf.fr
traceroute to www.neuf.fr (212.30.118.74), 30 hops max, 60 byte packets
&lt;snipped&gt;

 3  ge-2-1-0-0.nctou102.Toulouse.francetelecom.net (193.249.214.14)  55.474 ms  58.456 ms  60.440 ms
 4  xe-3-1-2-0.nrpoi202.Poitiers.francetelecom.net (81.253.130.122)  70.428 ms  72.403 ms  74.391 ms
 5  xe-0-1-0-0.ntaub102.Aubervilliers.francetelecom.net (193.251.126.202)  85.373 ms  87.352 ms  90.335 ms
 6  81.253.181.130 (81.253.181.130)  93.317 ms  55.676 ms  55.927 ms
 7  41-197-118-80.kaptech.net (80.118.197.41)  148.936 ms  139.944 ms  137.946 ms
 8  242-193-118-80.kaptech.net (80.118.193.242)  58.945 ms  164.900 ms  163.940 ms
 9  212.94.163.13 (212.94.163.13)  56.941 ms  55.938 ms  57.951 ms
10  10.5.39-62.rev.gaoland.net (62.39.5.10)  55.949 ms  56.950 ms  55.942 ms
11  Vlan4053.9velizy1-0-ro-t-3.9tel.net (213.203.124.181)  56.949 ms  56.969 ms  56.937 ms
12  62.62.153.54 (62.62.153.54)  57.966 ms  56.963 ms  57.958 ms
13  ilma.finnois.isp.9tel.net (212.30.118.74)  57.924 ms  56.989 ms  56.956 ms</screen>
      </listitem>
    </itemizedlist>

    <para>Pour obtenir la syntaxe de toutes les options disponibles, il faut
    accéder aux pages de manuels Unix :</para>
    <itemizedlist>
      <listitem>
      <para>via la console avec la commande <userinput>man
      traceroute</userinput>.</para>
      </listitem>
      <listitem>
      <para>via l'interface graphique avec le centre d'aide
      KDE :<menuchoice>
      <guimenu>Pages de manuels Unix</guimenu>
      <guimenuitem>Section 8 Administration système</guimenuitem>
      <guimenuitem>traceroute</guimenuitem>
      </menuchoice>.</para>
      </listitem>
    </itemizedlist>

    <para>Il existe quantité d'outils qui permettent d'avancer plus loin dans
    une utilisation plus subtile des valeurs du champ <acronym>TTL</acronym> de
    l'en-tête <acronym>IP</acronym>. Une technique appelée
    <wordasword>firewalking</wordasword> a connu son heure de gloire au début
    des années 2000. De nos jours, les pare-feux et les serveurs mandataires
    (<wordasword>proxy</wordasword>) manipulent ces valeurs de façon à masquer
    le nombre réel de sauts pour atteindre les hôtes d'une
    infrastructure.</para>
</sect2>

<sect2 xml:id='conf-intf-lan.tp.route'>
  <title>Travaux pratiques</title>

  <qandaset defaultlabel='number'>
    <qandaentry>
      <question>
      <para>Comment repérer les paramètres de la passerelle par défaut dans
      la table de routage de votre station ?</para>
      </question>
      <answer>
      <para>Relever l'indicateur de passerelle puis l'adresse
      <acronym>IP</acronym> et le masque réseau.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>La passerelle par défaut peut-elle appartenir à un autre réseau
      que celui de la station ?</para>
      </question>
      <answer>
      <para>La fonction d'une passerelle par défaut est de fournir une voie de
      communication vers tous les autres réseaux. Compléter le raisonnement à
      partir du cas où cette voie de communication n'appartient pas au réseau
      local.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Quel est le rôle de la première entrée de la table de
      routage ?</para>
      </question>
      <answer>
      <para>Normalement, la détermination du chemin de communication vers les
      hôtes du réseau local ne doit pas passer par la passerelle par
      défaut. Compléter le raisonnement sur le mode de communication avec les
      hôtes du réseau local.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
      <para>Reconstituer les étapes décrites lors de l'exécution de la commande
      <command>traceroute</command> ?</para>
      </question>
      <answer>
      <para>Identifier la station, la passerelle par défaut et les éventuels
      routeurs en notant les équipements d'interconnexion traversés. Compléter
      un schéma sous la forme indiquée ci-dessous :</para>
<screen>  |.....  ---[TTL=1]-->|@IP:           |@IP:           |@IP:           |@IP:
.------,~ ---[TTL=2]   | ---[TTL= ]    |               |               |
| PC   |' ---[TTL=3]   | ---[TTL= ]    | ---[TTL= ]    |               |
|Client|| ---[TTL= ]   | ---[TTL= ]    | ---[TTL= ]    | ---[TTL= ]    |
\------ / ---[TTL= ]   | ---[TTL= ]    | ---[TTL= ]    | ---[TTL= ]    | ---[TTL= ]
 ======/  ...</screen>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
	<para>Relativement à la question précédente, quelle est la
	signification des différents champs de chaque ligne affichée par la
	commande <command>traceroute</command> ?</para>
      </question>
      <answer>
	<para>Utiliser les pages de manuels de la commande pour identifier les
	champs.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
	<para>Dans quelles conditions peut-on obtenir des caractères '*' à la
	place des champs usuels ?</para>
      </question>
      <answer>
	<para>Toujours à partir des pages de manuels de la commande, identifier
	les limites de l'utilisation de cette commande.</para>
      </answer>
    </qandaentry>
  </qandaset>
</sect2>
</sect1>

<sect1 xml:id='conf-intf-lan.procfs'>
  <title>Fonctions réseau d'une interface</title>

  <para>Sur tous les systèmes, un certain nombre de paramètres sont actifs par
  défaut sur les interfaces réseau. Avec le noyau Linux, ces paramètres sont
  placés dans le système de fichiers virtuel <filename
  class='directory'>/proc</filename>.</para>
  
  <sect2 xml:id='show_proc'>
    <title>Comment visualiser les paramètres du noyau ?</title>
  
  <para>Dans le noyau Linux, la granularité du paramétrage de la pile de
  protocoles TCP/IP est très fine. Aussi le nombre de paramètres est important.
  Il suffit de visualiser le résultat des commandes <userinput>ls
  /proc/sys/net/ipv4/</userinput> ou <userinput>sysctl -A |grep net</userinput>
  pour le constater.</para>

  <para>Voici un petit script appelé <filename>show_proc.sh</filename> qui
  permet de visualiser les paramètres par protocole ou catégorie et leurs
  valeurs :</para>

<screen>#!/bin/bash

for param in `find /proc/sys -type f -name "*$1*"`; do
 echo $param = `cat $param`
 done</screen>

  <para>Dans le cas des réglages <acronym>ICMP</acronym> on obtient le résultat
  suivant avec un noyau de distribution standard :</para>

<screen># ./bin/show_proc.sh icmp
/proc/sys/net/ipv4/netfilter/ip_conntrack_icmp_timeout = 30
/proc/sys/net/ipv4/icmp_ratemask = 6168
/proc/sys/net/ipv4/icmp_ratelimit = 1000
/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses = 0
/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts = 0
/proc/sys/net/ipv4/icmp_echo_ignore_all = 0</screen>
  </sect2>

  <sect2 xml:id='change_proc'>
    <title>Comment changer les valeurs des paramètres ?</title>

  <para>Pour changer les valeurs par défaut attribuées dans le noyau, il existe
  au moins trois solutions :</para>

  <itemizedlist>
    <listitem>
    <para>La première solution consiste à affecter les valeurs
    individuellement. Prenons l'exemple célèbre de la fonction de routage des
    paquets <acronym>IP</acronym> du noyau :</para>

<screen>echo 1 > /proc/sys/net/ipv4/ip_forward</screen>
    </listitem>
    <listitem>
    <para>La seconde solution utilise le fichier de configuration
    <filename>/etc/sysctl.conf</filename> de la commande
    <command>sysctl</command> appartenant au paquet
    <application>procps</application>. Ce fichier de configuration n'est pas
    limité aux fonctions réseau du noyau Linux comme le montre le résultat de
    la commande <userinput>sysctl -A</userinput>. Voici un exemple très simple
    de fichier <filename>/etc/sysctl.conf</filename> :</para>

<screen># Activation de protection contre les mauvais messages d'erreurs ICMP
net.ipv4.icmp_ignore_bogus_error_responses=1</screen>

    <para>La commande <userinput>sysctl -p</userinput> active l'ensemble des
    valeurs indiquées dans le fichier ce configuration. On obtient
    alors :</para>

<screen># ./bin/show_proc.sh icmp_ignore_bogus_error_responses
/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses = 1</screen>

    <para>Comme le fichier <filename>/etc/sysctl.conf</filename> est lu à
    chaque démarrage du système, les valeurs des paramètres ajustés seront
    reprises. Ce fichier de configuration est un moyen pratique de conserver
    les paramètres personnels des fonctions réseau d'une interface.</para>
    </listitem>
    <listitem>
    <para>La troisième solution est présentée dans la section
    &url.securing-debian-howto;.</para>
    </listitem>
  </itemizedlist>
  </sect2>

  <sect2 xml:id='conf-intf-lan.sysctl'>
    <title>Travaux pratiques</title>
    
    <para>Voici un exemple de fichier de configuration
    <filename>/etc/sysctl.conf</filename> type :</para>
<screen># Refuser la prise en charge des requêtes ARP pour d'autres hôtes
net.ipv4.conf.all.proxy_arp = 0

# Ignorer les mauvais messages d'erreurs ICMP
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Ignorer les messages de diffusion ICMP
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Journaliser les adresses sources falsifiées ou non routables
net.ipv4.conf.all.log_martians = 1

# Refuser les adresses sources falsifiées ou non routables
net.ipv4.conf.all.rp_filter = 1

# Refuser les messages ICMP redirect
net.ipv4.conf.all.accept_redirects = 0

net.ipv4.conf.all.send_redirects = 0

# Refuser le routage source
net.ipv4.conf.all.accept_source_route = 0</screen>

  <qandaset defaultlabel='number'>
    <qandaentry>
    <question>
    <para>Quels sont les tests de communication ICMP à effectuer pour mettre en
    évidence le résultat du paramètre
    <literal>net.ipv4.icmp_echo_ignore_broadcasts = 1</literal> ?</para>
    </question>
    <answer>
    <para>Retrouver l'adresse de diffusion du réseau local à utiliser avec la
    commande <command>ping</command>.</para>
    </answer>
    </qandaentry>
    <qandaentry>
    <question>
    <para>Quels sont les tests de communication ICMP à effectuer pour mettre en
    évidence la journalisation des adresses falsifiées ?</para>
    </question>
    <answer>
    <para>La commande <command>ping</command> ne permet pas de modifier
    l'adresse source d'un message ICMP de type 8
    (<literal>echo request</literal>). Il est donc nécessaire d'utiliser
    un autre outil tel que <command>hping2</command>. Voici 2 exemples
    d'utilisation de cette commande :</para>
    <itemizedlist>
    <listitem>
    <para>Syntaxe équivalente à celle de la commande
    <command>ping</command> :</para>

<screen># hping2 -n -c 4 -1 192.168.1.1
HPING 192.168.1.1 (eth1 192.168.1.1): icmp mode set, 28 headers + 0 data bytes
len=46 ip=192.168.1.1 ttl=64 xml:id=60429 icmp_seq=0 rtt=1.5 ms
len=46 ip=192.168.1.1 ttl=64 xml:id=60430 icmp_seq=1 rtt=1.4 ms
len=46 ip=192.168.1.1 ttl=64 xml:id=60431 icmp_seq=2 rtt=1.4 ms
len=46 ip=192.168.1.1 ttl=64 xml:id=60432 icmp_seq=3 rtt=1.4 ms

--- 192.168.1.1 hping statistic ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max = 1.4/1.5/1.5 ms</screen>
    </listitem>
    <listitem>
    <para>Syntaxe utilisant l'adresse source falsifiée
    <literal>192.168.2.2</literal> :</para>

<screen># hping2 -n -c 4 -1 -a 192.168.2.2 192.168.1.1
HPING 192.168.1.1 (eth1 192.168.1.1): icmp mode set, 28 headers + 0 data bytes

--- 192.168.1.1 hping statistic ---
4 packets transmitted, 0 packets received, 100% packet loss
round-trip min/avg/max = 0.0/0.0/0.0 ms</screen>

    <para>Résultat produit dans le journal système de l'hôte
    <literal>192.168.1.1</literal> :</para>

<screen>kernel: martian source 192.168.1.1 from 192.168.2.2, on dev eth0
kernel: ll header: 00:04:75:fd:13:cd:00:0d:bc:ef:a6:8e:08:00
kernel: martian source 192.168.1.1 from 192.168.2.2, on dev eth0
kernel: ll header: 00:04:75:fd:13:cd:00:0d:bc:ef:a6:8e:08:00
kernel: martian source 192.168.1.1 from 192.168.2.2, on dev eth0
kernel: ll header: 00:04:75:fd:13:cd:00:0d:bc:ef:a6:8e:08:00
kernel: martian source 192.168.1.1 from 192.168.2.2, on dev eth0
kernel: ll header: 00:04:75:fd:13:cd:00:0d:bc:ef:a6:8e:08:00</screen>
    </listitem>
    </itemizedlist>
    </answer>
    </qandaentry>
  </qandaset>
  </sect2>

  <sect2 xml:id='sysctl.tutorial'>
    <title>Pour aller plus loin !</title>

  <para>Les quelques paramètres des fonctions réseau du noyau Linux présentés
  ci-avant ne constituent qu'une infime partie. Le document
  &url.ipsysctl.tutorial; présente l'ensemble des paramètres utilisables pour
  ajuster le fonctionnement de la pile de protocoles
  <acronym>TCP/IP</acronym>.</para>
  </sect2>
</sect1>
</article>
